// Â© Copyright 2018- 2022 - Elara AI Pty Ltd ACN 627 124 903
//
// Licensed under the EDK Licence version LICENSE-1.04.
//
// You may only use this file in accordance with the terms and conditions contained in EDK
// Licence - Version LICENSE-1.04. The full version of the EDK Licence is available at:
// https://elaraai.github.io/docs/license

import { ArrayType, EastType, StructType, StructValue, ValueTypeOf } from '../east/types';
import { EastFunction, EnvironmentType, TimeUnit, Variable } from '../east/functions';
import { PartitionDefinition, Table } from '../data/Table';
import { ELARASchema } from '../schema/ELARASchema';
import { Row } from "../data/data";
/** @internal */
export declare type Cache = {
    enabled?: boolean | null;
    invalidate?: EastFunction<"boolean">;
    remove?: EastFunction<"boolean">;
    uri?: StoreURI;
};
/**
 * Defines the persistance behaviour of a {@link DataSource}.
 *
 * @category Utility
 */
export declare type CacheDefinition = {
    /** set to true to enable the cache.*/
    enabled?: boolean;
    /** evaluate to true to invalidate (overwrite) a row in the cache.*/
    invalidate?: EastFunction<"boolean">;
    /** evaluate to true to remove a row from the cache */
    remove?: EastFunction<"boolean">;
    /** the optional {@link StoreURI} defining the location of the cache file **/
    uri?: StoreURI | URIString<'store://'>;
};
/**
 * Create a persistance behaviour of a {@link DataSource}.
 *
 * @param definition: the desired {@link CacheDefinition}.
 * @return a valid {@link Cache}
 *
 * @category Utility
 */
export declare function Cache(definition?: CacheDefinition): Cache;
/** @internal */
export declare type Poll = {
    value: number;
    unit: TimeUnit;
    datetime?: Variable<"datetime">;
    prev_datetime?: Variable<"datetime">;
    initial?: Variable<"boolean">;
};
/**
 * Defines the polling behaviour of a {@link DataSource}.
 *
 * @category Utility
 */
export declare type PollDefinition = {
    /** the polling period */
    value: number;
    /** the polling period unit */
    unit?: TimeUnit;
    /** the variable for the datetime of the current poll */
    datetime?: Variable<"datetime">;
    /** the variable for the datetime of the previous poll */
    prev_datetime?: Variable<"datetime">;
    /** the variable for the initilisation state of a {@link DataSource} */
    initial?: Variable<"boolean">;
};
/**
 * Create a polling behaviour of a {@link DataSource}.
 *
 * @param definition: the desired {@link PollDefinition}.
 * @return a valid {@link Poll}
 *
 * @category Utility
 */
export declare function Poll(definition: PollDefinition): Poll;
/**
 * A type of {@link URI} to describe the location of an asset (https://en.wikipedia.org/wiki/Uniform_Resource_Identifier).
 *
 * @category URI
 */
export declare type URIType = 'ftp' | 'sftp' | 'file' | 'http' | 'https' | 'mssql' | 'store';
/**
 * A type of {@link URIProtocol} to describe the protocol of a {@link URIType}.
 *
 * @category URI
 */
export declare type URIProtocol = 'ftp://' | 'sftp://' | 'http://' | 'https://' | 'mssql://' | 'file://' | 'store://';
/**
 * A string expression of a {@link URIType} for a particular {@link URIProtocol}.
 *
 * @category URI
 */
export declare type URIString<T extends URIProtocol = URIProtocol> = `${T}${string}`;
/** @internal */
export declare type URIProtocolTypeOf<T extends URIProtocol = URIProtocol> = T extends 'ftp://' ? 'ftp' : T extends 'store://' ? 'store' : T extends 'sftp://' ? 'sftp' : T extends 'http://' ? 'http' : T extends 'https://' ? 'https' : T extends 'mssql://' ? 'mssql' : T extends 'file://' ? 'file' : never;
/** @internal */
export declare type URIProtocolOf<T extends URIProtocol = URIProtocol> = T extends 'ftp://' ? FtpURI : T extends 'sftp://' ? SFtpURI : T extends 'http://' ? HttpURI : T extends 'https://' ? HttpsURI : T extends 'mssql://' ? MsSqlURI : T extends 'file://' ? FileURI : never;
/**
 * A type of {@link URI} for a file or directory.
 *
 * @remarks A file uri may describe a directory by appending a '/' to the path.
 *
 * @category URI
 */
export declare type FileTypeURI = {
    /** the path of the file or directory */
    path: EnvironmentType<"string">;
    /** the filter string to match (only valid for a dir path) */
    filter?: EnvironmentType<"string">;
    /** the regex flags to apply (only valid for a dir path) */
    flags?: EnvironmentType<"string">;
};
/** @internal */
export declare type FileTypeURIInstance = {
    path: string;
    filter?: string;
    flags?: string;
};
/**
 * A type of {@link URI} for a network file (such as ftp).
 *
 * @category URI
 */
export declare type NetworkFileTypeURI = {
    /** the {@link Expression} that evaluates to the hostname */
    host: EnvironmentType<"string">;
    /** the {@link Expression} that evaluates to the username */
    username?: EnvironmentType<"string">;
    /** the {@link Expression} that evaluates to the password */
    password?: EnvironmentType<"string">;
    /** the {@link Expression} that evaluates to the port */
    port?: EnvironmentType<"string">;
};
/** @internal */
export declare type NetworkFileTypeURIInstance = {
    host: string;
    username?: string;
    password?: string;
    port?: string;
};
/**
 * A type of {@link URI} for an mssql connection of the form mssql://[server[:port]]/[instance]/[database].
 *
 * @category URI
 */
export declare type MsSqlURI = {
    /** the {@link URIType} */
    type: 'mssql';
    /** the {@link Expression} that evaluates to the server name */
    server: EnvironmentType<"string">;
    /** the {@link Expression} that evaluates to the database name */
    database: EnvironmentType<"string">;
    /** the {@link Expression} that evaluates to the port */
    port?: EastFunction<"string">;
    /** the {@link Expression} that evaluates to the instance name */
    instance?: EnvironmentType<"string">;
};
/** @internal */
export declare type MsSqlURIInstance = {
    type: 'mssql';
    server: string;
    database: string;
    port?: string;
    instance?: string;
};
/**
 * Create a {@link MsSqlURI} for an mssql connection of the form mssql://[server[:port]]/[instance]/[database].
 *
 * @param definition: the desired {@link MsSqlURI}
 * @returns a valid {@link MsSqlURI}
 *
 * @category URI
 *
 * @example
 * ```typescript
 *  // Create a `MsSqlURI` for mssql://server:port/instance/database
 *  const uri = MsSqlURI({
 *      server: Const('server'),
 *      database: Const('database'),
 *      instance: Const('instance'),
 *      port: Const('port')
 *  })
 * ```
 */
export declare function MsSqlURI(uri: Omit<MsSqlURI, 'type'>): MsSqlURI;
/**
 * Create a {@link FtpURI} of the form ftp://user:password@host:port/path/?filter=XXX for a directory, or ftp://user:password@host:port/path for a file.
 *
 * @category URI
 */
export declare type FtpURI = FileTypeURI & NetworkFileTypeURI & {
    /** the {@link URIType} */
    type: 'ftp';
};
/**
 * Create a {@link FtpURI} of the form ftp://user:password@host:port/path/?filter=XXX for a directory, or ftp://user:password@host:port/path for a file.
 *
 * @param definition: the desired {@link FtpURI}
 * @returns a valid {@link FtpURI}
 *
 * @category URI
 *
 * @example
 * ```typescript
 *  // Create a `FtpURI` for ftp://user:password@host:port/dir/file.csv
 *  const uri = FtpURI({
 *      path: Const('dir/file.csv'),
 *      host: Const('host'),
 *      user: Const('user'),
 *      password: Const('password'),
 *      port: Const('21')
 *  })
 * ```
 *
 * @example
 * ```typescript
 *  // Create a `FtpURI` for csv's at ftp://host/dir/?filter=csv
 *  const uri = FtpURI({
 *      path: Const('dir/'),
 *      host: Const('host')
 *      filter: Const('csv'),
 *      user: Const('user'),
 *      password: Const('password'),
 *      port: Const('21')
 *  })
 * ```
 */
export declare function FtpURI(uri: Omit<FtpURI, 'type'>): FtpURI;
/** @internal */
export declare type FtpURIInstance = FileTypeURIInstance & NetworkFileTypeURIInstance & {
    type: 'ftp';
};
/**
 * Create a {@link StoreURI} of the form store://path/?filter=XXX for a directory, or store://path for a file in the ELARA services file store.
 *
 * @category URI
 */
export declare type StoreURI = FileTypeURI & {
    /** the {@link URIType} */
    type: 'store';
};
/**
 * Create a {@link StoreURI} of the form store://path/?filter=XXX for a directory, or store://path for a file in the ELARA services file store.
 *
 * @param definition: the desired {@link StoreURI}
 * @returns a valid {@link StoreURI}
 *
 * @category URI
 *
 * @example
 * ```typescript
 *  // Create a `StoreURI` for store://dir/file.csv
 *  const uri = StoreURI({
 *      path: Const('dir/file.csv'),
 *  })
 * ```
 *
 * @example
 * ```typescript
 *  // Create a `StoreURI` for csv's at store://dir/?filter=csv
 *  const uri = StoreURI({
 *      path: Const('dir/'),
 *      filter: Const('csv'),
 *  })
 * ```
 */
export declare function StoreURI(uri: Omit<StoreURI, 'type'>): StoreURI;
/** @internal */
export declare type StoreURIInstance = FileTypeURIInstance & {
    type: 'store';
};
/**
 * Create a {@link SFtpURI} of the form ftps://user:password@host:port/path/?filter=XXX for a directory, or ftps://user:password@host:port/path for a file
 *
 * @category URI
 */
export declare type SFtpURI = FileTypeURI & NetworkFileTypeURI & {
    /** the {@link URIType} */
    type: 'sftp';
};
/**
 * Create a {@link SFtpURI} of the form ftps://user:password@host:port/path/?filter=XXX for a directory, or ftps://user:password@host:port/path for a file
 *
 * @param definition: the desired {@link SFtpURI}
 * @returns a valid {@link SFtpURI}
 *
 * @category URI
 *
 * @example
 * ```typescript
 *  // Create a `SFtpURI` for ftps://user:password@host:port/dir/file.csv
 *  const uri = SFtpURI({
 *      path: Const('dir/file.csv'),
 *      host: Const('host'),
 *      user: Const('user'),
 *      password: Const('password'),
 *      port: Const('21')
 *  })
 * ```
 *
 * @example
 * ```typescript
 *  // Create a `SFtpURI` for csv's at ftps://user:password@host:port/dir/path/?.csv
 *  const uri = FtpURI({
 *      path: Const('dir/file.csv'),
 *      host: Const('host')
 *      filter: Const('csv'),
 *      user: Const('user'),
 *      password: Const('password'),
 *      port: Const('21')
 *  })
 * ```
 */
export declare function SFtpURI(uri: Omit<SFtpURI, 'type'>): SFtpURI;
/** @internal */
export declare type SFtpURIInstance = FileTypeURIInstance & NetworkFileTypeURIInstance & {
    type: 'sftp';
};
/**
 * A type of {@link URI} for a file connection of the form file://path/?filter=XXX for a directory, or file://path for a file.
 *
 * @category URI
 */
export declare type FileURI = FileTypeURI & {
    /** the {@link URIType} */
    type: 'file';
};
/**
 * A type of {@link URI} for a file connection of the form file://path/?filter=XXX for a directory, or file://path for a file.
 *
 * @param definition: the desired {@link SFtpURI}
 * @returns a valid {@link SFtpURI}
 *
 * @category URI
 *
 * @example
 * ```typescript
 *  // Create a `FileURI` for file://path/file.csv:
 *  const uri = FileURI({
 *      path: Const('path/file.csv'),
 *  })
 * ```
 *
 * @example
 * ```typescript
 *  // Create a `FileURI` for file://path/?filter=csv':
 *  const uri = FileURI({
 *      path: Const('path/'),
 *      filter: Const('csv')
 *  })
 * ```
 */
export declare function FileURI(uri: Omit<FileURI, 'type'>): FileURI;
/** @internal */
export declare type FileURIInstance = FileTypeURIInstance & {
    type: 'file';
};
/**
 * A type of {@link URI} for an http uri of the form http://hostname/path.
 *
 * @category URI
 */
export declare type HttpURI = {
    /** the {@link URIType} */
    type: 'http';
    /** the {@link Expression} that evaluates to the url */
    url: EastFunction<"string">;
};
/**
 * Create a {@link HttpURI} of the form http://hostname/path.
 *
 * @param definition: the desired {@link HttpURI}
 * @returns a valid {@link HttpURI}
 *
 * @category URI
 *
 * @example
 * ```typescript
 *  // Create a `HttpURI` for an endpoint:
 *  const uri = HttpURI({
 *      url: 'http://someurl.com',
 *  })
 * ```
 */
export declare function HttpURI(uri: Omit<HttpURI, 'type'>): HttpURI;
/** @internal */
export declare type HttpURIInstance = {
    type: 'http';
    url: string;
};
/**
 * A type of {@link URI} for an https connection of the form https://hostname/path.
 *
 * @category URI
 */
export declare type HttpsURI = {
    /** the {@link URIType} */
    type: 'https';
    /** the {@link Expression} that evaluates to the url */
    url: EastFunction<"string">;
};
/**
 * Create a {@link HttpsURI} of the form https://hostname/path.
 *
 * @param definition: the desired {@link HttpsURI}
 * @returns a valid {@link HttpsURI}
 *
 * @category URI
 *
 * @example
 * ```typescript
 *  // Create a `HttpsURI` for an endpoint:
 *  const uri = HttpsURI({
 *      url: 'https://someurl.com',
 *  })
 * ```
 */
export declare function HttpsURI(uri: Omit<HttpsURI, 'type'>): HttpsURI;
/** @internal */
export declare type HttpsURIInstance = {
    type: 'https';
    url: string;
};
/**
 * A {@link URI} for a connection to an asset.
 *
 * @category URI
 */
export declare type URI = StoreURI | MsSqlURI | FtpURI | SFtpURI | FileURI | HttpURI | HttpsURI;
/** @internal */
export declare type URIInstance = StoreURIInstance | MsSqlURIInstance | FtpURIInstance | SFtpURIInstance | FileURIInstance | HttpURIInstance | HttpsURIInstance;
/** @internal */
export declare function isURI(path: URI | URIString | EastFunction): path is URI;
/** @internal */
export declare function checkURI(value: URIString): void;
/** @internal */
export declare function toURI<T extends URIProtocol = URIProtocol>(value: URIString<T>): URIProtocolOf<T>;
/** @internal */
export declare function toURIType(value: URI | URIString): URIType;
/** @internal */
export declare function evaluateURI<T extends URI>(uri: T): URIInstance;
/** @internal */
export declare type SingleSource = {
    source_type: 'single_source';
    name: string;
    output?: Table;
    filter?: EastFunction<"boolean">;
    selections?: Record<string, EastFunction>;
    offline?: boolean;
    cache?: Cache;
};
/** @internal */
export declare type MultiSourceOutput = {
    table?: Table;
    filter?: EastFunction<"boolean">;
    selections?: Record<string, EastFunction>;
    cache?: Cache;
};
/** @internal */
export declare type MultiSource = {
    source_type: 'multi_source';
    name: string;
    offline?: boolean;
    outputs: Record<string, MultiSourceOutput>;
};
/** @internal */
export declare type ArraySource = SingleSource & {
    type: "array";
    rows: Row[];
    offline?: undefined;
    poll?: undefined;
    index_variable?: Variable<'integer'>;
};
/**
 * Defines a {@link DataSource} that creates an output {@link Table} and streams {@link Row}'s from an array.
 *
 * @category Procedural
 */
export declare type ArraySourceDefinition = {
    /** @internal */
    type: "array";
    /** the name of the {@link DataSource} */
    name: string;
    /** the array of data */
    rows: Row[];
    /** the {@link Expression} key that evaluates to a unique value */
    primary_key?: EastFunction<"string">;
    /** evaluate to false to exclude a {@link Row} in the output */
    filter?: EastFunction<"boolean">;
    /** a `Record` of the evaluated {@link Expression}'s */
    selections?: Record<string, EastFunction>;
    /** the {@link Partition}'s generated by the {@link Table} */
    partitions?: Record<string, PartitionDefinition>;
    /**  a {@link Variable} containing each row number in the {@link DataSource}. */
    index_variable?: Variable<'integer'>;
};
/** @internal */
export declare function fromArraySource(source: ArraySource): ArraySourceDefinition;
/**
 * Create a {@link DataSource} that creates an output {@link Table} and streams {@link Row}'s from an array.
 *
 * @param definition: the desired {@link ArraySourceDefinition}
 * @returns a valid {@link ArraySourceDefinition}
 *
 * @category Procedural
 * @remarks Note that selections in an {@link ArraySourceDefinition} should apply a {@link Parse} function to interpret formatting in source data.
 *
 * @example
 *  ```typescript
 *  // create the ArraySourceDefinition, note that the selections apply a Parse
 *  const source = ArraySource({
 *      name: 'Array',
 *      primary_key: Variable('id', 'string'),
 *      selections: {
 *          id: Parse(Variable('id', 'string'))
 *          date: Parse(Variable('date', 'datetime')),
 *          object: Parse(Variable('object', StructType({ count: 'integer', date: 'datetime' })))
 *          array: Parse(Variable('object', ArrayType(DictType('float'))),
 *      },
 *      rows: [{
 *          id: "1234",
 *          date: '2021-01-04T00:02:24.961Z',
 *          object: {
 *              count: 1000000n,
 *              date: '2021-03-05T00:05:33.213Z',
 *          },
 *          array: [
 *              { "one": 5.0, "two": 5.0 },
 *              { "two": 4.0, "three": 5.0 },
 *          ]
 *      }]
 *  })
 * ```
 */
export declare function ArraySource(definition: Omit<ArraySourceDefinition, 'type'>): ArraySourceDefinition;
/**
 * Create a Schema containing a {@link DataSource} that creates an output {@link Table} and streams {@link Row}'s from an array.
 *
 * @param definition: the desired {@link ArraySourceDefinition}
 * @returns a valid {@link ArraySourceDefinition} within a {@link ELARASchema}
 *
 * @category Procedural
 * @remarks Note that selections in an {@link ArraySourceDefinition} should apply a {@link Parse} function to interpret formatting in source data.
 *
 * @example
 * ```typescript
 *  // create the ArraySource within a ELARASchema, note that the selections apply a Parse
 *  const source = ArraySourceSchema({
 *      name: 'Array',
 *      primary_key: Variable('id', 'string'),
 *      selections: {
 *          id: Parse(Variable('id', 'string'))
 *          date: Parse(Variable('date', 'datetime')),
 *          object: Parse(Variable('object', StructType({ count: 'integer', date: 'datetime' })))
 *          array: Parse(Variable('object', ArrayType(DictType('float'))),
 *      },
 *      rows: [{
 *          id: "1234",
 *          date: '2021-01-04T00:02:24.961Z',
 *          object: {
 *              count: 1000000n,
 *              date: '2021-03-05T00:05:33.213Z',
 *          },
 *          array: [
 *              { "one": 5.0, "two": 5.0 },
 *              { "two": 4.0, "three": 5.0 },
 *          ]
 *      }]
 *  })
 * ```
 */
export declare function ArraySourceSchema(definition: Omit<ArraySourceDefinition, "type">): ELARASchema;
/** @internal */
export declare type CsvSource = SingleSource & {
    type: "csv";
    uri: StoreURI | FileURI | FtpURI | SFtpURI | URIString<'store://' | 'file://' | 'ftp://' | 'sftp://'>;
    poll: Poll | null;
    skip_n: number | null;
    delimiter: string;
    index_variable?: Variable<'integer'>;
};
/**
 * Defines a {@link DataSource} that creates an output {@link Table} and streams {@link Row}'s from a csv file.
 *
 * @category File
 */
export declare type CsvSourceDefinition = {
    /** @internal */
    type: "csv";
    /** the name of the {@link DataSource} */
    name: string;
    /** the path of the datasource contents */
    uri: StoreURI | FileURI | FtpURI | SFtpURI | URIString<'store://' | 'file://' | 'ftp://' | 'sftp://'> | EnvironmentType<'string'>;
    /** the configuration of the {@link DataSource} {@link Poll} */
    poll?: Poll;
    /** the row number of rows to skip prior to parsing headers (0 index) */
    skip_n?: number;
    /** the delimiter on each line seperating between each value */
    delimiter?: string;
    /** the {@link Expression} key that evaluates to a unique value */
    primary_key?: EastFunction<"string">;
    /** evaluate to false to exclude a {@link Row} in the output  */
    filter?: EastFunction<"boolean">;
    /** a `Record` of the evaluated {@link Expression}'s */
    selections?: Record<string, EastFunction>;
    /** the {@link Partition}'s generated by the {@link Table} */
    partitions?: Record<string, PartitionDefinition>;
    /** set to true if the {@link DataSource} should run offline */
    offline?: boolean;
    /**  the configuration of the {@link Cache} for the {@link DataSource}. */
    cache?: Cache;
    /**  a {@link Variable} containing each row number in the {@link DataSource}. */
    index_variable?: Variable<'integer'>;
};
/**
 * Create a {@link DataSource} that creates an output {@link Table} and streams {@link Row}'s from a csv file.
 *
 * @param definition: the desired {@link CsvSourceDefinition}.
 * @returns a valid {@link CsvSourceDefinition}
 *
 * @category File
 * @remarks Note that selections in an {@link CsvSourceDefinition} should apply a {@link Parse} function to interpret formatting in source data.
 *
 * @example
 * ```typescript
 *  //To create an CsvSourceDefinition of some primitive data, removing the first 4 garbage rows:
 *  const source = CsvSource({
 *      name: 'Csv',
 *      uri: Const('files/some_ftp_file.csv'),
 *      headers: 5,
 *      primary_key: Variable('id', 'string'),
 *      selections: {
 *          id: Parse(Variable('id', 'string'))
 *          date: Parse(Variable('date', 'datetime')),
 *          number: Parse(Variable('float', 'float')),
 *          integer: Parse(Variable('integer', 'integer')),
 *          boolean: Parse(Variable('boolean', 'boolean')),
 *      }
 *  })
 * ```
 */
export declare function CsvSource(definition: Omit<CsvSourceDefinition, 'type'>): CsvSourceDefinition;
/**
 * Create a {@link ELARASchema} containing a {@link DataSource} that creates an output {@link Table} and streams {@link Row}'s from a csv file.
 *
 * @param definition: the desired {@link CsvSourceDefinition}.
 * @returns a valid {@link CsvSourceDefinition} within a {@link ELARASchema}
 *
 * @category File
 * @remarks Note that selections in an {@link CsvSourceDefinition} should apply a {@link Parse} function to interpret formatting in source data.
 *
 * @example
 * ```typescript
 *  //To create an CsvSource within an ELARASchema of some primitive data, removing the first 5 garbage rows:
 *  const source = CsvSourceSchema({
 *      name: 'Csv',
 *      uri: Const('files/some_ftp_file.csv'),
 *      remove_top_n: 5,
 *      primary_key: Variable('id', 'string'),
 *      selections: {
 *          id: Parse(Variable('id', 'string'))
 *          date: Parse(Variable('date', 'datetime')),
 *          number: Parse(Variable('float', 'float')),
 *          integer: Parse(Variable('integer', 'integer')),
 *          boolean: Parse(Variable('boolean', 'boolean')),
 *      }
 *  })
 * ```
 */
export declare function CsvSourceSchema(definition: Omit<CsvSourceDefinition, "type">): ELARASchema;
/** @internal */
export declare type JsonSource = SingleSource & {
    type: "json";
    uri: StoreURI | FileURI | FtpURI | SFtpURI | URIString<'store://' | 'file://' | 'ftp://' | 'sftp://'>;
    poll: Poll | null;
    index_variable?: Variable<'integer'>;
};
/**
 * Defines a {@link DataSource} that creates an output {@link Table} and streams {@link Row}'s from a Json lines file https://jsonlines.org/examples/.
 *
 * @category File
 */
export declare type JsonSourceDefinition = {
    /** @internal */
    type: "json";
    /** the name of the {@link DataSource} */
    name: string;
    /** the path of the datasource contents */
    uri: StoreURI | FileURI | FtpURI | SFtpURI | URIString<'store://' | 'file://' | 'ftp://' | 'sftp://'> | EnvironmentType<'string'>;
    /** the configuration of the {@link DataSource} {@link Poll} */
    poll?: Poll;
    /** a `Record` of the evaluated {@link Expression}'s */
    selections?: Record<string, EastFunction>;
    /** the {@link Expression} key that evaluates to a unique value */
    primary_key?: EastFunction<"string">;
    /** evaluate to false to exclude a {@link Row} in the output */
    filter?: EastFunction<"boolean">;
    /** the {@link Partition}'s generated by the {@link Table} */
    partitions?: Record<string, PartitionDefinition>;
    /** set to true if the {@link DataSource} should run offline */
    offline?: boolean;
    /**  the configuration of the {@link Cache} for the {@link DataSource}. */
    cache?: Cache;
    /**  a {@link Variable} containing each row number in the {@link DataSource}. */
    index_variable?: Variable<'integer'>;
};
/**
 * Create a {@link DataSource} that creates an output {@link Table} and streams {@link Row}'s from a Json lines file (https://jsonlines.org/).
 *
 * @param definition: the desired {@link JsonSourceDefinition}.
 * @returns a valid {@link JsonSourceDefinition}
 *
 * @category File
 * @remarks Note that selections in an {@link JsonSourceDefinition} should apply a {@link Parse} function to interpret formatting in source data.
 *
 * @example
 * ```typescript
 *  // Create a complex type of the JSON data.
 *  const json_type = ArrayType(StructType({
 *      string: 'string',
 *      date: 'datetime',
 *      struct: StructType({
 *          string: 'string',
 *          date: 'datetime'
 *      }),
 *  }))
 *  // Create a JsonSourceDefinition of some complex data in a Json file:
 *  const source = JsonSource({
 *      name: 'Json',
 *      uri: Const('files/test.json'),
 *      primary_key: Variable('string', 'string'),
 *      filter: Const(true),
 *      body: Parse(Variable('body', json_type)),
 *      body_variable: Variable('body', json_type),
 *      value: Variable('body', json_type),
 *  })
 * ```
 */
export declare function JsonSource(definition: Omit<JsonSourceDefinition, 'type'>): JsonSourceDefinition;
/**
 * Create a {@link ELARASchema} containing a {@link DataSource} that creates an output {@link Table} and streams {@link Row}'s from a Json file.
 *
 * @param definition: the desired {@link JsonSourceDefinition}
 * @returns a valid {@link JsonSourceDefinition} within a {@link ELARASchema}
 *
 * @category File
 * @remarks Note that selections in an {@link JsonSourceDefinition} should apply a {@link Parse} function to interpret formatting in source data.
 *
 * @example
 * ```typescript
 *  // Create a complex type of the JSON data.
 *  const json_type = ArrayType(StructType({
 *      string: 'string',
 *      date: 'datetime',
 *      struct: StructType({
 *          string: 'string',
 *          date: 'datetime'
 *      }),
 *  }))
 *  // Create a JsonSourceDefinition within a ELARASchema of some complex data in a Json file:
 *  const source = JsonSourceSchema({
 *      name: 'Json',
 *      uri: Const('files/test.json'),
 *      primary_key: Variable('string', 'string'),
 *      filter: Const(true),
 *      body: Parse(Variable('body', json_type)),
 *      body_variable: Variable('body', json_type),
 *      value: Variable('body', json_type),
 *  })
 * ```
 */
export declare function JsonSourceSchema(definition: Omit<JsonSourceDefinition, "type">): ELARASchema;
/** @internal */
export declare type ExcelSource = MultiSource & {
    type: "xlsx";
    uri: StoreURI | FileURI | FtpURI | SFtpURI | URIString<'store://' | 'file://' | 'ftp://' | 'sftp://'>;
    poll: Poll | null;
    outputs: Record<string, {
        index_variable?: Variable<'integer'> | null;
    }>;
};
/**
 * Defines a {@link ExcelWorksheetDefinition} that creates an output {@link Table} and streams {@link Row}'s from an xlsx worksheet.
 *
 * @category File
 */
export declare type ExcelWorksheetDefinition = {
    /** the {@link Expression} key that evaluates to a unique value */
    primary_key?: EastFunction<"string">;
    /** evaluate to false to exclude a {@link Row} in the output */
    filter?: EastFunction<"boolean">;
    /** a `Record` of the evaluated {@link Expression}'s */
    selections?: Record<string, EastFunction>;
    /** the {@link Partition}'s generated by the {@link Table} */
    partitions?: Record<string, PartitionDefinition>;
    /**  the configuration of the {@link Cache} for the {@link DataSource}. */
    cache?: Cache;
    /**  a {@link Variable} containing each row number in the {@link DataSource}. */
    index_variable?: Variable<'integer'>;
};
/**
 * Create a {@link ExcelWorksheetDefinition} that creates an output {@link Table} and streams {@link Row}'s from an xlsx worksheet.
 *
 * @param definition: the desired {@link ExcelWorksheetDefinition}
 * @returns a valid {@link ExcelWorksheetDefinition}
 *
 * @category File
 * @remarks Note that selections in an {@link ExcelWorksheetDefinition} should apply a {@link Parse} function to interpret formatting in source data.
 *
 * @example
 * ```typescript
 *  //To create an ExcelWorksheetDefinition of some primitive data:
 *  const source = ExcelWorksheet({
 *      primary_key: Variable('id', 'string'),
 *      selections: {
 *          id: Parse(Variable('id', 'string'))
 *          date: Parse(Variable('date', 'datetime')),
 *          number: Parse(Variable('float', 'float')),
 *          integer: Parse(Variable('integer', 'integer')),
 *          boolean: Parse(Variable('boolean', 'boolean')),
 *      }
 *  })
 * ```
 */
export declare function ExcelWorksheet(definition: ExcelWorksheetDefinition): ExcelWorksheetDefinition;
/**
 * Defines a {@link DataSource} that creates an output {@link Table} and streams {@link Row}'s from a xlsx file.
 *
 * @category File
 */
export declare type ExcelSourceDefinition = {
    /** @internal */
    type: "xlsx";
    /** the name of the ArraySource */
    name: string;
    /** the path of the datasource contents */
    uri: StoreURI | FileURI | FtpURI | SFtpURI | URIString<'store://' | 'file://' | 'ftp://' | 'sftp://'> | EnvironmentType<'string'>;
    /** set to true if the {@link DataSource} should run offline */
    offline?: boolean;
    /** the configuration of the {@link DataSource} {@link Poll} */
    poll?: Poll;
    /** the {@link ExcelWorksheetDefinition}'s within the spreadsheet */
    worksheets?: Record<string, ExcelWorksheetDefinition>;
};
/**
 * Create a {@link DataSource} that creates an output {@link Table} and streams {@link Row}'s from a xlsx file.
 *
 * @param definition: the desired {@link ExcelSourceDefinition}
 * @returns a valid {@link ExcelSourceDefinition}
 *
 * @category File
 * @remarks Note that selections in an {@link ExcelSourceDefinition} should apply a {@link Parse} function to interpret formatting in source data.
 *
 * @example
 * ```typescript
 *  // Create a ExcelSourceDefinition of some data in an Xlsx file:
 *  const source = ExcelSource({
 *      name: 'Excel',
 *      uri: Const('files/test.xlsx'),
 *      worksheets: {
 *          'Sheet 1': ExcelWorksheet({
 *              primary_key: Variable('string', 'string'),
 *              selections: {
 *                  id: Parse(Variable('id', 'string'))
 *                  date: Parse(Variable('date', 'datetime')),
 *                  number: Parse(Variable('float', 'float')),
 *                  integer: Parse(Variable('integer', 'integer')),
 *                  boolean: Parse(Variable('boolean', 'boolean')),
 *              }
 *          }),
 *          'Sheet 2': ExcelWorksheet({
 *              primary_key: Variable('string', 'string'),
 *              selections: {
 *                  id: Parse(Variable('id', 'string'))
 *                  date: Parse(Variable('date', 'datetime')),
 *                  number: Parse(Variable('float', 'float')),
 *                  integer: Parse(Variable('integer', 'integer')),
 *                  boolean: Parse(Variable('boolean', 'boolean')),
 *              }
 *          })
 *      }
 *  })
 * ```
 */
export declare function ExcelSource(definition: Omit<ExcelSourceDefinition, 'type'>): ExcelSourceDefinition;
/**
 * Create a {@link ELARASchema} containing a {@link DataSource} that creates an output {@link Table} and streams {@link Row}'s from a xlsx file.
 *
 * @param definition: the desired {@link ExcelSourceDefinition}
 * @returns a valid {@link ExcelSourceDefinition} within a {@link ELARASchema}
 *
 * @category File
 * @remarks Note that selections in an {@link ExcelSourceDefinition} should apply a {@link Parse} function to interpret formatting in source data.
 *
 * @example
 * ```typescript
 *  // Create a Schema containing an ExcelSourceDefinition of some data in an Xlsx file:
 *  const source = ExcelSourceSchema({
 *      name: 'Excel',
 *      uri: Const('files/test.xlsx'),
 *      worksheets: {
 *          'Sheet 1': ExcelWorksheet({
 *              primary_key: Variable('string', 'string'),
 *              selections: {
 *                  id: Parse(Variable('id', 'string'))
 *                  date: Parse(Variable('date', 'datetime')),
 *                  number: Parse(Variable('float', 'float')),
 *                  integer: Parse(Variable('integer', 'integer')),
 *                  boolean: Parse(Variable('boolean', 'boolean')),
 *              }
 *          }),
 *          'Sheet 2': ExcelWorksheet({
 *              primary_key: Variable('string', 'string'),
 *              selections: {
 *                  id: Parse(Variable('id', 'string'))
 *                  date: Parse(Variable('date', 'datetime')),
 *                  number: Parse(Variable('float', 'float')),
 *                  integer: Parse(Variable('integer', 'integer')),
 *                  boolean: Parse(Variable('boolean', 'boolean')),
 *              }
 *          })
 *      }
 *  })
 * ```
 */
export declare function ExcelSourceSchema(definition: Omit<ExcelSourceDefinition, "type">): ELARASchema;
/** @internal */
export declare type RangeSource = SingleSource & {
    type: "range";
    start: number;
    stop: number;
    step: number;
    field: Variable<"float">;
    offline?: undefined;
    poll?: undefined;
    cache?: undefined;
};
/**
 * Defines a {@link DataSource} that creates an output {@link Table} and streams a predefined range of {@link Row}'s.
 *
 * @category Procedural
 *
 */
export declare type RangeSourceDefinition = {
    /** @internal */
    type: "range";
    /** the name of the {@link DataSource} */
    name: string;
    /** the first number in the range */
    start: number;
    /** the last number in the range */
    stop: number;
    /** the step size for each {@link Row} */
    step: number;
    /** {@link Variable} containing the range value */
    field: Variable<"float">;
    /** evaluate to false to exclude a {@link Row} in the output */
    filter?: EastFunction<"boolean">;
    /** a `Record` of the evaluated {@link Expression}'s */
    selections?: Record<string, EastFunction>;
    /** the {@link Partition}'s generated by the {@link Table} */
    partitions?: Record<string, PartitionDefinition>;
};
/**
 * Create a {@link DataSource} that creates an output {@link Table} and streams a predefined range of {@link Row}'s.
 *
 * @param definition: the desired {@link RangeSourceDefinition}.
 * @returns a valid {@link RangeSourceDefinition}
 *
 * @category Procedural
 * @remarks Note that selections in an {@link RangeSourceDefinition} should apply a {@link Parse} function to interpret formatting in source data.
 *
 * @example
 * ```typescript
 *  //To create an RangeSourceDefinition from 1 to 10 in setps of 2, including the value as a string:
 *  const source = RangeSource({
 *      name: 'Range',
 *      start: 1,
 *      stop: 10,
 *      step: 2,
 *      field: Variable('value', 'float')
 *      selections: {
 *          string: StringJoin`Value is ${Variable('value', 'float')}`
 *      }
 *  })
 * ```
 */
export declare function RangeSource(definition: Omit<RangeSourceDefinition, 'type'>): RangeSourceDefinition;
/** @internal */
export declare function toRangeSource(def: Omit<RangeSourceDefinition, 'type'>): RangeSource;
/**
 * Create a {@link ELARASchema} containing a {@link DataSource} that creates an output {@link Table} and streams a predefined range of {@link Row}'s.
 *
 * @param definition: the desired {@link RangeSourceDefinition}
 * @returns a valid {@link RangeSourceDefinition} within a {@link ELARASchema}
 *
 * @category Procedural
 * @remarks Note that selections in an {@link RangeSourceDefinition} should apply a {@link Parse} function to interpret formatting in source data.
 *
 *
 * @example
 * ```typescript
 *  //To create an ELARASchema containing a RangeSourceDefinition from 1 to 10 in increments of 2, including the value as a string:
 *  const source = RangeSourceSchema({
 *      name: 'Range',
 *      start: 1,
 *      stop: 10,
 *      step: 2,
 *      field: Variable('value', 'float')
 *      selections: {
 *          string: StringJoin`Value is ${Variable('value', 'float')}`
 *      }
 *  })
 * ```
 */
export declare function RangeSourceSchema(definition: Omit<RangeSourceDefinition, "type">): ELARASchema;
/** @internal */
export declare type ClockSource = SingleSource & {
    type: "clock";
    offset: number;
    poll: Poll;
    past_cycles: number;
    future_cycles: number;
    cycle_variable?: Variable<"integer">;
    timezone_hours: number;
    cache?: undefined;
    offline?: undefined;
};
/**
 * Defines a {@link DataSource} that creates an output {@link Table} and streams time triggered {@link Row}'s.
 *
 * @category Procedural
 */
export declare type ClockSourceDefinition = {
    /** @internal */
    type: "clock";
    /** the name of the {@link DataSource} */
    name: string;
    /** the offset in the units to start from */
    offset?: number;
    /** the number of hours to subtract to account for timezone */
    timezone_hours?: number;
    /** the time period in units between rows */
    period: number;
    /** the unit of time for each row */
    unit: TimeUnit;
    /** the {@link Variable} for the date value */
    date_variable: Variable<"datetime">;
    /** the {@link Variable} for the cycle value */
    cycle_variable?: Variable<"integer">;
    /** the number of cycles in the past to include in the output */
    past_cycles: number;
    /** the number of cycles in the future to include in the output */
    future_cycles: number;
    /** evaluate to false to exclude a {@link Row} in the output  */
    filter?: EastFunction<"boolean">;
    /** a `Record` of the evaluated {@link Expression}'s */
    selections?: Record<string, EastFunction>;
    /** the {@link Partition}'s generated by the {@link Table} */
    partitions?: Record<string, PartitionDefinition>;
};
/**
 * Create a {@link DataSource} that creates an output {@link Table} and streams time triggered {@link Row}'s.
 *
 * @param definition: the desired {@link ClockSourceDefinition}
 * @returns a valid {@link ClockSourceDefinition}
 *
 * @category Procedural
 * @remarks Note that selections in an {@link ClockSourceDefinition} should apply a {@link Parse} function to interpret formatting in source data.
 *
 * @example
 * ```typescript
 *  //To create an ClockSourceDefinition producing rows for each day for ten 10 in the past, and 12 in the future:
 *  const source = ClockSource({
 *      name: 'Clock',
 *      period: 1,
 *      unit: 'day',
 *      date_variable: Variable('Tick', 'datetime'),
 *      cycle_variable: Variable('HourlyCycle', 'integer'),
 *      past_cycles: 10,
 *      future_cycles: 12,
 *      timezone_hours: 5, // 0 -> 19:00
 *      selections: {
 *          Iso: Print(Variable('Tick', 'datetime')),
 *      }
 *  })
 * ```
 */
export declare function ClockSource(definition: Omit<ClockSourceDefinition, 'type'>): ClockSourceDefinition;
/**
 * Create a {@link ELARASchema} containing a {@link DataSource} that creates an output {@link Table} and streams time triggered {@link Row}'s.
 *
 * @param definition: the desired {@link ClockSourceDefinition}
 * @returns a valid {@link ClockSourceDefinition} within a {@link ELARASchema}
 *
 * @category Procedural
 * @remarks Note that selections in an {@link ClockSourceDefinition} should apply a {@link Parse} function to interpret formatting in source data.
 *
 * @example
 * ```typescript
 *  //To create an ELARASchema containing a ClockSourceDefinition producing rows for each day for ten 10 in the past, and 12 in the future:
 *  const source = ClockSourceSchema({
 *      name: 'Clock',
 *      period: 1,
 *      unit: 'day',
 *      date_variable: Variable('Tick', 'datetime'),
 *      cycle_variable: Variable('HourlyCycle', 'integer'),
 *      past_cycles: 10,
 *      future_cycles: 12,
 *      timezone_hours: 5, // 0 -> 19:00
 *      selections: {
 *          Iso: Print(Variable('Tick', 'datetime')),
 *      }
 *  })
 * ```
 */
export declare function ClockSourceSchema(definition: Omit<ClockSourceDefinition, "type">): ELARASchema;
/** @internal */
export declare type SqlSourceOutput = {
    type: 'query';
    query: EnvironmentType<'string'>;
} | {
    type: 'csv';
    uri: StoreURI | FileURI | SFtpURI | FtpURI | URIString<'store://' | 'file://' | 'ftp://' | 'sftp://'>;
    delimiter: string;
    index_variable?: Variable<'integer'>;
    skip_n: number | null;
};
/** @internal */
export declare type SqlSource = MultiSource & {
    type: "sql";
    connection: MsSqlURI | URIString<'mssql://'>;
    username: EnvironmentType<"string">;
    password: EnvironmentType<"string">;
    domain: EnvironmentType<"string"> | null;
    trusted: boolean;
    poll: Poll | null;
    outputs: Record<string, SqlSourceOutput>;
};
/**
 * Defines a {@link SqlSourceQuery} that creates an output {@link Table} and streams {@link Row}'s from a sql query.
 *
 * @category Database
 */
export declare type SqlSourceQueryDefinition = {
    type: 'query';
    /** the query to execute, (alternatively a file path with a csv) */
    query: EnvironmentType<'string'>;
    /** the {@link Expression} key that evaluates to a unique value */
    primary_key?: EastFunction<"string">;
    /** evaluate to false to exclude a {@link Row} in the output */
    filter?: EastFunction<"boolean">;
    /** a `Record` of the evaluated {@link Expression}'s */
    selections?: Record<string, EastFunction>;
    /** the {@link Partition}'s generated by the {@link Table} */
    partitions?: Record<string, PartitionDefinition>;
    /**  the configuration of the {@link Cache} for the {@link DataSource}. */
    cache?: Cache;
};
/**
 * Create a {@link SqlSourceQuery} that creates an output {@link Table} and streams {@link Row}'s from a sql query.
 *
 * @param definition: the desired {@link SqlSourceQueryDefinition}
 * @returns a valid {@link SqlSourceQueryDefinition}
 *
 * @category Database
 * @remarks Note that selections in an {@link SqlSourceQueryDefinition} should apply a {@link Parse} function to interpret formatting in source data.
 *
 * @example
 * ```typescript
 *  //To create an `SqlSourceQuery` of some primitive data:
 *  const source = SqlSourceQuery({
 *      query: "select * from dbo.table",
 *      primary_key: Variable('id', 'string'),
 *      selections: {
 *          id: Parse(Variable('id', 'string'))
 *          date: Parse(Variable('date', 'datetime')),
 *          number: Parse(Variable('float', 'float')),
 *          integer: Parse(Variable('integer', 'integer')),
 *          boolean: Parse(Variable('boolean', 'boolean')),
 *      }
 *  })
 * ```
 */
export declare function SqlSourceQuery(definition: Omit<SqlSourceQueryDefinition, "type">): SqlSourceQueryDefinition;
/**
 * Defines a {@link SqlSourceCsvDefinition} that creates an output {@link Table} and streams {@link Row}'s from a csv file.
 *
 * @category Database
 */
export declare type SqlSourceCsvDefinition = {
    type: 'csv';
    /** the query to execute, (alternatively a file path with a csv) */
    uri: StoreURI | FileURI | SFtpURI | FtpURI | URIString<'store://' | 'file://' | 'ftp://' | 'sftp://'>;
    /** the delimiter on each line seperating between each value */
    delimiter?: string;
    /** the row number of rows to skip prior to parsing headers (0 index) */
    skip_n?: number;
    /** the {@link Expression} key that evaluates to a unique value */
    primary_key?: EastFunction<"string">;
    /** evaluate to false to exclude a {@link Row} in the output */
    filter?: EastFunction<"boolean">;
    /** a `Record` of the evaluated {@link Expression}'s */
    selections?: Record<string, EastFunction>;
    /** the {@link Partition}'s generated by the {@link Table} */
    partitions?: Record<string, PartitionDefinition>;
    /**  the configuration of the {@link Cache} for the {@link DataSource}. */
    cache?: Cache;
    /**  a {@link Variable} containing each row number in the {@link DataSource}. */
    index_variable?: Variable<'integer'>;
};
/**
 * Create a {@link SqlSourceCsv} that creates an output {@link Table} and streams {@link Row}'s from a csv file.
 *
 * @param definition: the desired {@link SqlSourceCsvDefinition}
 * @returns a valid {@link SqlSourceCsvDefinition}
 *
 * @category Database
 * @remarks Note that selections in an {@link SqlSourceCsvDefinition} should apply a {@link Parse} function to interpret formatting in source data.
 *
 * @example
 * ```typescript
 *  //To create an `SqlSourceCsv` of some primitive data:
 *  const source = SqlSourceCsv({
 *      uri: "select * from dbo.table",
 *      primary_key: Variable('id', 'string'),
 *      selections: {
 *          id: Parse(Variable('id', 'string'))
 *          date: Parse(Variable('date', 'datetime')),
 *          number: Parse(Variable('float', 'float')),
 *          integer: Parse(Variable('integer', 'integer')),
 *          boolean: Parse(Variable('boolean', 'boolean')),
 *      }
 *  })
 * ```
 */
export declare function SqlSourceCsv(definition: Omit<SqlSourceCsvDefinition, "type">): SqlSourceCsvDefinition;
/**
 * Defines a {@link SqlSourceOutputDefinition} to decribe the output {@link Table} and streams {@link Row}'s from an {@link SqlSourceDefinition}.
 *
 * @category Database
 */
export declare type SqlSourceOutputDefinition = SqlSourceCsvDefinition | SqlSourceQueryDefinition;
/** @internal */
export declare function toSqlSourceOutput(def: SqlSourceOutputDefinition): SqlSourceOutput;
/**
 * Defines a {@link SqlSourceDefinition} that creates an output {@link Table} and streams {@link Row}'s of multiple queries a sql database.
 *
 * @category Database
 */
export declare type SqlSourceDefinition = {
    /** @internal */
    type: "sql";
    /** the name of the {@link DataSource} */
    name: string;
    /** the {@link MsSqlURI} for the connection */
    connection: MsSqlURI | URIString<'mssql://'>;
    /** the {@link EnvironmentType} that evaluates to the username */
    username: EnvironmentType<"string">;
    /** the {@link EnvironmentType} that evaluates to the password */
    password: EnvironmentType<"string">;
    /** the {@link EnvironmentType} that evaluates to the domain */
    domain?: EnvironmentType<"string">;
    /** true if a trusted conneciton (windows authentication) should be used */
    trusted?: boolean;
    /** set to true if the {@link DataSource} should run offline */
    offline?: boolean;
    /** the configuration of the {@link DataSource} {@link Poll} */
    poll?: Poll;
    /** the {@link SqlSourceOutput} to perform on the database */
    outputs?: Record<string, SqlSourceOutputDefinition>;
};
/**
 * Create a {@link SqlSourceDefinition} that creates an output {@link Table} and streams {@link Row}'s of multiple queries a sql database.
 *
 * @param definition: the desired {@link SqlSourceDefinition}
 * @returns a valid {@link SqlSourceDefinition}
 *
 * @remarks Note that selections in an {@link SqlSourceQuery} should apply a {@link Parse} function to interpret formatting in source data.
 * @remarks In order to simplify development an output may be defined from a csv file uri in place of a query.
 *
 * @category Database
 *
 * @example
 * ```typescript
 *  // Create a `SqlSource` of some data in some sql tables, and poll them every half second:
 *  const source = SqlSource({
 *      name: 'SQL',
 *      connection: MsSqlURI({
 *          server: "localhost",
 *          database: "DataSourceTest"
 *      }),
 *      poll: Poll({
 *          value: 0.5,
 *          unit: 'second',
 *          datetime: Variable("tick", 'datetime'),
 *          prev_datetime: Variable("prev_tick", 'datetime'),
 *      }),
 *      queries: {
 *          'Table One': SqlSourceQuery({
 *              query: "select * from dbo.table_one",
 *              primary_key: Variable('id', 'string'),
 *              selections: {
 *                  id: Parse(Variable('id', 'string'))
 *                  date: Parse(Variable('date', 'datetime')),
 *                  number: Parse(Variable('float', 'float')),
 *                  integer: Parse(Variable('integer', 'integer')),
 *                  boolean: Parse(Variable('boolean', 'boolean')),
 *              }
 *          }),
 *          'Table Two': SqlSourceCsv({
 *              path: "table.csv",
 *              primary_key: Variable('id', 'string'),
 *              selections: {
 *                  id: Parse(Variable('id', 'string'))
 *                  date: Parse(Variable('date', 'datetime')),
 *                  number: Parse(Variable('float', 'float')),
 *                  integer: Parse(Variable('integer', 'integer')),
 *                  boolean: Parse(Variable('boolean', 'boolean')),
 *              }
 *          })
 *      }
 *  })
 * ```
 */
export declare function SqlSource(definition: Omit<SqlSourceDefinition, 'type'>): SqlSourceDefinition;
/** @internal */
export declare function toSqlSource(def: Omit<SqlSourceDefinition, 'type'>): SqlSource;
/**
 * Create a Schema containing a {@link SqlSourceDefinition} that creates an output {@link Table} and streams {@link Row}'s of multiple queries a sql database.
 *
 * @param definition: the desired {@link ArraySourceDefinition}
 * @returns a valid {@link ArraySourceDefinition} within a {@link ELARASchema}
 *
 * @category Database
 * @remarks Note that selections in an {@link SqlSourceQuery} should apply a {@link Parse} function to interpret formatting in source data.
 *
 * @example
 * ```typescript
 *  // Create a Schema containing an SqlSource of some data in some sql tables, and poll them every half second:
 *  const source = SqlSourceSchema({
 *      name: 'SQL',
 *      username: Const("user"),
 *      password: Const("..."),
 *      connection: MsSqlURI({
 *          server: ELARA.Const("localhost"),
 *          database: ELARA.Const("DataSourceTest"),
 *      }),
 *      poll: Poll({
 *          value: 0.5,
 *          unit: 'second',
 *          datetime: Variable("tick", 'datetime'),
 *          prev_datetime: Variable("prev_tick", 'datetime'),
 *      }),
 *      queries: {
 *          'Table One': SqlSourceQuery({
 *              query: Const("select * from dbo.table_one"),
 *              primary_key: Variable('id', 'string'),
 *              selections: {
 *                  id: Parse(Variable('id', 'string'))
 *                  date: Parse(Variable('date', 'datetime')),
 *                  number: Parse(Variable('float', 'float')),
 *                  integer: Parse(Variable('integer', 'integer')),
 *                  boolean: Parse(Variable('boolean', 'boolean')),
 *              }
 *          }),
 *          TestTableFile: SqlSourceCsv({
 *              uri: Const("files/TestTable.csv"),
 *              primary_key: Variable("a string", 'string'),
 *              filter: Const(true),
 *              selections: {
 *                  'a string': Parse(Variable("a string", 'string')),
 *                  'a date': Parse(Variable("a date", 'datetime')),
 *                  'a number': Parse(Variable("a number", 'float')),
 *                  'a integer': Parse(Variable("a integer", 'integer')),
 *                  'a boolean': Parse(Variable("a boolean", 'boolean')),
 *                  'Another String': Parse(Variable("Another String", 'string')),
 *              },
 *          }),
 *      }
 *  })
 * ```
 */
export declare function SqlSourceSchema(definition: Omit<SqlSourceDefinition, "type">): ELARASchema;
/** @internal */
export declare type SqlChangeTrackingTable = {
    fields?: Record<string, EastType>;
    primary_key?: EastFunction<"string">;
    filter?: EastFunction<"boolean">;
    selections?: Record<string, EastFunction>;
    partitions?: Record<string, PartitionDefinition>;
};
/**
 * Defines a {@link SqlChangeTrackingTableDefinition} that creates an output {@link Table} and streams {@link Row}'s as incremental changes of an sql query.
 *
 * @category File
 */
export declare type SqlChangeTrackingTableDefinition = {
    /**  the query result columns and their {@link EastType}'s */
    fields?: Record<string, EastType>;
    /** the {@link Expression} key that evaluates to a unique value */
    primary_key?: EastFunction<"string">;
    /** evaluate to false to exclude a {@link Row} in the output */
    filter?: EastFunction<"boolean">;
    /** a `Record` of the evaluated {@link Expression}'s */
    selections?: Record<string, EastFunction>;
    /** the {@link Partition}'s generated by the {@link Table} */
    partitions?: Record<string, PartitionDefinition>;
};
/**
 * Create a {@link SqlChangeTrackingTableDefinition} that creates an output {@link Table} and streams {@link Row}'s as incremental changes of an sql query.
 *
 * @param definition: the desired {@link SqlChangeTrackingTableDefinition}
 * @returns a valid {@link SqlChangeTrackingTableDefinition}
 *
 * @category Database
 * @remarks Note that selections in an {@link SqlChangeTrackingTableDefinition} should apply a {@link Parse} function to interpret formatting in source data.
 *
 * @example
 * ```typescript
 *  //To create an SqlChangeTrackingTable of some query data:
 *  const source = SqlChangeTrackingTable({
 *      primary_key: Variable('id', 'string'),
 *      fields: {
 *          id: 'string',
 *          date: 'datetime',
 *          number: 'float',
 *          integer: 'integer',
 *          boolean: 'boolean',
 *      },
 *  })
 * ```
 */
export declare function SqlChangeTrackingTable(definition: SqlChangeTrackingTable): {
    fields: Record<string, EastType> | undefined;
    primary_key: EastFunction<"string"> | undefined;
    filter: EastFunction<"boolean"> | undefined;
    selections: Record<string, EastFunction<EastType>> | undefined;
    partitions: Record<string, PartitionDefinition> | undefined;
};
/** @internal */
export declare type SqlChangeTrackingSource = MultiSource & {
    type: "sql_change_tracking";
    initialize: string;
    update: string;
    connection: MsSqlURI | URIString<'mssql://'>;
    username: EnvironmentType<"string">;
    password: EnvironmentType<"string">;
    poll: Poll;
};
/**
 * Defines a {@link SqlChangeTrackingTableDefinition} that creates an output {@link Table} and streams {@link Row}'s incremental changes from multiple queries of a sql database.
 *
 * @category Database
 */
export declare type SqlChangeTrackingSourceDefinition = {
    /** @internal */
    type: "sql_change_tracking";
    /** the name of the {@link DataSource} */
    name: string;
    /** the stored prodecure name to initialise the database */
    initialize: string;
    /** the stored prodecure name to update get updates from the database */
    update: string;
    /** the `Record` of one or more {@link SqlChangeTrackingTable}'s to track */
    tables?: Record<string, SqlChangeTrackingTable>;
    /** the location of the server */
    connection: MsSqlURI | URIString<'mssql://'>;
    /** the {@link Expression} key that evaluates to the username */
    username: EnvironmentType<"string">;
    /** the {@link Expression} key that evaluates to the password */
    password: EnvironmentType<"string">;
    /** set to true if the {@link DataSource} should run offline */
    offline?: boolean;
    /** the configuration of the {@link DataSource} {@link Poll} */
    poll: Poll;
};
/**
 * Create a {@link SqlChangeTrackingTableDefinition} that creates an output {@link Table} and streams {@link Row}'s incremental changes from multiple queries of a sql database.
 *
 * @param definition: the desired {@link SqlChangeTrackingSourceDefinition}
 * @returns a valid {@link SqlChangeTrackingSourceDefinition}
 *
 * @remarks Note that selections in an {@link SqlChangeTrackingTable} should apply a {@link Parse} function to interpret formatting in source data.
 * @category Database
 *
 * @example
 * ```typescript
 *  // Create a SqlSource of some data in some sql tables, and poll them every half second:
 *  const source = SqlChangeTrackingSource({
 *      name: 'SQL Tracked',
 *      initialize: Const("INITIAL_DATA_NAME"),
 *      update: Const("UPDATE_DATA_NAME"),
 *      username: Const("user"),
 *      password: Const("..."),
 *      connection: MsSqlURI({
 *          server: ELARA.Const("localhost"),
 *          database: ELARA.Const("DataSourceTest"),
 *          port: Const(1433),
 *      }),
 *      poll: Poll({
 *          value: 0.5,
 *          unit: 'second',
 *          datetime: Variable("tick", 'datetime'),
 *          prev_datetime: Variable("prev_tick", 'datetime'),
 *      }),
 *      tables: {
 *          TRACKED_TABLE_1: SqlChangeTrackingTable({
 *              primary_key: Variable('TRACKED_TABLE_1_COL_1', 'string'),
 *              fields: {
 *                  TRACKED_TABLE_1_COL_1: 'string',
 *                  TRACKED_TABLE_1_COL_2: 'datetime',
 *                  // ...
 *                  TRACKED_TABLE_1_COL_N: 'integer'
 *              }
 *          }),
 *          // ...
 *          TRACKED_TABLE_N: SqlChangeTrackingTable({
 *              primary_key: Variable('TRACKED_TABLE_N_COL_1', 'string'),
 *              fields: {
 *                  TRACKED_TABLE_N_COL_1: 'string',
 *                  TRACKED_TABLE_N_COL_2: 'datetime',
 *                  // ...
 *                  TRACKED_TABLE_N_COL_N: 'integer'
 *              }
 *          })
 *      }
 *  })
 * ```
 * @remarks Note that a {@link SqlChangeTrackingTable} requires several changes to be made to the target database, including installtion of multiple stored procedures.
 *
 * @remarks To enable change tracking on a {@link SqlChangeTrackingSourceDefinition.database}.
 * @example
 * ```sql
 *  -- the SqlChangeTrackingSource requires some database settings to be updated to function, see below:
 *  ALTER DATABASE [DB_NAME]
 *  SET CHANGE_TRACKING = ON
 *  (CHANGE_RETENTION = 2 HOURS, AUTO_CLEANUP = ON)
 *
 *  ALTER DATABASE [DB_NAME]
 *  SET ALLOW_SNAPSHOT_ISOLATION ON
 *
 *  USE [DB_NAME]
 *  GO
 *
 *  -- configure change trackign on N relevant tables
 *  ALTER TABLE TRACKED_TABLE_1
 *  ENABLE CHANGE_TRACKING
 *  WITH (TRACK_COLUMNS_UPDATED = OFF)
 *
 *  -- ...
 *
 *  ALTER TABLE TRACKED_TABLE_N
 *  ENABLE CHANGE_TRACKING
 *  WITH (TRACK_COLUMNS_UPDATED = OFF)
 *
 *  GO
 * ```
 * @remarks To install the {@link SqlChangeTrackingSourceDefinition.initialize} script in the database.
 * @example
 * ```sql
 *  -- the SqlChangeTrackingSource requires an sql stored procedure to be installed on the target database to query for initial data
 *
 *  -- drop and then create the stored procedure
 *  USE [DB_NAME]
 *  GO
 *
 *  IF object_id('dbo.INITIAL_DATA_NAME', 'p') IS NOT NULL
 *      DROP PROCEDURE INITIAL_DATA_NAME
 *  GO
 *  CREATE PROCEDURE INITIAL_DATA_NAME
 *      @current_version bigint OUTPUT
 *  AS
 *  SET TRANSACTION ISOLATION LEVEL SNAPSHOT
 *  BEGIN TRANSACTION
 *
 *  -- always query the change tracking version
 *  SELECT @current_version = CHANGE_TRACKING_CURRENT_VERSION()
 *
 *  -- query the tracked tables
 *  SELECT  TRACKED_TABLE_1_COL_1,
 *          TRACKED_TABLE_1_COL_2,
 *          -- ...
 *          TRACKED_TABLE_1_COL_N
 *          FROM TRACKED_TABLE_1
 *
 *  -- ...
 *
 *  SELECT  TRACKED_TABLE_N_COL_1,
 *          TRACKED_TABLE_N_COL_2,
 *          -- ...
 *          TRACKED_TABLE_N_COL_N
 *          FROM TRACKED_TABLE_N
 *
 *  COMMIT TRANSACTION;
 *  GO
 * ```
 * @remarks To install the {@link SqlChangeTrackingSourceDefinition.update} script in the database.
 * @example
 * ```sql
 *  -- the SqlChangeTrackingSource requires an sql stored procedure to be installed on the target database to query for initial data
 *
 *  -- drop and then create the stored procedure
 *  USE [DB_NAME]
 *  GO
 *
 *  IF object_id('dbo.UPDATE_DATA_NAME', 'p') IS NOT NULL
 *      DROP PROCEDURE UPDATE_DATA_NAME
 *  GO
 *  CREATE PROCEDURE UPDATE_DATA_NAME
 *      @previous_version bigint,
 *      @min_valid_version bigint OUTPUT,
 *      @current_version bigint OUTPUT
 *  AS
 *  SET TRANSACTION ISOLATION LEVEL SNAPSHOT
 *  BEGIN TRANSACTION
 *
 *  -- query the change tracking version
 *  SELECT @current_version = CHANGE_TRACKING_CURRENT_VERSION()
 *
 *  -- query the minimum tracking version
 *  SELECT @min_valid_version = CHANGE_TRACKING_MIN_VALID_VERSION(OBJECT_ID('dbo.Containers'))
 *
 *  -- query the tracked tables and change table
 *  SELECT CT.Id
 *  FROM CHANGETABLE(CHANGES dbo.TRACKED_TABLE_1, @previous_version) AS CT
 *  WHERE CT.SYS_CHANGE_OPERATION = 'U' OR CT.SYS_CHANGE_OPERATION = 'D'
 *
 *  SELECT  CT.Id,
 *          TRACKED_TABLE_1_COL_1,
 *          TRACKED_TABLE_1_COL_2,
 *          -- ...
 *          TRACKED_TABLE_1_COL_N
 *  FROM CHANGETABLE(CHANGES dbo.TRACKED_TABLE_1, @previous_version) AS CT
 *  INNER JOIN dbo.TRACKED_TABLE_1 AS VT ON VT.Id = CT.Id
 *  WHERE (CT.SYS_CHANGE_OPERATION = 'U' OR CT.SYS_CHANGE_OPERATION = 'I')
 *
 *  -- ...
 *
 *  SELECT CT.Id
 *  FROM CHANGETABLE(CHANGES dbo.TRACKED_TABLE_N, @previous_version) AS CT
 *  WHERE CT.SYS_CHANGE_OPERATION = 'U' OR CT.SYS_CHANGE_OPERATION = 'D'
 *
 *  SELECT  CT.Id,
 *          TRACKED_TABLE_N_COL_1,
 *          TRACKED_TABLE_N_COL_2,
 *          -- ...
 *          TRACKED_TABLE_N_COL_N
 *  FROM CHANGETABLE(CHANGES dbo.TRACKED_TABLE_N, @previous_version) AS CT
 *  INNER JOIN dbo.TRACKED_TABLE_N AS VT ON VT.Id = CT.Id
 *  WHERE (CT.SYS_CHANGE_OPERATION = 'U' OR CT.SYS_CHANGE_OPERATION = 'I')
 *
 *  COMMIT TRANSACTION;
 *  GO
 * ```
 *
 */
export declare function SqlChangeTrackingSource(definition: Omit<SqlChangeTrackingSourceDefinition, 'type'>): SqlChangeTrackingSourceDefinition;
/**
 * Create a {@link ELARASchema} containing a {@link SqlChangeTrackingTableDefinition} that creates an output {@link Table} and streams {@link Row}'s incremental changes from multiple queries of a sql database.
 *
 * @param definition: the desired {@link SqlChangeTrackingSourceDefinition}
 * @returns a valid {@link SqlChangeTrackingSourceDefinition} within a {@link ELARASchema}
 *
 * @remarks Note that selections in an {@link SqlChangeTrackingTable} should apply a {@link Parse} function to interpret formatting in source data.
 * @category Database
 *
 * @example
 * ```typescript
 *  // To create an ELARASchema containing a SqlSource of some data in some sql tables, and poll them every half second:
 *  const source = SqlChangeTrackingSourceSchema({
 *      name: 'SQL Tracked',
 *      initialize: Const("INITIAL_DATA_NAME"),
 *      update: Const("UPDATE_DATA_NAME"),
 *      username: Const("user"),
 *      password: Const("..."),
 *      connection: MsSqlURI({
 *          server: ELARA.Const("localhost"),
 *          database: ELARA.Const("DataSourceTest"),
 *          port: Const(1433),
 *      }),
 *      poll: Poll({
 *          value: 0.5,
 *          unit: 'second',
 *          datetime: Variable("tick", 'datetime'),
 *          prev_datetime: Variable("prev_tick", 'datetime'),
 *      }),
 *      tables: {
 *          TRACKED_TABLE_1: SqlChangeTrackingTable({
 *              primary_key: Variable('TRACKED_TABLE_1_COL_1', 'string'),
 *              fields: {
 *                  TRACKED_TABLE_1_COL_1: 'string',
 *                  TRACKED_TABLE_1_COL_2: 'datetime',
 *                  // ...
 *                  TRACKED_TABLE_1_COL_N: 'integer'
 *              }
 *          }),
 *          // ...
 *          TRACKED_TABLE_N: SqlChangeTrackingTable({
 *              primary_key: Variable('TRACKED_TABLE_N_COL_1', 'string'),
 *              fields: {
 *                  TRACKED_TABLE_N_COL_1: 'string',
 *                  TRACKED_TABLE_N_COL_2: 'datetime',
 *                  // ...
 *                  TRACKED_TABLE_N_COL_N: 'integer'
 *              }
 *          })
 *      }
 *  })
 * ```
 * @remarks Note that a {@link SqlChangeTrackingTable} requires several changes to be made to the target database, including installtion of multiple stored procedures.
 *
 * @remarks To enable change tracking on a {@link SqlChangeTrackingSourceDefinition.database}.
 * @example
 * ```sql
 *  -- the SqlChangeTrackingSource requires some database settings to be updated to function, see below:
 *  ALTER DATABASE [DB_NAME]
 *  SET CHANGE_TRACKING = ON
 *  (CHANGE_RETENTION = 2 HOURS, AUTO_CLEANUP = ON)
 *
 *  ALTER DATABASE [DB_NAME]
 *  SET ALLOW_SNAPSHOT_ISOLATION ON
 *
 *  USE [DB_NAME]
 *  GO
 *
 *  -- configure change trackign on N relevant tables
 *  ALTER TABLE TRACKED_TABLE_1
 *  ENABLE CHANGE_TRACKING
 *  WITH (TRACK_COLUMNS_UPDATED = OFF)
 *
 *  -- ...
 *
 *  ALTER TABLE TRACKED_TABLE_N
 *  ENABLE CHANGE_TRACKING
 *  WITH (TRACK_COLUMNS_UPDATED = OFF)
 *
 *  GO
 * ```
 * @remarks To install the {@link SqlChangeTrackingSourceDefinition.initialize} script in the database.
 * @example
 * ```sql
 *  -- the SqlChangeTrackingSource requires an sql stored procedure to be installed on the target database to query for initial data
 *
 *  -- drop and then create the stored procedure
 *  USE [DB_NAME]
 *  GO
 *
 *  IF object_id('dbo.INITIAL_DATA_NAME', 'p') IS NOT NULL
 *      DROP PROCEDURE INITIAL_DATA_NAME
 *  GO
 *  CREATE PROCEDURE INITIAL_DATA_NAME
 *      @current_version bigint OUTPUT
 *  AS
 *  SET TRANSACTION ISOLATION LEVEL SNAPSHOT
 *  BEGIN TRANSACTION
 *
 *  -- always query the change tracking version
 *  SELECT @current_version = CHANGE_TRACKING_CURRENT_VERSION()
 *
 *  -- query the tracked tables
 *  SELECT  TRACKED_TABLE_1_COL_1,
 *          TRACKED_TABLE_1_COL_2,
 *          -- ...
 *          TRACKED_TABLE_1_COL_N
 *          FROM TRACKED_TABLE_1
 *
 *  -- ...
 *
 *  SELECT  TRACKED_TABLE_N_COL_1,
 *          TRACKED_TABLE_N_COL_2,
 *          -- ...
 *          TRACKED_TABLE_N_COL_N
 *          FROM TRACKED_TABLE_N
 *
 *  COMMIT TRANSACTION;
 *  GO
 * ```
 * @remarks To install the {@link SqlChangeTrackingSourceDefinition.update} script in the database.
 * @example
 * ```sql
 *  -- the SqlChangeTrackingSource requires an sql stored procedure to be installed on the target database to query for initial data
 *
 *  -- drop and then create the stored procedure
 *  USE [DB_NAME]
 *  GO
 *
 *  IF object_id('dbo.UPDATE_DATA_NAME', 'p') IS NOT NULL
 *      DROP PROCEDURE UPDATE_DATA_NAME
 *  GO
 *  CREATE PROCEDURE UPDATE_DATA_NAME
 *      @previous_version bigint,
 *      @min_valid_version bigint OUTPUT,
 *      @current_version bigint OUTPUT
 *  AS
 *  SET TRANSACTION ISOLATION LEVEL SNAPSHOT
 *  BEGIN TRANSACTION
 *
 *  -- query the change tracking version
 *  SELECT @current_version = CHANGE_TRACKING_CURRENT_VERSION()
 *
 *  -- query the minimum tracking version
 *  SELECT @min_valid_version = CHANGE_TRACKING_MIN_VALID_VERSION(OBJECT_ID('dbo.Containers'))
 *
 *  -- query the tracked tables and change table
 *  SELECT CT.Id
 *  FROM CHANGETABLE(CHANGES dbo.TRACKED_TABLE_1, @previous_version) AS CT
 *  WHERE CT.SYS_CHANGE_OPERATION = 'U' OR CT.SYS_CHANGE_OPERATION = 'D'
 *
 *  SELECT  CT.Id,
 *          TRACKED_TABLE_1_COL_1,
 *          TRACKED_TABLE_1_COL_2,
 *          -- ...
 *          TRACKED_TABLE_1_COL_N
 *  FROM CHANGETABLE(CHANGES dbo.TRACKED_TABLE_1, @previous_version) AS CT
 *  INNER JOIN dbo.TRACKED_TABLE_1 AS VT ON VT.Id = CT.Id
 *  WHERE (CT.SYS_CHANGE_OPERATION = 'U' OR CT.SYS_CHANGE_OPERATION = 'I')
 *
 *  -- ...
 *
 *  SELECT CT.Id
 *  FROM CHANGETABLE(CHANGES dbo.TRACKED_TABLE_N, @previous_version) AS CT
 *  WHERE CT.SYS_CHANGE_OPERATION = 'U' OR CT.SYS_CHANGE_OPERATION = 'D'
 *
 *  SELECT  CT.Id,
 *          TRACKED_TABLE_N_COL_1,
 *          TRACKED_TABLE_N_COL_2,
 *          -- ...
 *          TRACKED_TABLE_N_COL_N
 *  FROM CHANGETABLE(CHANGES dbo.TRACKED_TABLE_N, @previous_version) AS CT
 *  INNER JOIN dbo.TRACKED_TABLE_N AS VT ON VT.Id = CT.Id
 *  WHERE (CT.SYS_CHANGE_OPERATION = 'U' OR CT.SYS_CHANGE_OPERATION = 'I')
 *
 *  COMMIT TRANSACTION;
 *  GO
 * ```
 *
 */
export declare function SqlChangeTrackingSourceSchema(definition: Omit<SqlChangeTrackingSourceDefinition, "type">): ELARASchema;
/**
 * A http method.
 *
 * @category Network
 */
export declare type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";
/**
 * A http request mime type.
 *
 * @category Network
 */
export declare type HttpMimeType = "application/json" | "application/x-www-form-urlencoded";
/** @internal */
export declare type RestApiRequest = {
    url: HttpURI | HttpsURI;
    method: HttpMethod;
    accept?: HttpMimeType;
    content?: HttpMimeType;
    body?: EastFunction<EastType>;
    headers?: EastFunction<StructType>;
    paginate?: EastFunction<'boolean'>;
    retry?: EastFunction<'boolean'>;
    delay_ms?: EastFunction<'integer'>;
    failure_variable?: Variable<'boolean'>;
    n_pages_variable?: Variable<"integer">;
    n_attempts_variable?: Variable<"integer">;
    datetime_variable?: Variable<"datetime">;
};
/** @internal */
export declare function encodeBody(value: StructValue): string;
/** @internal */
export declare function evaluateRestApiRequest(request: RestApiRequest, context?: Row): {
    url: string;
    method: HttpMethod;
    body?: string;
    headers?: ValueTypeOf<StructType>;
};
/**
 * Defines a http request to generate a request to a server. The contents of the request is mostly East functions evaluated in the context of the last known response, and the token.
 *
 * @category Network
 */
export declare type RestApiRequestDefinition = {
    /** the url the request data from the request. */
    url?: HttpURI | HttpsURI | URIString<'http://' | 'https://'> | EastFunction<'string'>;
    /** the http method for the request */
    method: HttpMethod;
    /** the mime type accepted by the response */
    accept?: HttpMimeType;
    /**  the mime type of the request */
    content?: HttpMimeType;
    /**  a {@link EastFunction} for the body of the request */
    body?: EastFunction<EastType>;
    /** a {@link EastFunction} for the headers of the request */
    headers?: EastFunction<StructType>;
    /** evaluate to true if a second page request should be generated */
    paginate?: EastFunction<'boolean'>;
    /**  evaluate to true if the request should be retried */
    retry?: EastFunction<'boolean'>;
    /** an {@link EastFunction} defining the delay in ms until the next request (being a retry or page request) */
    delay_ms?: EastFunction<'integer'>;
    /** the variable set to true if an error occurs during request */
    failure_variable?: Variable<'boolean'>;
    /** the {@link Variable} containing the current page number (or index into pagniation) */
    n_pages_variable?: Variable<"integer">;
    /** the {@link Variable} containing the number of retry attempts for this request */
    n_attempts_variable?: Variable<"integer">;
    /** the {@link Variable} containing the date and time of the request */
    datetime_variable?: Variable<"datetime">;
};
/** A http request to generate a request to a server. The contents of the request is mostly East functions evaluated in the context of the last known response, and the token.
 *
 * @param definition: the desired {@link RestApiRequestDefinition}
 * @returns a valid {@link RestApiRequestDefinition}
 *
 * @category Network
 * @remarks Note that the context for evaluation of {@link EastFunction}'s is both the current environment, previous requests, and depending on `RestApiEndpoint` configuration may also include `token`, parent `response`, and  `poll` variables.
 *
 * @example
 * ```typescript
 *  // Create a `RestApiRequest` to query github for a user repos, where the a Github user id has been defined in an environment variable, and a valid token exists in scope form an `Authorisation` configuration:
 *  const source = RestApiRequest( {
 *      url: StringJoin`https://api.github.com/users/${Environment("GITHUB_USER")}/repos`,
 *      method: 'GET',
 *      accept: 'application/json',
 *      headers: Struct({
 *          Accept: Const("application/vnd.github.v3+json"),
 *          Authorization: StringJoin`token ${GetField(Variable("token", rest_token_response_body_type), "access_token")}`
 *      }),
 *      // retry if the number of allowable requests is exhausted (status_code comes form response scope)
 *      retry: And(
 *          Equal(Variable('status_code', 'integer'), 429n),
 *          LessEqual(Variable('n_attempts', 'integer'), 5n),
 *      ),
 *      // pause a minute if the number of allowable requests is exhausted (status_code comes form response scope)
 *      delay_ms: IfElse(
 *          Equal(Variable('status_code', 'integer'), 429n),
 *          Const(62000n),
 *          Const(400n)
 *      ),
 *      content: 'application/x-www-form-urlencoded',
 *      datetime_variable: Variable("request_datetime", 'datetime'),
 *  })
 * ```
 */
export declare function RestApiRequest(definition: RestApiRequestDefinition): RestApiRequestDefinition;
/** @internal */
export declare type RestApiResponse<T extends EastType = EastType> = {
    value?: EastFunction<T>;
    headers?: EastFunction<StructType>;
    headers_variable?: Variable<StructType>;
    status_code_variable?: Variable<"integer">;
    status_text_variable?: Variable<"string">;
    body?: EastFunction<EastType>;
    body_variable?: Variable<EastType>;
};
/** A http response to generate parse the repsonse from a server. The contents of the response is mostly East functions evaluated in the context of the last known response, request, and the token.
 *
 *  @category Network
 */
export declare type RestApiResponseDefinition<T extends EastType = EastType> = {
    /** a {@link EastFunction} to be evaluated to the response output */
    value?: EastFunction<T>;
    /** a {@link EastFunction} for the headers of the request */
    headers?: EastFunction<StructType>;
    /** the {@link Variable} containing the response headers */
    headers_variable?: Variable<StructType>;
    /** the {@link Variable} containing the response status body */
    status_code_variable?: Variable<"integer">;
    /** the {@link Variable} containing the response status text */
    status_text_variable?: Variable<"string">;
    /** the {@link EastFunction} to be evaluated to update the body */
    body?: EastFunction<EastType>;
    /** the {@link Variable} containing the response body */
    body_variable?: Variable<EastType>;
};
/** A http response to generate parse the repsonse from a server. The contents of the response is mostly East functions evaluated in the context of the last known response, request, and the token.
 *
 * @param definition: the desired {@link RestApiResponse}
 * @returns a valid {@link RestApiResponse}
 *
 * @category Network
 * @remarks Note that the context for evaluation of {@link EastFunction}'s is both the current environment, previous requests, and depending on `RestApiEndpoint` configuration may also include `token`, parent `response`, and  `poll` variables.
 *
 * @example
 * ```typescript
 *  // create a 'repos' request response body type
 *  const response_body_type = ArrayType(StructType({
 *      id: 'float',
 *      node_id: 'string',
 *      name: 'string',
 *      full_name: 'string',
 *      url: 'string',
 *      description: 'string',
 *      owner: StructType({
 *          login: 'string',
 *          id: 'float',
 *          url: 'string',
 *      }),
 *  }));
 *
 *  // create a 'repos' request response header type
 *  const response_header_type = StructType({
 *      server: 'string',
 *      connection: 'string',
 *      // ...
 *      etag: 'string',
 *  });
 *
 *  // Create a RestApiResponse to a github for a user repos response:
 *  const source = RestApiResponse({
 *      headers: Parse(Variable("headers", response_header_type)),
 *      headers_variable: Variable("headers", response_header_type),
 *      body: Parse(Variable("body", response_body_type)),
 *      body_variable: Parse(Variable("body", response_body_type))
 *      value: Parse(Variable("body", response_body_type))
 *      status_code_variable: Variable("status_code", 'integer'),
 *      status_text_variable: Variable("status_text", 'integer'),
 *  })
 * ```
 */
export declare function RestApiResponse<T extends EastType = EastType>(config: RestApiResponseDefinition<T>): RestApiResponseDefinition<T>;
/**
 * Defines an http {@link RestApiRequest} and {@link RestApiResponse} to generate a request to a server following a parent {@link RestApiResponse} and {@link RestApiRequest}.
 *
 * @category Network
 */
export declare type RestApiEndpointElement<T extends 'array' | 'struct' | 'table' = 'array' | 'struct' | 'table'> = T extends 'array' ? {
    /** @internal */
    type: T;
    /** the {@link RestApiEndpointElement} {@link RestApiRequest} */
    request?: RestApiRequest;
    /** the {@link RestApiEndpointElement} {@link RestApiResponse} as a {@link ArrayType} */
    response?: RestApiResponse<ArrayType>;
    /** the endpoint detail {@link Variable} as a {@link ArrayType} */
    variable?: Variable<ArrayType>;
} : T extends 'table' ? {
    /** @internal */
    type: T;
    /** the {@link RestApiEndpointElement} {@link RestApiRequest} */
    request?: RestApiRequest;
    /** the {@link RestApiEndpointElement} {@link RestApiResponse} as a {@link ArrayType} */
    response?: RestApiResponse<ArrayType<StructType>>;
} : T extends 'struct' ? {
    /** @internal */
    type: T;
    /** the {@link RestApiEndpointElement} {@link RestApiRequest}, for {@link StructType} no pagination is allowed */
    request?: Omit<RestApiRequest, 'paginate' | 'n_pages_variable'>;
    /** the {@link RestApiEndpointElement}  {@link RestApiResponse} as a {@link StructType} */
    response?: RestApiResponse<StructType>;
    /** the endpoint detail {@link Variable} as a {@link StructType} */
    variable?: Variable<StructType>;
} : never;
/**
 * Defines an http {@link RestApiRequest} and {@link RestApiResponse} to generate a request to a server following a parent {@link RestApiResponse} and {@link RestApiRequest}.
 *
 * @category Network
 */
export declare type RestApiEndpointElementDefinition<T extends 'array' | 'struct' | 'table' = 'array' | 'struct' | 'table'> = T extends 'array' ? {
    /** @internal */
    type: T;
    /** the {@link RestApiEndpointElement} {@link RestApiRequest} */
    request?: RestApiRequestDefinition;
    /** the {@link RestApiEndpointElement} {@link RestApiResponse} as a {@link ArrayType} */
    response?: RestApiResponseDefinition<ArrayType>;
    /** the endpoint detail {@link Variable} as a {@link ArrayType} */
    variable?: Variable<ArrayType>;
} : T extends 'table' ? {
    /** @internal */
    type: T;
    /** the {@link RestApiEndpointElement} {@link RestApiRequest} */
    request?: RestApiRequestDefinition;
    /** the {@link RestApiEndpointElement} {@link RestApiResponse} as a {@link ArrayType} */
    response?: RestApiResponseDefinition<ArrayType<StructType>>;
    /** the {@link Expression} key that evaluates to a unique value */
    primary_key?: EastFunction<"string">;
    /** evaluate to false to exclude a {@link Row} in the output */
    filter?: EastFunction<"boolean">;
    /** the {@link Partition}'s generated by the {@link Table} */
    partitions?: Record<string, PartitionDefinition>;
    /**  the configuration of the {@link Cache} for the {@link DataSource}. */
    cache?: Cache;
} : T extends 'struct' ? {
    /** @internal */
    type: T;
    /** the {@link RestApiEndpointElement} {@link RestApiRequest}, for {@link StructType} no pagination is allowed */
    request?: Omit<RestApiRequestDefinition, 'paginate' | 'n_pages_variable'>;
    /** the {@link RestApiEndpointElement}  {@link RestApiResponse} as a {@link StructType} */
    response?: RestApiResponseDefinition<StructType>;
    /** the endpoint detail {@link Variable} as a {@link StructType} */
    variable?: Variable<StructType>;
} : never;
/**
 * An  {@link ArrayType} {@link RestApiEndpointElement} to generate a request to a server following a parent {@link RestApiResponse} and {@link RestApiRequest}.
 *
 * @param definition: the desired {@link RestApiEndpointElement}
 * @returns a valid {@link RestApiEndpointElement}
 *
 * @category Network
 * @remarks Note that the context for evaluation of {@link EastFunction}'s is both the current environment, previous requests, and depending on {@link RestApiEndpointElement} configuration may also include `token`, parent `response`, and  `poll` variables.
 *
 * @example
 * ```typescript
 *  // create a 'repos' request response body type
 *  const response_body_type = ArrayType(StructType({
 *      name: 'string',
 *      commit: StructType({
 *          sha: 'string',
 *          url: 'float',
 *      }),
 *      zipball_url: 'string',
 *      tarball_url: 'string',
 *      node_id: 'string',
 *  }));
 *
 *  // create a 'repos' request response header type
 *  const response_header_type = StructType({
 *      server: 'string',
 *      connection: 'string',
 *      // ...
 *      etag: 'string',
 *  });
 *
 *  // Create a RestApiEndpointArrayElement to sub-query the tags associated with a user per parent repos response value
 *  const element = RestApiEndpointArrayElement({
 *      request: RestApiRequest{
 *          url: StringJoin`https://api.github.com/repos/${Variable("name", 'string')}/${Environment("GITHUB_USER")}/tags`,
 *          method: 'GET',
 *          accept: 'application/json',
 *          headers: Struct({
 *              Accept: Const("application/vnd.github.v3+json"),
 *              Authorization: StringJoin([Const("token "), GetField(Variable("token", rest_token_response_body_type), "access_token"),], ""),
 *          }),
 *          content: 'application/x-www-form-urlencoded',
 *          datetime_variable: Variable("request_datetime", 'datetime'),
 *      },
 *      response: RestApiResponse({
 *          status_code_variable: Variable("status_code", 'integer'),
 *          status_text_variable: Variable("status_text", 'string'),
 *          headers: Parse(Variable("headers", response_header_type)),
 *          headers_variable: Variable("headers", response_header_type),
 *          body: Parse(Variable("body", response_body_type)),
 *          body_variable: Variable("body", response_body_type),
 *          value: Variable("body", response_body_type),
 *      }),
 *      variable: Variable("tags", response_body_type),
 * })
 * ```
 */
export declare function RestApiEndpointArrayElement(definition: Omit<RestApiEndpointElementDefinition<'array'>, 'type'>): RestApiEndpointElementDefinition<'array'>;
/**
 * An  {@link ArrayType} {@link RestApiEndpointElement} to generate a request to a server following a parent {@link RestApiResponse} and {@link RestApiRequest}.
 *
 * @param definition: the desired {@link RestApiEndpointElement}
 * @returns a valid {@link RestApiEndpointElement}
 *
 * @category Network
 * @remarks Note that the context for evaluation of {@link EastFunction}'s is both the current environment, previous requests, and depending on {@link RestApiEndpointElement} configuration may also include `token`, parent `response`, and  `poll` variables.
 *
 * @example
 * ```typescript
 *  // create a 'repos' request response body type
 *  const response_body_type = ArrayType(StructType({
 *      name: 'string',
 *      commit: StructType({
 *          sha: 'string',
 *          url: 'float',
 *      }),
 *      zipball_url: 'string',
 *      tarball_url: 'string',
 *      node_id: 'string',
 *  }));
 *
 *  // create a 'repos' request response header type
 *  const response_header_type = StructType({
 *      server: 'string',
 *      connection: 'string',
 *      // ...
 *      etag: 'string',
 *  });
 *
 *  // Create a RestApiEndpointTableElement to sub-query the tags associated with a user per parent repos response value
 *  const element = RestApiEndpointTableElement({
 *      primary_key: Variable("name", "string")
 *      request: RestApiRequest{
 *          url: StringJoin`https://api.github.com/repos/${Variable("name", 'string')}/${Environment("GITHUB_USER")}/tags`,
 *          method: 'GET',
 *          accept: 'application/json',
 *          headers: Struct({
 *              Accept: Const("application/vnd.github.v3+json"),
 *              Authorization: StringJoin([Const("token "), GetField(Variable("token", rest_token_response_body_type), "access_token"),], ""),
 *          }),
 *          content: 'application/x-www-form-urlencoded',
 *          datetime_variable: Variable("request_datetime", 'datetime'),
 *      },
 *      response: RestApiResponse({
 *          status_code_variable: Variable("status_code", 'integer'),
 *          status_text_variable: Variable("status_text", 'string'),
 *          headers: Parse(Variable("headers", response_header_type)),
 *          headers_variable: Variable("headers", response_header_type),
 *          body: Parse(Variable("body", response_body_type)),
 *          body_variable: Variable("body", response_body_type),
 *          value: Variable("body", response_body_type),
 *      }),
 * })
 * ```
 */
export declare function RestApiEndpointTableElement(definition: Omit<RestApiEndpointElementDefinition<'table'>, 'type'>): RestApiEndpointElementDefinition<'table'>;
/**
 * An  {@link StructType} {@link RestApiEndpointElement} to generate a request to a server following a parent {@link RestApiResponse} and {@link RestApiRequest}.
 *
 * @param definition: the desired {@link RestApiEndpointElement}
 * @returns a valid {@link RestApiEndpointElement}
 *
 * @category Network
 * @remarks Note that the context for evaluation of {@link EastFunction}'s is both the current environment, previous requests, and depending on {@link RestApiEndpointElement} configuration may also include `token`, parent `response`, and  `poll` variables.
 *
 * @example
 * ```typescript
 *  // create a 'repos' request response body type
 *  const response_body_type = StructType({
 *      has_issues: 'boolean',
 *      has_projects: 'boolean',
 *      has_wiki: 'boolean'
 *  });
 *
 *  // create a 'repos' request response header type
 *  const response_header_type = StructType({
 *      server: 'string',
 *      connection: 'string',
 *      // ...
 *      etag: 'string',
 *  });
 *
 *  // Create a RestApiEndpointArrayElement to sub-query the repos details associated with a user per parent repos response value
 *  const element = RestApiEndpointStructElement({
 *      request: RestApiRequest{
 *          url: StringJoin`https://api.github.com/repos/${Variable("name", 'string')}`,
 *          method: 'GET',
 *          accept: 'application/json',
 *          headers: Struct({
 *              Accept: Const("application/vnd.github.v3+json"),
 *              Authorization: StringJoin([Const("token "), GetField(Variable("token", rest_token_response_body_type), "access_token"),], ""),
 *          }),
 *          content: 'application/x-www-form-urlencoded',
 *          datetime_variable: Variable("request_datetime", 'datetime'),
 *      },
 *      response: RestApiResponse({
 *          status_code_variable: Variable("status_code", 'integer'),
 *          status_text_variable: Variable("status_text", 'string'),
 *          headers: Parse(Variable("headers", response_header_type)),
 *          headers_variable: Variable("headers", response_header_type),
 *          body: Parse(Variable("body", response_body_type)),
 *          body_variable: Variable("body", response_body_type),
 *          value: Variable("body", response_body_type),
 *      }),
 *      variable: Variable("repos_detail", response_body_type),
 * })
 * ```
 */
export declare function RestApiEndpointStructElement(definition: Omit<RestApiEndpointElementDefinition<'struct'>, 'type'>): RestApiEndpointElementDefinition<'struct'>;
/** @internal */
export declare type RestApiEndpoint = {
    type: 'endpoint';
    request?: RestApiRequest;
    response?: RestApiResponse<ArrayType<StructType>>;
    elements?: Record<string, RestApiEndpointElement>;
};
/**
 * Defines a {@link RestApiEndpointDefinition} that creates an output {@link Table} and streams {@link Row}'s from a Restful http endpoint.
 *
 * @category Network
 *
 */
export declare type RestApiEndpointDefinition = {
    type: 'endpoint';
    /** the primary output {@link RestApiRequest} */
    request?: RestApiRequestDefinition;
    /** the primary output {@link RestApiResponse}, must always produce an {@link ArrayType} of {@link StructType} */
    response?: RestApiResponseDefinition<ArrayType<StructType>>;
    /** the `Record` of {@link RestApiEndpointElement} executed as sub-queries within {@link RestApiEndpointDefinition.response} */
    elements?: Record<string, RestApiEndpointElementDefinition>;
    /** the {@link Expression} key that evaluates to a unique value */
    primary_key?: EastFunction<"string">;
    /** evaluate to false to exclude a {@link Row} in the output */
    filter?: EastFunction<"boolean">;
    /** the {@link Partition}'s generated by the {@link Table} */
    partitions?: Record<string, PartitionDefinition>;
    /**  the configuration of the {@link Cache} for the {@link DataSource}. */
    cache?: Cache;
};
/**
 * Create a {@link RestApiEndpointDefinition} that creates an output {@link Table} and streams {@link Row}'s from a Restful http endpoint.
 *
 * @param definition: the desired {@link RestApiEndpointDefinition}
 * @returns a valid {@link RestApiEndpointDefinition}
 *
 * @category Network
 *
 * @example
 *  ```typescript
 *  // create a 'repos' request response body type
 *  const response_body_type = ArrayType(StructType({
 *      id: 'float',
 *      node_id: 'string',
 *      name: 'string',
 *      full_name: 'string',
 *      url: 'string',
 *      description: 'string',
 *      owner: StructType({
 *          login: 'string',
 *          id: 'float',
 *          url: 'string',
 *      }),
 *  }));
 *
 *  // create a 'repos' request response header type
 *  const response_header_type = StructType({
 *      server: 'string',
 *      connection: 'string',
 *      // ...
 *      etag: 'string',
 *  });
 *
 *
 *  // query github for the repos associated with a user
 *  const element = RestApiEndpoint({
 *      request: RestApiRequest({
 *          url: StringJoin`https://api.github.com/users/${Environment("GITHUB_USER")}/repos`,
 *          method: 'GET',
 *          accept: 'application/json',
 *          headers: Struct({
 *              Accept: Const("application/vnd.github.v3+json"),
 *              Authorization: StringJoin`token ${GetField(Variable("token", rest_token_response_body_type), "access_token")}`
 *          }),
 *          // retry if the number of allowable requests is exhausted (status_code comes form response scope)
 *          retry: Const(false),
 *          // pause a minute if the number of allowable requests is exhausted (status_code comes form response scope)
 *          delay_ms: Const(400n),
 *          content: 'application/x-www-form-urlencoded',
 *          datetime_variable: Variable("request_datetime", 'datetime'),
 *      }),
 *      response: RestApiResponse({
 *          status_code_variable: Variable("status_code", 'integer'),
 *          status_text_variable: Variable("status_text", 'string'),
 *          headers: Parse(Variable("headers", response_header_type)),
 *          headers_variable: Variable("headers", response_header_type),
 *          body: Parse(Variable("body", response_body_type)),
 *          body_variable: Variable("body", response_body_type),
 *          value: Variable("body", response_body_type),
 *      }),
 *      elements: {
 *          sub_query: RestApiEndpointArrayElement({
 *              // ...
 *          })
 *      }
 * })
 * ```
 */
export declare function RestApiEndpoint(config: Omit<RestApiEndpointDefinition, 'type'>): RestApiEndpointDefinition;
/** @internal */
export declare type RestApiAuthorisation = {
    success_uri?: HttpsURI | HttpURI;
    authorise_request?: RestApiRequest;
    authorise_response?: RestApiResponse<StructType>;
    authorise_variable?: Variable<StructType>;
    redirect_variable?: Variable<"string">;
    token_request?: RestApiRequest;
    refresh_request?: RestApiRequest;
    token_response?: RestApiResponse<StructType>;
    token_variable?: Variable<StructType>;
    refresh?: EastFunction<"boolean">;
    refresh_variable?: Variable<"boolean">;
    duration_variable?: Variable<"float">;
    connected_variable?: Variable<"datetime">;
    initialised_variable?: Variable<"boolean">;
};
/**
 * Defines a {@link RestApiAuthorisationDefinition} the manage oauth2 authentication for a rest data source.
 *
 * @category Network
 *
 */
export declare type RestApiAuthorisationDefinition = {
    /** the {@link EnvironmentType} evaluating to the redirect triggered by the callback uri, on success */
    success_uri?: HttpsURI | HttpURI | URIString<'http://' | 'https://'> | EastFunction<'string'>;
    /** the {@link RestApiResponse} processed when the `redirect_uri` is called by the third party service */
    authorise_response?: RestApiResponseDefinition<StructType>;
    /** the {@link RestApiRequest} processed following the {@link RestApiResponse.authorise_response} */
    authorise_request?: RestApiRequestDefinition;
    /** the {@link Variable} that contains the redirect uri */
    redirect_variable?: Variable<"string">;
    /** the {@link Variable} that contains authorisation request response */
    authorise_variable?: Variable<StructType>;
    /** the {@link RestApiResponse} called following processing authorise_variable during authorisation, in scope variables are [{@link RestApiResponse.refresh}, {@link RestApiResponse.duration}, {@link RestApiResponse.connected}, {@link RestApiResponse.datetime}, {@link RestApiResponse.prev_datetime}, {@link RestApiResponse.initial}] */
    token_request?: RestApiRequestDefinition;
    /** the {@link RestApiResponse} to request a token refresh, in scope variables are [{@link RestApiResponse.refresh}, {@link RestApiResponse.duration}, {@link RestApiResponse.connected}, {@link RestApiResponse.datetime}, {@link RestApiResponse.prev_datetime}, {@link RestApiResponse.initial}] */
    refresh_request?: RestApiRequestDefinition;
    /** the {@link RestApiResponse} from requesting a token, assumes token is a {@link StructType} */
    token_response?: RestApiResponseDefinition<StructType>;
    /** the {@link Variable} that contains token */
    token_variable?: Variable<StructType>;
    /** evaluate to true if the token should be refreshed */
    refresh?: EastFunction<"boolean">;
    /** the {@link Variable} that contains refresh request response */
    refresh_variable?: Variable<"boolean">;
    /** the {@link Variable} that contains the duration since connected */
    duration_variable?: Variable<"float">;
    /** the {@link Variable} that contains the connection date */
    connected_variable?: Variable<"datetime">;
    /** the {@link Variable} that contains the initialisation state */
    initialised_variable?: Variable<"boolean">;
};
/**
 * Create a {@link RestApiAuthorisationDefinition} the manage oauth2 authentication for a rest data source.
 *
 * @category Network
 *
 * @example
 *  ```typescript
 *  // create the auth request response body type
 *  const authorise_response_body_type = StructType({
 *      code: 'string',
 *  });
 *
 *  // create the auth token request response body type
 *  const token_response_body_type = StructType({
 *      token_type: 'string',
 *      access_token: 'string',
 *      expires_in: 'float',
 *      refresh_token: 'string',
 *  });
 *
 *  // configure authentication for the Kounta api (https://apidoc.kounta.com/) using some preset environment variables
 *  const element = RestApiAuthorisation({
 *      redirect_uri: Environment(KOUNTA_REDIRECT_URI)
 *      success_uri: Const("https://www.google.com"),
 *      authorise_request: RestApiRequest({
 *          url: Const("https://my.kounta.com/authorize"),
 *          method: 'GET',
 *          accept: 'application/json',
 *          body: Struct({
 *              response_type: Const("code"),
 *              state: Const("auth"),
 *              client_id: Environment(KOUNTA_APP_ID),
 *              redirect_uri: Environment(KOUNTA_REDIRECT_URI),
 *          }),
 *      }),
 *      authorise_response: RestApiResponse({
 *          status_code_variable: Variable("status_code", 'integer'),
 *          status_text_variable: Variable("status_text", 'string'),
 *          body: Parse(Variable("body", authorise_response_body_type)),
 *          body_variable: Variable("body", authorise_response_body_type),
 *          value: Parse(Variable("body", authorise_response_body_type)),
 *      }),
 *      authorise_variable: Variable("authorise", authorise_response_body_type),
 *      token_request: {
 *          url: Const('https://api.kounta.com/v1/token.json'),
 *          method: 'POST',
 *          content: 'application/x-www-form-urlencoded',
 *          body: Struct({
 *              grant_type: Const('authorization_code'),
 *              code: GetField(Variable("authorise", authorise_response_body_type), "code"),
 *              client_id: Environment(KOUNTA_APP_ID),
 *              client_secret: Environment(KOUNTA_APP_SECRET),
 *              redirect_uri: Environment(KOUNTA_REDIRECT_URI),
 *          }),
 *      },
 *      refresh_request: {
 *          url: Const('https://api.kounta.com/v1/token.json'),
 *          method: 'POST',
 *          content: 'application/x-www-form-urlencoded',
 *          body: Struct({
 *              grant_type: Const('refresh_token'),
 *              refresh_token: GetField(Variable("token", token_response_body_type), "refresh_token"),
 *              client_id: Environment(KOUNTA_APP_ID),
 *              client_secret: Environment(KOUNTA_APP_SECRET),
 *          }),
 *      },
 *      token_response: {
 *          body: Parse(Variable('body', token_response_body_type)),
 *          body_variable: Variable('body', token_response_body_type),
 *          value: Struct({
 *              token_type: GetField(Variable('body', token_response_body_type), 'token_type'),
 *              access_token: GetField(Variable("body", token_response_body_type), "access_token"),
 *              expires_in: GetField(Variable('body', token_response_body_type), 'expires_in'),
 *              refresh_token: IfElse(
 *                  // a refresh request doesnt return the refresh token, so recycle it
 *                  IsNull(GetField(Variable("body", token_response_body_type), "refresh_token")),
 *                  GetField(Variable("token", token_response_body_type), "refresh_token"),
 *                  GetField(Variable("body", token_response_body_type), "refresh_token")
 *              ),
 *          }),
 *      },
 *      token_variable: Variable("token", token_response_body_type),
 *      connected_variable: Variable('connected', 'datetime'),
 *      duration_variable: Variable('duration', 'float'),
 *      refresh: Or(
 *          Greater(
 *              IfElse(
 *                  IsNull(Variable('duration', 'float')),
 *                  2,
 *                  Variable('duration', 'float')
 *              ),
 *              IfElse(
 *                  IsNull(GetField(Variable("token", token_response_body_type), "expires_in")),
 *                  1,
 *                  Divide(Multiply(Parse(GetField(Variable("token", token_response_body_type), "expires_in")), 1000), 2)
 *              ),
 *          ),
 *      ),
 * })
 * ```
 */
export declare function RestApiAuthorisation(config: RestApiAuthorisationDefinition): RestApiAuthorisationDefinition;
/** @internal */
export declare type RestApiSource = MultiSource & {
    type: "rest";
    name: string;
    poll: Poll | null;
    authorisation?: RestApiAuthorisation;
    outputs: Record<string, RestApiEndpoint | RestApiEndpointElement<'table'>>;
};
/**
 * Defines a {@link RestApiSourceDefinition} that creates an output {@link Table} and streams {@link Row}'s of multiple http {@link RestApiEndpointDefinition}'s, using if required oauth2 {@link RestApiAuthorisation}.
 *
 * @category Network
 */
export declare type RestApiSourceDefinition = {
    /** @internal */
    type: "rest";
    /** the name of the {@link DataSource} */
    name: string;
    /** set to true if the {@link DataSource} should run offline */
    offline?: boolean;
    /** the configuration of the {@link DataSource} {@link Poll} */
    poll?: Poll;
    /** the configuration of the {@link DataSource} {@link RestApiAuthorisation} */
    authorisation?: RestApiAuthorisationDefinition;
    /** the `Record` of the {@link DataSource} {@link RestApiEndpointDefinition}'s' */
    endpoints?: Record<string, RestApiEndpointDefinition>;
};
/**
 * Create a {@link RestApiSourceDefinition} that creates an output {@link Table} and streams {@link Row}'s of multiple http {@link RestApiEndpointDefinition}'s, using if required oauth2 {@link RestApiAuthorisation}.
 *
 * @param definition: the desired {@link RestApiSourceDefinition}
 * @returns a valid {@link RestApiSourceDefinition}
 *
 * @category Network
 *
 * @example
 *  ```typescript
 *  // create a 'repos' request response body type
 *  const response_body_type = ArrayType(StructType({
 *      id: 'float',
 *      node_id: 'string',
 *      name: 'string',
 *      full_name: 'string',
 *      url: 'string',
 *      description: 'string',
 *      owner: StructType({
 *          login: 'string',
 *          id: 'float',
 *          url: 'string',
 *      }),
 *  }));
 *
 *  // create a 'repos' request response header type
 *  const response_header_type = StructType({
 *      server: 'string',
 *      connection: 'string',
 *      // ...
 *      etag: 'string',
 *  });
 *
 *
 *  // configure a RestApiSourceDefinition to query github for the repos associated with a user
 *  const source = RestApiSource({
 *      name: "Guthub Rest",
 *      poll: Poll({
 *          // ...
 *      }),
 *      authorisation: RestApiAuthorisation({
 *          //...
 *      }),
 *      endpoints: {
 *          repos: RestApiEndpoint({
 *              request: RestApiRequest({
 *                  url: StringJoin`https://api.github.com/users/${Environment("GITHUB_USER")}/repos`,
 *                  method: 'GET',
 *                  accept: 'application/json',
 *                  headers: Struct({
 *                      Accept: Const("application/vnd.github.v3+json"),
 *                      Authorization: StringJoin`token ${GetField(Variable("token", rest_token_response_body_type), "access_token")}`
 *                  }),
 *                  // retry if the number of allowable requests is exhausted (status_code comes form response scope)
 *                  retry: Const(false),
 *                  // pause a minute if the number of allowable requests is exhausted (status_code comes form response scope)
 *                  delay_ms: Const(400n),
 *                  content: 'application/x-www-form-urlencoded',
 *                  datetime_variable: Variable("request_datetime", 'datetime'),
 *              }),
 *              response: RestApiResponse({
 *                  status_code_variable: Variable("status_code", 'integer'),
 *                  status_text_variable: Variable("status_text", 'string'),
 *                  headers: Parse(Variable("headers", response_header_type)),
 *                  headers_variable: Variable("headers", response_header_type),
 *                  body: Parse(Variable("body", response_body_type)),
 *                  body_variable: Variable("body", response_body_type),
 *                  value: Variable("body", response_body_type),
 *              }),
 *              elements: {
 *                  sub_query: RestApiEndpointArrayElement({
 *                      // ...
 *                  })
 *              }
 *          }),
 *      }
 *  })
 * ```
 */
export declare function RestApiSource(config: Omit<RestApiSourceDefinition, 'type'>): RestApiSourceDefinition;
/**
 * Create a {@link ELARASchema} containing a {@link RestApiSourceDefinition} that creates an output {@link Table} and streams {@link Row}'s of multiple http {@link RestApiEndpointDefinition}'s, using if required oauth2 {@link RestApiAuthorisation}.
 *
 * @param definition: the desired {@link RestApiSourceDefinition}
 * @returns a valid {@link RestApiSourceDefinition} within a {@link ELARASchema}
 *
 * @category Network
 *
 * @example
 *  ```typescript
 *  // create a 'repos' request response body type
 *  const response_body_type = ArrayType(StructType({
 *      id: 'float',
 *      node_id: 'string',
 *      name: 'string',
 *      full_name: 'string',
 *      url: 'string',
 *      description: 'string',
 *      owner: StructType({
 *          login: 'string',
 *          id: 'float',
 *          url: 'string',
 *      }),
 *  }));
 *
 *  // create a 'repos' request response header type
 *  const response_header_type = StructType({
 *      server: 'string',
 *      connection: 'string',
 *      // ...
 *      etag: 'string',
 *  });
 *
 *
 *  // To create an ELARASchema containing a RestApiSourceDefinition to query github for the repos associated with a user
 *  const source = RestApiSource({
 *      name: "Guthub Rest",
 *      poll: Poll({
 *          // ...
 *      }),
 *      authorisation: RestApiAuthorisation({
 *          //...
 *      }),
 *      endpoints: {
 *          repos: RestApiEndpoint({
 *              request: RestApiRequest({
 *                  url: StringJoin`https://api.github.com/users/${Environment("GITHUB_USER")}/repos`,
 *                  method: 'GET',
 *                  accept: 'application/json',
 *                  headers: Struct({
 *                      Accept: Const("application/vnd.github.v3+json"),
 *                      Authorization: StringJoin`token ${GetField(Variable("token", rest_token_response_body_type), "access_token")}`
 *                  }),
 *                  // retry if the number of allowable requests is exhausted (status_code comes form response scope)
 *                  retry: Const(false),
 *                  // pause a minute if the number of allowable requests is exhausted (status_code comes form response scope)
 *                  delay_ms: Const(400n),
 *                  content: 'application/x-www-form-urlencoded',
 *                  datetime_variable: Variable("request_datetime", 'datetime'),
 *              }),
 *              response: RestApiResponse({
 *                  status_code_variable: Variable("status_code", 'integer'),
 *                  status_text_variable: Variable("status_text", 'string'),
 *                  headers: Parse(Variable("headers", response_header_type)),
 *                  headers_variable: Variable("headers", response_header_type),
 *                  body: Parse(Variable("body", response_body_type)),
 *                  body_variable: Variable("body", response_body_type),
 *                  value: Variable("body", response_body_type),
 *              }),
 *              elements: {
 *                  sub_query: RestApiEndpointArrayElement({
 *                      // ...
 *                  })
 *              }
 *          }),
 *      }
 *  })
 * ```
 */
export declare function RestApiSourceSchema(def: Omit<RestApiSourceDefinition, "type">): ELARASchema;
/** @internal */
export declare type DataSource = RestApiSource | ArraySource | CsvSource | JsonSource | ExcelSource | RangeSource | ClockSource | SqlSource | SqlChangeTrackingSource;
/** @internal */
export declare type DataSourceDefinition = RestApiSourceDefinition | ArraySourceDefinition | CsvSourceDefinition | JsonSourceDefinition | ClockSourceDefinition | RangeSourceDefinition | SqlSourceDefinition | ExcelSourceDefinition | SqlChangeTrackingSourceDefinition;
/** @internal */
export declare function toRestApiRequest(key: string, request: RestApiRequestDefinition, context?: Record<string, Variable>): {
    request: RestApiRequest;
    context: Record<string, Variable>;
};
/** @internal */
export declare function toRestApiResponse<T extends EastType = EastType>(key: string, response: RestApiResponseDefinition<T>, context?: Record<string, Variable>): {
    response: RestApiResponse<T>;
    context: Record<string, Variable>;
};
/** @internal */
export declare function toRestApiAuthorisation(key: string, authorisation: RestApiAuthorisationDefinition, context?: Record<string, Variable>): {
    authorisation: RestApiAuthorisation;
    context: Record<string, Variable>;
};
/** @internal */
export declare function toRestApiEndpoint(key: string, endpoint: RestApiEndpointDefinition, context?: Record<string, Variable>): {
    endpoint: RestApiEndpoint;
    context: Record<string, Variable>;
};
/** @internal */
export declare function toRestApiSource(def: Omit<RestApiSourceDefinition, 'type'>): RestApiSource;
/** @internal */
export declare function toSqlChangeTrackingSource(def: Omit<SqlChangeTrackingSourceDefinition, 'type'>): SqlChangeTrackingSource;
/** @internal */
export declare function toDataSource(def: DataSourceDefinition): DataSource;
/**
 * Create a Schema containing a {@link DataSource} that creates an output {@link Table} and streams {@link Row}'s from an array.
 *
 * @param definition: the desired {@link DataSourceDefinition}
 * @returns a valid {@link DataSourceDefinition} within a {@link ELARASchema}
 *
 * @example
 * ```typescript
 *  // create the ArraySource within a ELARASchema, note that the selections apply a Parse
 *  const source = DataSourceSchema(
 *      ArraySource({
 *          name: 'Array',
 *          primary_key: Variable('id', 'string'),
 *          selections: {
 *              id: Parse(Variable('id', 'string'))
 *              date: Parse(Variable('date', 'datetime')),
 *              object: Parse(Variable('object', StructType({ count: 'integer', date: 'datetime' })))
 *              array: Parse(Variable('object', ArrayType(DictType('float'))),
 *          },
 *          rows: [{
 *              id: "1234",
 *              date: '2021-01-04T00:02:24.961Z',
 *              object: {
 *                  count: 1000000n,
 *                  date: '2021-03-05T00:05:33.213Z',
 *              },
 *              array: [
 *                  { "one": 5.0, "two": 5.0 },
 *                  { "two": 4.0, "three": 5.0 },
 *              ]
 *          }]
 *      })
 * )
 * ```
 */
export declare function DataSourceSchema(def: DataSourceDefinition): ELARASchema;
