// Â© Copyright 2018- 2022 - Elara AI Pty Ltd ACN 627 124 903
//
// Licensed under the EDK Licence version LICENSE-1.04.
//
// You may only use this file in accordance with the terms and conditions contained in EDK
// Licence - Version LICENSE-1.04. The full version of the EDK Licence is available at:
// https://elaraai.github.io/docs/license

import { Table } from '../data/Table';
import { Expression } from '../east/definition';
import { EastFunction, Property, StructFunction, Variable } from '../east/functions';
import { ArrayType, DictType, EastType, PrimitiveType, StructType, ValueTypeOf } from '../east/types';
import { PropertyKind, PropertyStructure, SamplingStatistic } from './Property';
import { PropertyReference, PropertyReferenceMapping, PropertyReferenceStructure } from './PropertyReference';
/** {@category Property} */
export declare type MLSamplingMode = "max_likelihood" | "sample" | "probability" | "sample_squared";
/** @internal */
export declare type MLFunctionInstance<T extends EastType = EastType> = {
    function: "ml";
    type: T;
    inputs: Record<string, PropertyReference<EastType>>;
    features: Record<string, PropertyReference<EastType>>;
    training_group: string | null;
    output: EastFunction<T>;
    evaluate: boolean;
    train: boolean;
    sampling_mode: MLSamplingMode;
};
/** @internal */
export declare type GetPropertyFunction<T extends EastType = EastType> = {
    function: "getproperty";
    type: T;
    property_parent: string;
    property_concept: string;
    property_marker?: string;
    inputs: {
        marker?: PropertyReference<"string">;
        date?: PropertyReference<"datetime">;
    };
    evaluate: boolean;
};
/** @internal */
export declare type GetPropertiesFunction<T extends EastType = EastType> = {
    function: "getproperties";
    type: T;
    property_parent: string;
    property_concept: string;
    property_markers?: Set<string>;
    inputs: {
        markers?: PropertyReference<"set">;
        date?: PropertyReference<"datetime">;
    };
    evaluate: boolean;
};
/** @internal */
export declare type GenericFunctionInstance<T extends EastType = EastType> = {
    function: "generic";
    type: T;
    ast: EastFunction<T>;
    inputs: Record<string, PropertyReference>;
    evaluate: boolean;
};
/** @internal */
export declare type RandomFunctionInstance<T extends EastType = EastType> = {
    function: "random";
    type: T;
    inputs: {
        number?: PropertyReference<"integer">;
    };
    evaluate: boolean;
} & ({
    distribution: "uniform";
} | {
    distribution: "gaussian";
} | {
    distribution: "exponential";
} | {
    distribution: "weibull";
    inputs: {
        shape: PropertyReference<"float">;
    };
} | {
    distribution: "array";
    inputs: {
        array: PropertyReference<ArrayType<T>>;
    };
} | {
    distribution: "set";
    inputs: {
        set: PropertyReference<"set">;
    };
});
/** @internal */
export declare type Function<T extends EastType = EastType> = MLFunctionInstance<T> | GetPropertyFunction<T> | GetPropertiesFunction<T> | GenericFunctionInstance<T> | RandomFunctionInstance<T>;
/** @internal */
export declare function toFunction<T extends EastType>(parent: string, marker: string, def: FunctionDefinition<T>, properties: Record<string, Property>): Function<T>;
/** @internal */
export declare function toGenericFunction<T extends EastType>(f: EastFunction<T>, properties: Record<string, PropertyReference>): GenericFunctionInstance<T>;
/** @internal */
export declare type MLFunctionMapping<T extends EastType = EastType> = {
    function: "ml";
    type: T;
    inputs: Record<string, PropertyReferenceMapping>;
    features: Record<string, PropertyReferenceMapping<EastType>>;
    training_group: EastFunction<"string"> | null;
    output: EastFunction<T>;
    evaluate: EastFunction<"boolean">;
    train: EastFunction<"boolean">;
    sampling_mode: MLSamplingMode;
};
/** @internal */
export declare type GetPropertyFunctionMapping<T extends EastType = EastType> = {
    function: "getproperty";
    type: T;
    property_parent: string;
    property_concept: string;
    property_marker?: EastFunction<"string">;
    inputs: {
        marker?: PropertyReferenceMapping<"string">;
        date?: PropertyReferenceMapping<"datetime">;
    };
    evaluate: EastFunction<"boolean">;
};
/** @internal */
export declare type GetPropertiesFunctionMapping<T extends EastType = EastType> = {
    function: "getproperties";
    type: T;
    property_parent: string;
    property_concept: string;
    property_markers?: EastFunction<"set">;
    inputs: {
        markers?: PropertyReferenceMapping<"set">;
        date?: PropertyReferenceMapping<"datetime">;
    };
    evaluate: EastFunction<"boolean">;
};
/** @internal */
export declare type GenericFunctionMapping<T extends EastType = EastType> = {
    function: "generic";
    type: T;
    ast: EastFunction<T>;
    inputs: Record<string, PropertyReferenceMapping>;
    evaluate: EastFunction<"boolean">;
};
/** @internal */
export declare type RandomFunctionMapping<T extends EastType = EastType> = {
    function: "random";
    type: T;
    inputs: {
        number?: PropertyReferenceMapping<"integer">;
    };
    evaluate: EastFunction<"boolean">;
} & ({
    distribution: "uniform";
} | {
    distribution: "gaussian";
} | {
    distribution: "exponential";
} | {
    distribution: "weibull";
    inputs: {
        shape: PropertyReferenceMapping<"float">;
    };
} | {
    distribution: "array";
    inputs: {
        array: PropertyReferenceMapping<ArrayType<T>>;
    };
} | {
    distribution: "set";
    inputs: {
        set: PropertyReferenceMapping<"set">;
    };
});
/** @internal */
export declare type FunctionMapping<T extends EastType = EastType> = MLFunctionMapping<T> | GetPropertyFunctionMapping<T> | GetPropertiesFunctionMapping<T> | GenericFunctionMapping<T> | RandomFunctionMapping<T>;
/** @internal */
export declare function toFunctionMapping<T extends EastType>(parent: string, marker: EastFunction<"string">, def: FunctionDefinition<T>, fields: Record<string, Variable>, properties: Record<string, Property>): FunctionMapping<T>;
/** @internal */
export declare function toGenericFunctionMapping<T extends EastType>(f: EastFunction<T>, properties: Record<string, PropertyReferenceMapping>): GenericFunctionMapping<T>;
/** @category Property */
export declare type MLFunctionStructure<T extends EastType = EastType> = {
    function: "ml";
    type: T;
    parent: string;
    concept: string;
    inputs: Record<string, PropertyReferenceStructure<EastType>>;
    features: Record<string, PropertyReferenceStructure<EastType>>;
    output_type: EastType;
    sampling_mode: MLSamplingMode;
    training_table: Table;
    feature_rank_table: Table;
    validation_table: Table;
};
/** @category Property */
export declare type GetPropertyFunctionStructure<T extends EastType = EastType> = {
    function: "getproperty";
    type: T;
    parent: string;
    concept: string;
    property_parent: string;
    property_concept: string;
    inputs: {
        marker?: PropertyReferenceStructure<"string">;
        date?: PropertyReferenceStructure<"datetime">;
    };
};
/** @category Property */
export declare type GetPropertiesFunctionStructure<T extends EastType = EastType> = {
    function: "getproperties";
    type: T;
    parent: string;
    concept: string;
    property_parent: string;
    property_concept: string;
    inputs: {
        markers?: PropertyReferenceStructure<"set">;
        date?: PropertyReferenceStructure<"datetime">;
    };
};
/** @category Property */
export declare type GenericFunctionStructure<T extends EastType = EastType> = {
    function: "generic";
    type: T;
    parent: string;
    concept: string;
    ast: EastFunction<T>;
    inputs: Record<string, PropertyReferenceStructure>;
};
/** @category Property */
export declare type RandomFunctionStructure<T extends EastType = EastType> = {
    function: "random";
    type: T;
    parent: string;
    concept: string;
    inputs: {
        number?: PropertyReferenceStructure<"integer">;
    };
} & ({
    type: "float";
    distribution: "uniform";
} | {
    type: "float";
    distribution: "gaussian";
} | {
    type: "float";
    distribution: "exponential";
} | {
    type: "float";
    distribution: "weibull";
    inputs: {
        shape: PropertyReferenceStructure<"float">;
    };
} | {
    distribution: "array";
    inputs: {
        array: PropertyReferenceStructure<ArrayType<T>>;
    };
} | {
    type: "string";
    distribution: "set";
    inputs: {
        set: PropertyReferenceStructure<"set">;
    };
});
/** @category Property */
export declare type FunctionStructure<T extends EastType = EastType> = MLFunctionStructure<T> | GetPropertyFunctionStructure<T> | GetPropertiesFunctionStructure<T> | GenericFunctionStructure<T> | RandomFunctionStructure<T>;
/**
 * An object to define a {@link GenericFunction} property, allowing you to set extra parameters
 * such as `objective`, `evaluate` and `value`.
 *
 * @category Property
 *
 * @example
 * ```typescript
 * //...
 * properties: {
 *     //...
 *     // Define the objective to maximize SaleAmount
 *     SaleAmount: GenericFunction({
 *         expression: Multiply(
 *             Property("SaleQuantity", "integer"),
 *             Property("UnitPrice", "float")
 *         ),
 *         objective: Property("SaleAmount", "float"),
 *     }),
 *     //...
 * }
 * //...
 * ```
 */
export declare type GenericFunctionConfig<T extends EastType> = {
    /** An {@link Expression} defining the property value, given access to local {@link Property}s as well as, in the case of mappings, tabular data via {@link Variable}s */
    expression: Expression<T>;
    /** The value to use if `evaluate` is `false` (and for ML training) */
    value?: Expression<T> | null;
    /** A flag determining whether `expression` is evaluated during the simulation (or whether `value` is used) */
    evaluate?: Expression<"boolean">;
    /** One or more {@link EastFunction}s to apply to the array of samples to generate a result */
    sampling_function?: EastFunction | Record<string, EastFunction>;
    /** One or more {@link SamplingStatistic}s to apply to the array of samples to generate a result */
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
    /** An {@link EastFunction} that returns this property's contribution to the global objective function */
    objective?: Expression<"float">;
};
/** @internal */
export declare type GenericFunctionDefinition<T extends EastType> = {
    kind: "function";
    function: "generic";
    type: T;
    expression: EastFunction<T>;
    value?: Expression<T> | null;
    evaluate?: Expression<"boolean">;
    objective?: Expression<"float">;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
};
/**
 * Create a property from a generic East function.
 *
 * Note: In most cases you can write the {@link Expression} directly as the property
 * definition. This function allows you to control additional parameters such as `objective`,
 * `evaluate` and `value`.
 *
 * @param config the {@link GenericFunctionConfig} defining the generic function property
 * @returns a generic-function property definition
 *
 * @category Property
 *
 * @example
 * ```typescript
 * //...
 * properties: {
 *     //...
 *     // Define the objective to maximize SaleAmount
 *     SaleAmount: GenericFunction({
 *         expression: Multiply(
 *             Property("SaleQuantity", "integer"),
 *             Property("UnitPrice", "float")
 *         ),
 *         objective: Property("SaleAmount", "float"),
 *     }),
 *     //...
 * }
 * //...
 * ```
 */
export declare function GenericFunction<T extends EastType>(config: GenericFunctionConfig<T>): GenericFunctionDefinition<T>;
/** @internal */
export declare type MLFunctionDefinition<T extends EastType> = {
    type: T;
    kind: "function";
    function: "ml";
    value?: undefined;
    features: Record<string, Property<EastType>>;
    output: Expression<T>;
    evaluate: Expression<"boolean">;
    train: Expression<"boolean">;
    training_group?: Expression<"string">;
    objective?: Expression<"float">;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
    sampling_mode: "sample" | "max_likelihood";
} | {
    type: "float";
    kind: "function";
    function: "ml";
    value?: undefined;
    features: Record<string, Property<EastType>>;
    output: Expression<T>;
    evaluate: Expression<"boolean">;
    train: Expression<"boolean">;
    training_group?: Expression<"string">;
    objective?: Expression<"float">;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
    sampling_mode: "sample_squared";
} | {
    type: DictType<"float">;
    kind: "function";
    function: "ml";
    value?: undefined;
    features: Record<string, Property<EastType>>;
    output: Expression<"string">;
    evaluate: Expression<"boolean">;
    train: Expression<"boolean">;
    training_group?: Expression<"string">;
    objective?: Expression<"float">;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
    sampling_mode: "probability";
} | {
    type: StructType<{
        mean: "float";
        var: "float";
    }>;
    kind: "function";
    function: "ml";
    value?: undefined;
    features: Record<string, Property<EastType>>;
    output: Expression<"float">;
    evaluate: Expression<"boolean">;
    train: Expression<"boolean">;
    training_group?: Expression<"string">;
    objective?: Expression<"float">;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
    sampling_mode: "probability";
};
/** @internal */
export declare type MLTypes = 'string' | 'float' | 'integer' | 'datetime' | DictType<'float' | 'integer'> | StructType<{
    max: "float";
    min: "float";
    value: "float";
}>;
/** @internal */
export declare type MLSampledType<T extends MLTypes, S extends MLSamplingMode | undefined> = S extends "sample" | "max_likelihood" | "sample_squared" | undefined ? T : S extends "probability" ? T extends "string" ? DictType<"float"> : T extends "float" ? StructType<{
    mean: "float";
    var: "float";
}> : never : never;
/** @internal */
export declare function MLSampledType<T extends MLTypes, S extends MLSamplingMode>(type: T, sampling_mode: S): MLSampledType<T, S>;
/**
 * Configuration for {@link MLFunction}.
 *
 * @category Property
 */
export declare type MLFunctionConfig<T extends MLTypes, S extends MLSamplingMode | undefined> = {
    /** The "default" ML function output value, used for training when `train` is `true`, and in the simulation when `evaluate` is `false` */
    output: Expression<T>;
    /** A record of local {@link Property} "features" that the ML function base its predictions on */
    features: Record<string, Property<PrimitiveType | DictType<PrimitiveType> | DictType<DictType<'float' | 'integer'>>>>;
    /** An {@link Expression} setting when the simulation will evaluate the ML function (ignoring `value`) */
    evaluate: Expression<"boolean">;
    /** An {@link Expression} setting which instances training will use to generate an ML model */
    train: Expression<"boolean">;
    /** If specified, multiple ML models will be generated by splitting data by the `training_group` key */
    training_group?: Expression<"string">;
    /** One or more {@link EastFunction}s to apply to the array of samples to generate a result */
    sampling_function?: EastFunction | Record<string, EastFunction>;
    /** One or more {@link SamplingStatistic}s to apply to the array of samples to generate a result */
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
    /** Choose a mode to draw samples from CDF of ML function during prediction */
    sampling_mode?: S;
    /** An {@link Expression} giving the contribution of this property to the global objective function, to guide optimization */
    objective?: Expression<"float">;
};
/**
 * Create a machine learning (ML) function. The output value is predicted based upon a set
 * of input features, which are {@link Property}s local to the parent {@link Agent},
 * {@link Resource} or {@link Process} instance. Due to uncertainty, there is an amount of
 * randomness to the output value that will vary between simulation _trajectories_.
 *
 * The ML function is trained on example data, where both the output value and input features
 * are known. Typically, historical data is used to train an `MLFunction` to create future
 * predictions. Training will learn from instances that have the `train` flag set to `true`.
 * Data not to be predicted within the simulation must have the `evaluate` flag to `false`.
 *
 * The specific machine-learning algorithm employed depends on the output (`output`) type:
 *
 * * Selector: string
 * * GP: number | integer | datetime
 * * DictionaryEstimator: Dict<number | integer>
 * * UtilityEstimator: Struct<{ max: number, min: number, value }>
 *
 * Accepted feature types are {@link PrimitiveType}s and dictionaries thereof.
 *
 * @param config Configuration object
 * @returns a property definition for the ML function
 *
 * @category Property
 *
 * @example
 * ```typescript
 * //... (within an agent, resource or transaction mapping)
 * properties: {
 *     //...
 *     // Create an ML function to predict the duration (in hours) of a task based on task features
 *     TaskDuration: MLFunction({
 *         output: Variable("Duration", "float"),
 *         features: {
 *             TaskType: Property("TaskType", "string"),
 *             EstimatedDuration: Property("EstimatedDuration", "float"),
 *             // Other features
 *         },
 *         train: Variable("IsHistoricData", "boolean"),
 *         evaluate: Not(Variable("IsHistoricData", "boolean"))
 *     }),
 *     //...
 * },
 * //...
 * ```
 */
export declare function MLFunction<T extends MLTypes, S extends MLSamplingMode | undefined>(config: MLFunctionConfig<T, S>): MLFunctionDefinition<MLSampledType<T, S>>;
/** @internal */
export declare type GetPropertyFunctionDefinition<T extends EastType> = {
    function: "getproperty";
    type: T;
    kind: "function";
    property_parent?: string;
    property_kind?: PropertyKind;
    property_concept: string;
    property_marker?: Expression<"string">;
    inputs: {
        marker?: Property<"string">;
        date?: Property<"datetime">;
    };
    value?: Expression<T>;
    evaluate?: Expression<"boolean">;
    objective?: Expression<"float">;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
};
/**
 * Configuration for {@link GetProperty}.
 *
 * @category Property
 */
export declare type GetPropertyConfig<T extends EastType> = {
    /** Defines the {@link PropertyStructure} that the target property belongs to. Local properties can be fetched with {@link Property}. */
    property: PropertyStructure<T> | Property<T>;
    /** The unique identifier of the property instance (optional if the {@link PropertyStructure} has just one instance) */
    marker?: Property<"string"> | Expression<"string">;
    /** The default `value` for when `evaluate` is `false` (optional) */
    value?: Expression<T>;
    /** The local property indicating when to fetch a temporal property (optional, defaults to {@link ProcessDate}) */
    date?: Property<"datetime">;
    /** A flag to set whether the simulation will fetch the property or use `value` (optional) */
    evaluate?: Expression<"boolean">;
    /** One or more {@link EastFunction}s to apply to the array of samples to generate a result */
    sampling_function?: EastFunction | Record<string, EastFunction>;
    /** One or more {@link SamplingStatistic}s to apply to the array of samples to generate a result */
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
    /** An {@link Expression} giving the contribution of this property to the global objective function, to guide optimization */
    objective?: Expression<"float">;
};
/**
 * Get a property value from another {@link Agent}, {@link Resource} or {@link Process}.
 *
 * In most cases a value for the marker will need to be provided, unless the targeted
 * property has only a single instance defined. If the value of `marker` is not valid, a
 * value of `null` is returned.
 *
 * Note that values of {@link TemporalProperty}s can only be obtained within the context of
 * a {@link Process}, where the value is taken at the corresponding {@link ProcessDate}.
 *
 * @param config Specify options - notably the `property` and the `marker` of the targeted property
 *
 * @category Property
 *
 * @example
 * ```typescript
 * import product_structure from "../gen/product.structure"
 *
 * //...
 * properties: {
 *     //...
 *     // product marker
 *     ProductId: ...,
 *     // get the price of the product
 *     ProductPrice: GetProperty({
 *         property: product_structure.properties.price,
 *         marker: Property("ProductId", "string")
 *     }),
 * }
 * //...
 * ```
 */
export declare function GetProperty<T extends EastType>(config: GetPropertyConfig<T>): GetPropertyFunctionDefinition<T>;
/** @internal */
export declare type GetPropertiesFunctionDefinition<T extends EastType> = {
    function: "getproperties";
    type: T;
    kind: "function";
    property_parent?: string;
    property_kind?: PropertyKind;
    property_concept: string;
    property_markers?: Expression<"set">;
    inputs: {
        markers?: Property<"set">;
        date?: Property<"datetime">;
    };
    value?: Expression<T>;
    evaluate?: Expression<"boolean">;
    objective?: Expression<"float">;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
};
/**
 * Configuration for {@link GetProperties}.
 *
 * @category Property
 */
export declare type GetPropertiesConfig<T extends EastType> = {
    /** Defines the {@link PropertyStructure} that the target properties belong to. Local properties can be fetched with {@link Property}. */
    property: PropertyStructure<T> | Property<T>;
    /** The unique identifiers of the property instances to be fetched (defaults to all valid markers for that property) */
    markers?: Property<"set"> | Expression<"set">;
    /** The default `value` for when `evaluate` is `false` (optional) */
    value?: Expression<DictType<T>>;
    /** The local property indicating when to fetch a temporal property (optional, defaults to {@link ProcessDate}) */
    date?: Property<"datetime">;
    /** A flag to set whether the simulation will fetch the property or use `value` (optional) */
    evaluate?: Expression<"boolean">;
    /** One or more {@link EastFunction}s to apply to the array of samples to generate a result */
    sampling_function?: EastFunction | Record<string, EastFunction>;
    /** One or more {@link SamplingStatistic}s to apply to the array of samples to generate a result */
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
    /** An {@link Expression} giving the contribution of this property to the global objective function, to guide optimization */
    objective?: Expression<"float">;
};
/**
 * Get multiple property values from other {@link Agent}s, {@link Resource}s or {@link Process}s.
 *
 * If a set of markers is not specified, the properties of all the instances will be returned.
 *
 * Note that values of {@link TemporalProperty}s can only be obtained within the context of
 * a {@link Process}, where the value is taken at the corresponding {@link ProcessDate}.
 *
 * @param config Specify options - notably the `property` and the `markers` of the targeted property
 *
 * @category Property
 *
 * @example
 * ```typescript
 * import employee_structure from "../gen/employee.structure"
 *
 * //...
 * properties: {
 *     //...
 *     // Ids of employees on this shift
 *     ShiftEmployeeIds: ...,
 *     // get the price of the product
 *     ShiftEmployeeNames: GetProperties(
 *         {
 *             property: employee_structure.properties.name,
 *             markers: Property("ShiftEmployeeIds", "set")
 *         }
 *     ),
 * }
 * //...
 * ```
 */
export declare function GetProperties<T extends EastType>(config: GetPropertiesConfig<T>): GetPropertiesFunctionDefinition<DictType<T>>;
/** @internal */
export declare type RandomFunctionDefinition<T extends EastType> = {
    function: "random";
    type: T;
    kind: "function";
    inputs: {
        number?: Property<"integer">;
    };
    value?: Expression<T>;
    evaluate?: Expression<"boolean">;
    objective?: Expression<"float">;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
} & ({
    distribution: "uniform";
} | {
    distribution: "gaussian";
} | {
    distribution: "exponential";
} | {
    distribution: "weibull";
    inputs: {
        shape: Property<"float">;
    };
} | {
    distribution: "array";
    inputs: {
        array: Property<ArrayType<T>>;
    };
} | {
    distribution: "set";
    inputs: {
        set: Property<"set">;
    };
});
/** @category Property */
export declare type UniformRandomFunctionConfig = {
    distribution: "uniform";
    value?: Expression<"float">;
    evaluate?: Expression<"boolean">;
    objective?: Expression<"float">;
    number?: undefined;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
};
/** @category Property */
export declare type UniformMultipleRandomFunctionConfig = {
    distribution: "uniform";
    value?: Expression<"float">;
    evaluate?: Expression<"boolean">;
    objective?: Expression<"float">;
    number: Property<"integer">;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
};
/** @category Property */
export declare type GaussianRandomFunctionConfig = {
    distribution: "gaussian";
    value?: Expression<"float">;
    evaluate?: Expression<"boolean">;
    objective?: Expression<"float">;
    number?: undefined;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
};
/** @category Property */
export declare type GaussianMultipleRandomFunctionConfig = {
    distribution: "gaussian";
    value?: Expression<"float">;
    evaluate?: Expression<"boolean">;
    objective?: Expression<"float">;
    number: Property<"integer">;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
};
/** @category Property */
export declare type ExponentialRandomFunctionConfig = {
    distribution: "exponential";
    value?: Expression<"float">;
    evaluate?: Expression<"boolean">;
    objective?: Expression<"float">;
    number?: undefined;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
};
/** @category Property */
export declare type ExponentialMultipleRandomFunctionConfig = {
    distribution: "exponential";
    value?: Expression<"float">;
    evaluate?: Expression<"boolean">;
    objective?: Expression<"float">;
    number: Property<"integer">;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
};
/** @category Property */
export declare type WeibullRandomFunctionConfig = {
    distribution: "weibull";
    shape: Property<"float">;
    value?: Expression<"float">;
    evaluate?: Expression<"boolean">;
    objective?: Expression<"float">;
    number?: undefined;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
};
/** @category Property */
export declare type WeibullMultipleRandomFunctionConfig = {
    distribution: "weibull";
    shape: Property<"float">;
    value?: Expression<"float">;
    evaluate?: Expression<"boolean">;
    objective?: Expression<"float">;
    number: Property<"integer">;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
};
/** @category Property */
export declare type ArrayRandomFunctionConfig<T extends EastType> = {
    distribution: "array";
    array: Property<ArrayType<T>>;
    value?: Expression<T>;
    evaluate?: Expression<"boolean">;
    objective?: Expression<"float">;
    number?: undefined;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
};
/** @category Property */
export declare type ArrayMultipleRandomFunctionConfig<T extends EastType> = {
    distribution: "array";
    array: Property<ArrayType<T>>;
    value?: Expression<T>;
    evaluate?: Expression<"boolean">;
    objective?: Expression<"float">;
    number: Property<"integer">;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
};
/** @category Property */
export declare type SetRandomFunctionConfig = {
    distribution: "set";
    set: Property<"set">;
    value?: Expression<"string">;
    evaluate?: Expression<"boolean">;
    objective?: Expression<"float">;
    number?: undefined;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
};
/** @category Property */
export declare type SetMultipleRandomFunctionConfig = {
    distribution: "set";
    set: Property<"set">;
    value?: Expression<"string">;
    evaluate?: Expression<"boolean">;
    objective?: Expression<"float">;
    number: Property<"integer">;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
};
/**
 * One of a number of random distribution configurations.
 *
 * @category Property
 */
export declare type RandomFunctionConfig = UniformRandomFunctionConfig | UniformMultipleRandomFunctionConfig | GaussianRandomFunctionConfig | GaussianMultipleRandomFunctionConfig | ExponentialRandomFunctionConfig | ExponentialMultipleRandomFunctionConfig | WeibullRandomFunctionConfig | WeibullMultipleRandomFunctionConfig | ArrayRandomFunctionConfig<EastType> | ArrayMultipleRandomFunctionConfig<EastType> | SetRandomFunctionConfig | SetMultipleRandomFunctionConfig;
/**
 * Create a property with a random value.
 *
 * We are able to draw samples from a variety of statistical distributions, including uniform,
 * Gaussian, exponential, Weibull, or picking one or more entries of a given array or set.
 *
 * @param config A {@link RandomFunctionConfig} describing the random distribution
 * @returns A property definition for a random function property definition
 *
 * @category Property
 */
export declare function Random(config: UniformMultipleRandomFunctionConfig): RandomFunctionDefinition<ArrayType<"float">>;
export declare function Random(config: UniformRandomFunctionConfig): RandomFunctionDefinition<"float">;
export declare function Random(config: GaussianMultipleRandomFunctionConfig): RandomFunctionDefinition<ArrayType<"float">>;
export declare function Random(config: GaussianRandomFunctionConfig): RandomFunctionDefinition<"float">;
export declare function Random(config: ExponentialMultipleRandomFunctionConfig): RandomFunctionDefinition<ArrayType<"float">>;
export declare function Random(config: ExponentialRandomFunctionConfig): RandomFunctionDefinition<"float">;
export declare function Random(config: WeibullMultipleRandomFunctionConfig): RandomFunctionDefinition<ArrayType<"float">>;
export declare function Random(config: WeibullRandomFunctionConfig): RandomFunctionDefinition<"float">;
export declare function Random<T extends EastType>(config: ArrayMultipleRandomFunctionConfig<T>): RandomFunctionDefinition<ArrayType<T>>;
export declare function Random<T extends EastType>(config: ArrayRandomFunctionConfig<T>): RandomFunctionDefinition<T>;
export declare function Random(config: SetMultipleRandomFunctionConfig): RandomFunctionDefinition<ArrayType<"string">>;
export declare function Random(config: SetRandomFunctionConfig): RandomFunctionDefinition<"string">;
/** @internal */
export declare type FunctionDefinition<T extends EastType> = GenericFunctionDefinition<T> | MLFunctionDefinition<T> | GetPropertyFunctionDefinition<T> | GetPropertiesFunctionDefinition<T> | RandomFunctionDefinition<T>;
/** @internal */
export declare type FunctionPropertyMapping<T extends EastType = EastType> = {
    type: T;
    kind: "function";
    value: EastFunction<T> | null;
    function: FunctionMapping<T>;
    sampling_function?: StructFunction;
    objective?: EastFunction<"float">;
};
/** @category Property */
export declare type FunctionPropertyStructure<T extends EastType = EastType> = {
    type: T;
    kind: "function";
    parent: string;
    concept: string;
    marker?: string;
    function: FunctionStructure<T>;
    result_table?: Table;
    sampling_function?: StructFunction;
};
/** @internal */
export declare type FunctionProperty<T extends EastType = EastType> = {
    type: T;
    kind: "function";
    value: ValueTypeOf<T> | null;
    function: Function<T>;
    sampling_function?: StructFunction;
    objective?: EastFunction<"float">;
};
/** @internal */
export declare function toFunctionStructure<T extends EastType>(func: Function<T> | FunctionMapping<T>, parent: string, concept: string): FunctionStructure<T>;
