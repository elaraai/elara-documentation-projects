// Â© Copyright 2018- 2022 - Elara AI Pty Ltd ACN 627 124 903
//
// Licensed under the EDK Licence version LICENSE-1.04.
//
// You may only use this file in accordance with the terms and conditions contained in EDK
// Licence - Version LICENSE-1.04. The full version of the EDK Licence is available at:
// https://elaraai.github.io/docs/license

import { Table } from '../data/Table';
import { Expression } from '../east/definition';
import { EastFunction, StructFunction, TimeUnit, Variable } from '../east/functions';
import { EastType, ValueTypeOf } from '../east/types';
import { FunctionDefinition, FunctionProperty, FunctionPropertyMapping, FunctionPropertyStructure } from './Function';
import { OptionProperty, OptionPropertyDefinition, OptionPropertyMapping, OptionPropertyStructure } from './Option';
import { PropertyReference, PropertyReferenceMapping } from './PropertyReference';
/**
 * There are four kinds of properties:
 *  * `'value'`: a predetermined, fixed value
 *  * `'option'`: value can differ from scenario to scenario
 *  * `'function'`: value is calculated during the simulation
 *  * `'temporal'`: value evolves over time
 *
 * @category Property
 */
export declare type PropertyKind = "value" | "option" | "function" | "settable" | "temporal";
/** A property instance with a fixed, predetermined value.
 *
 * @category Property
*/
export declare type ValueProperty<T extends EastType = EastType> = {
    /** The {@link EastType} of the property */
    type: T;
    /** The {@link PropertyKind} of the property */
    kind: "value";
    /** The fixed value of this property */
    value: ValueTypeOf<T> | null;
};
/** A property instance whose value can be set exactly once.
 *
 * @category Property
*/
export declare type SettableProperty<T extends EastType = EastType> = {
    /** The {@link EastType} of the property */
    type: T;
    /** The {@link PropertyKind} of the property */
    kind: "settable";
    /** The value of this property if active is `false` */
    value: ValueTypeOf<T> | null;
    /** If set to `false`, the property behaves as a `ValueProperty` and cannot be set */
    active: boolean;
    /** @internal */
    sampling_function?: StructFunction;
    /** An {@link EastFunction} that returns this property's contribution to the global objective function, to guide optimization */
    objective?: EastFunction<"float">;
};
/** A property instance whose value can evolve over time.
 *
 * @category Property
*/
export declare type TemporalProperty<T extends EastType = EastType> = {
    /** The {@link EastType} of the property */
    type: T;
    /** The {@link PropertyKind} of the property */
    kind: "temporal";
    /** The inital value of this property at the start of the simulation */
    value: ValueTypeOf<T> | null;
    /** @internal */
    sampling_period?: number;
    /** @internal */
    sampling_unit?: TimeUnit;
    /** @internal */
    sampling_function?: StructFunction;
    /** An {@link EastFunction} that returns this property's contribution to the global objective function, to guide optimization */
    objective?: EastFunction<"float">;
};
/** @category Property */
export declare type PropertyInstance<T extends EastType = EastType> = ValueProperty<T> | OptionProperty<T> | FunctionProperty<T> | SettableProperty<T> | TemporalProperty<T>;
/**
 * A mapping for creating {@link ValueProperty}s (with a fixed, predetermined value) from rows of a {@link Table}.
 *
 * @category Property
*/
export declare type ValuePropertyMapping<T extends EastType = EastType> = {
    /** The {@link EastType} of the property */
    type: T;
    /** The {@link PropertyKind} of the property */
    kind: "value";
    /** The {@link EastFunction} that generates the value for the property from the table row */
    value: EastFunction<T>;
};
/**
 * A mapping for creating {@link SettablePropery}s (whose value can be set exactly once) from rows of a {@link Table}.
 *
 * @category Property
*/
export declare type SettablePropertyMapping<T extends EastType = EastType> = {
    /** The {@link EastType} of the property */
    type: T;
    /** The {@link PropertyKind} of the property */
    kind: "settable";
    /** The {@link EastFunction} that generates the value of this property if active is `false` from the table row */
    value: EastFunction<T>;
    /** The {@link EastFunction} that determines whether the property is settable or takes a fixed value from the table row */
    active: EastFunction<"boolean">;
    /** @internal */
    sampling_function?: StructFunction;
    /** An {@link EastFunction} that returns the property's contribution to the global objective function, to guide optimization */
    objective?: EastFunction<"float">;
};
/**
 * A mapping for creating {@link TemporalPropery}s (whose value can evolve over time) from rows of a {@link Table}.
 *
 * @category Property
*/
export declare type TemporalPropertyMapping<T extends EastType = EastType> = {
    /** The {@link EastType} of the property */
    type: T;
    /** The {@link PropertyKind} of the property */
    kind: "temporal";
    /** The {@link EastFunction} that generates the initial value for the property from the table row */
    value: EastFunction<T>;
    /** @internal */
    sampling_period?: number;
    /** @internal */
    sampling_unit?: TimeUnit;
    /** @internal */
    sampling_function?: StructFunction;
    /** An {@link EastFunction} that returns the property's contribution to the global objective function, to guide optimization */
    objective?: EastFunction<"float">;
};
/** @category Property */
export declare type PropertyMapping<T extends EastType = EastType> = ValuePropertyMapping<T> | OptionPropertyMapping<T> | FunctionPropertyMapping<T> | SettablePropertyMapping<T> | TemporalPropertyMapping<T>;
/** The structure for a set of properties with fixed, predetermined value.
 *
 * @category Property
*/
export declare type ValuePropertyStructure<T extends EastType = EastType> = {
    /** The {@link EastType} of the property */
    type: T;
    /** The {@link PropertyKind} of the property */
    kind: "value";
    /** The identifier of the {@link AgentStructure}, {@link ResourceStructure} or {@link ProcessStructure} that this property belongs to */
    parent: string;
    /** The unique identifier of this property structure */
    concept: string;
    /** If there is exactly one instance belonging to this structure, its marker is recorded here */
    marker?: string;
};
/** The structure for a set of properties whose value can evolve over time.
 *
 * @category Property
*/
export declare type SettablePropertyStructure<T extends EastType = EastType> = {
    /** The {@link EastType} of the property */
    type: T;
    /** The {@link PropertyKind} of the property */
    kind: "settable";
    /** The identifier of the {@link AgentStructure}, {@link ResourceStructure} or {@link ProcessStructure} that this property belongs to */
    parent: string;
    /** The unique identifier of this property structure */
    concept: string;
    /** If there is exactly one instance belonging to this structure, its marker is recorded here */
    marker?: string;
    /** A {@link Table} containing the simulation results */
    result_table?: Table;
    /** A set of {@link EastFunction}s to apply to the array of results to generate a sample */
    sampling_function?: StructFunction;
};
/** The structure for a set of properties whose value can evolve over time.
 *
 * @category Property
*/
export declare type TemporalPropertyStructure<T extends EastType = EastType> = {
    /** The {@link EastType} of the property */
    type: T;
    /** The {@link PropertyKind} of the property */
    kind: "temporal";
    /** The identifier of the {@link AgentStructure}, {@link ResourceStructure} or {@link ProcessStructure} that this property belongs to */
    parent: string;
    /** The unique identifier of this property structure */
    concept: string;
    /** If there is exactly one instance belonging to this structure, its marker is recorded here */
    marker?: string;
    /** A {@link Table} containing the simulation results */
    result_table?: Table;
    /** The period at which results are sampled */
    sampling_period?: number;
    /** The {@link TimeUnit} at which results are sampled. If `sampling_period` and `sampling_unit` are unspecified, only the final result is reported. */
    sampling_unit?: TimeUnit;
    /** A set of {@link EastFunction}s to apply to the array of results to generate a sample */
    sampling_function?: StructFunction;
};
/** @category Property */
export declare type PropertyStructure<T extends EastType = EastType> = ValuePropertyStructure<T> | OptionPropertyStructure<T> | FunctionPropertyStructure<T> | SettablePropertyStructure<T> | TemporalPropertyStructure<T>;
/** @internal */
export declare type SettablePropertyDefinition<T extends EastType> = {
    type: T;
    kind: "settable";
    value: Expression<T>;
    active?: Expression<"boolean">;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
    objective?: Expression<"float">;
};
/** @internal */
export declare type TemporalPropertyDefinition<T extends EastType> = {
    type: T;
    kind: "temporal";
    initial_value: Expression<T>;
    sampling_period?: number;
    sampling_unit?: TimeUnit;
    sampling_function?: EastFunction | Record<string, EastFunction>;
    sampling_statistic?: SamplingStatistic | "none" | Record<string, SamplingStatistic>;
    objective?: Expression<"float">;
};
/** @category Property */
declare type Numeral = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
/** @category Property */
export declare type SamplingStatistic = "mean" | "median" | "stddev" | "mode" | "minimum" | "maximum" | "first" | "all" | `p${Numeral}${Numeral}` | `p${Numeral}` | "p100";
/**
 * An object for defining a settable property.
 *
 * The `active` flag controls whether the value needs to be set during the simulation or
 * is known in advance. In either case, the `value` field must be provided so that the
 * {@link EastType} of the property can be inferred.
 *
 * The stochastic simulation will generate different property values for each trajectory.
 * You can specify one or more {@link SamplingStatistic}'s to report on, such as the
 * `"mean"` value, using the `sampling_statistic` field. Advanced
 * users can use `sampling_function` to generate custom statistics from an array of results.
 *
 * @category Property
 */
export declare type SettablePropertyConfig<T extends EastType> = {
    /** An {@link Expression} that generates the value of this property if active is `false` (if unnecessary, use `Null(type)` to specify {@link EastType} of the property) */
    value: Expression<T>;
    /** When `false`, the property behaves as a `ValueProperty` and cannot be set */
    active?: Expression<"boolean">;
    /** One or more {@link Expression} to apply to the array of samples to generate a result */
    sampling_function?: Record<string, EastFunction> | EastFunction;
    /** One or more {@link SamplingStatistic}s to generate a result */
    sampling_statistic?: Record<string, SamplingStatistic> | SamplingStatistic | "none";
    /** An {@link Expression} that returns the property's contribution to the global objective function, to guide optimization */
    objective?: Expression<"float">;
};
/**
 * Create a settable property.
 *
 * @param def the {@link SettablePropertyConfig} for the property
 *
 * @category Property
*/
export declare function Settable<T extends EastType>(def: SettablePropertyConfig<T>): SettablePropertyDefinition<T>;
/**
 * An object for defining a temporal property.
 *
 * The initial value (at the beginning of the simulation) must be specified.
 *
 * The reporting of the simulation results can be controlled.
 *
 * By default, only the results at the end of the simulation are reported. Setting the
 * `sampling_unit` and `sampling_period` causes the results to be reported at regular time
 * intervals.
 *
 * The stochastic simulation will generate different property values for each trajectory.
 * You can specify one or more {@link SamplingStatistic}'s to report on, such as the
 * `"mean"` value, using the `sampling_statistic` field. Advanced
 * users can use `sampling_function` to generate custom statistics from an array of results.
 *
 * @category Property
 */
export declare type TemporalPropertyConfig<T extends EastType> = {
    /** An {@link Expression} that generates the initial value for the property */
    initial_value: Expression<T>;
    /** The period at which results are sampled */
    sampling_period?: number;
    /** The {@link TimeUnit} at which results are sampled. If `sampling_period` and `sampling_unit` are unspecified, only the final result is reported. */
    sampling_unit?: TimeUnit;
    /** One or more {@link Expression} to apply to the array of samples to generate a result */
    sampling_function?: Record<string, EastFunction> | EastFunction;
    /** One or more {@link SamplingStatistic}s to generate a result */
    sampling_statistic?: Record<string, SamplingStatistic> | SamplingStatistic | "none";
    /** An {@link Expression} that returns the property's contribution to the global objective function, to guide optimization */
    objective?: Expression<"float">;
};
/**
 * Create a temporal property.
 *
 * @param def the {@link TemporalPropertyConfig} for the property
 *
 * @category Property
*/
export declare function Temporal<T extends EastType>(def: TemporalPropertyConfig<T>): TemporalPropertyDefinition<T>;
/** @internal */
export declare type PropertyDefinition<T extends EastType = EastType> = Expression<T> | OptionPropertyDefinition<T> | SettablePropertyDefinition<T> | TemporalPropertyDefinition<T> | FunctionDefinition<T>;
/** @internal */
export declare function isSettablePropertyDefinition<T extends EastType>(def: PropertyDefinition<T>): def is SettablePropertyDefinition<T>;
/** @internal */
export declare function isTemporalPropertyDefinition<T extends EastType>(def: PropertyDefinition<T>): def is TemporalPropertyDefinition<T>;
/** @internal */
export declare function isFunctionPropertyDefinition<T extends EastType>(def: PropertyDefinition<T>): def is FunctionDefinition<T>;
/** @internal */
export declare function isOptionPropertyDefinition<T extends EastType>(def: PropertyDefinition<T>): def is OptionPropertyDefinition<T>;
/** @internal */
export declare function toProperty<T extends EastType>(parent: string, marker: string, property_concept: string, def: PropertyDefinition<T>, local_properties: Record<string, PropertyReference>): PropertyInstance<T>;
/** @internal */
export declare function toPropertyMapping<T extends EastType>(parent: string, marker: EastFunction<"string">, property_concept: string, def: PropertyDefinition<T>, fields: Record<string, Variable>, local_properties: Record<string, PropertyReferenceMapping>): PropertyMapping<T>;
/** @internal */
export declare function toPropertyStructure<T extends EastType>(property: PropertyInstance<T> | PropertyMapping<T>, parent: string, concept: string, marker?: string): PropertyStructure<T>;
/** @internal */
export declare function propertiesTables(properties: Record<string, PropertyStructure>): Record<string, Table>;
/** @internal */
export declare function propertyTables(property: PropertyStructure): Record<string, Table>;
/** @internal */
export declare function makePropertyReference<T extends EastType>(parent: string, marker: string, property_concept: string, def: PropertyDefinition<T>): PropertyReference<T>;
/** @internal */
export declare function makePropertyReferenceMapping<T extends EastType>(parent: string, marker: EastFunction<"string">, property_concept: string, def: PropertyDefinition<T>): PropertyReferenceMapping<T>;
export {};
