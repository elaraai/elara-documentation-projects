// Â© Copyright 2018- 2022 - Elara AI Pty Ltd ACN 627 124 903
//
// Licensed under the EDK Licence version LICENSE-1.04.
//
// You may only use this file in accordance with the terms and conditions contained in EDK
// Licence - Version LICENSE-1.04. The full version of the EDK Licence is available at:
// https://elaraai.github.io/docs/license

import { AxisTypeOf, AxisValueTypeOf } from "./Axis";
import { Color, ColorValue, GroupColorDefinition, RowColorDefinition } from "./Color";
import { View, ViewAggregation, ViewGroup } from "../analytics/View";
import { PrimitiveType } from "../east/types";
import { Variable } from "../east/functions";
/**
 * Defines an {@link AnnotationType} type to display within a {@link Visual}.
 *
 * @category Annotation
 */
export declare type AnnotationType = 'square' | 'line' | 'circle' | 'marker' | 'image';
/**
 * Defines an {@link AnnotationKind} to display within a {@link Visual}, either mapped from data, or an individual instance.
 *
 * @category Annotation
 */
export declare type AnnotationKind = 'mapping' | 'instance';
/** @internal */
export declare type Annotation<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType, T extends AnnotationType = AnnotationType, K extends AnnotationKind = AnnotationKind> = K extends 'mapping' ? (T extends 'square' ? {
    type: T;
    kind: K;
    view: string;
    x1: Variable<X> | null;
    y1: Variable<Y> | null;
    x2: Variable<X> | null;
    y2: Variable<Y> | null;
    stroke_type: 'solid' | 'dashed';
    stroke_thickness: Variable<'float'> | null;
    stroke: Color | null;
    background: Color | null;
    background_opacity: Variable<'float'> | null;
} : T extends 'line' ? {
    type: T;
    kind: K;
    view: string;
    line_type: 'bounded' | 'unbounded';
    x1: Variable<X>;
    y1: Variable<Y>;
    x2: Variable<X>;
    y2: Variable<Y>;
    stroke_type: 'solid' | 'dashed';
    stroke_thickness: Variable<'float'> | null;
    stroke: Color | null;
} : T extends 'circle' ? {
    type: T;
    kind: K;
    view: string;
    cx: Variable<X>;
    cy: Variable<Y>;
    radius: Variable<'float'>;
    background: Color | null;
    background_opacity: Variable<'float'> | null;
    stroke_type: 'solid' | 'dashed';
    stroke_thickness: Variable<'float'> | null;
    stroke: Color | null;
} : never) : K extends 'instance' ? (T extends 'square' ? {
    type: T;
    kind: K;
    x1: AxisValueTypeOf<AxisTypeOf<X>>;
    y1: AxisValueTypeOf<AxisTypeOf<Y>>;
    x2: AxisValueTypeOf<AxisTypeOf<X>>;
    y2: AxisValueTypeOf<AxisTypeOf<Y>>;
    stroke_type: 'solid' | 'dashed';
    stroke_thickness: number | null;
    stroke: ColorValue | null;
    background: ColorValue | null;
    background_opacity: number | null;
} : T extends 'line' ? {
    type: T;
    kind: K;
    line_type: 'bounded' | 'unbounded';
    x1: AxisValueTypeOf<AxisTypeOf<X>>;
    y1: AxisValueTypeOf<AxisTypeOf<Y>>;
    x2: AxisValueTypeOf<AxisTypeOf<X>>;
    y2: AxisValueTypeOf<AxisTypeOf<Y>>;
    stroke_type: 'solid' | 'dashed';
    stroke_thickness: number | null;
    stroke: ColorValue | null;
} : T extends 'circle' ? {
    type: T;
    kind: K;
    cx: AxisValueTypeOf<AxisTypeOf<X>>;
    cy: AxisValueTypeOf<AxisTypeOf<Y>>;
    radius: number;
    background: ColorValue | null;
    background_opacity: number | null;
    stroke_type: 'solid' | 'dashed';
    stroke_thickness: number | null;
    stroke: ColorValue | null;
} : never) : never;
/**
 * Defines an annotation to display within a {@link GroupVisual}, either mapped from a {@link GroupView}, or an individual instance.
 *
 * @category Annotation
 */
export declare type GroupAnnotationDefinition<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType, T extends AnnotationType = AnnotationType, K extends AnnotationKind = AnnotationKind> = K extends 'mapping' ? (T extends 'square' ? {
    /** the {@link AnnotationType} */
    type: T;
    /** the {@link AnnotationKind} */
    kind: K;
    /** the {@link GroupView} to use for the annotation */
    view: View;
    /** the {@link ViewAggregation} or {@link GroupView} containing the x value of the top-left corner */
    x1: ViewAggregation<X> | ViewGroup<X>;
    /** the {@link ViewAggregation} or {@link GroupView} containing the y value of the top-left corner */
    y1: ViewAggregation<Y> | ViewGroup<Y>;
    /** the {@link ViewAggregation} or {@link GroupView} containing the x value of the bottom-right corner */
    x2: ViewAggregation<X> | ViewGroup<X>;
    /** the {@link ViewAggregation} or {@link GroupView} containing the y value of the bottom-right corner */
    y2: ViewAggregation<Y> | ViewGroup<Y>;
    /** the stroke style for the {@link GroupAnnotationDefinition} */
    stroke_type: 'solid' | 'dashed';
    /** the {@link ViewAggregation} or {@link GroupView} containing the stroke thickness (in pixels) */
    stroke_thickness: ViewAggregation<'float'> | ViewGroup<'float'>;
    /** the stroke color as a {@link GroupColorDefinition} */
    stroke?: GroupColorDefinition;
    /** the background color as a {@link GroupColorDefinition} */
    background?: GroupColorDefinition;
    /** the {@link ViewAggregation} or {@link GroupView} containing the background opacity (normalised in the UI) */
    background_opacity: ViewAggregation<'float'> | ViewGroup<'float'>;
} : T extends 'line' ? {
    /** the {@link AnnotationType} */
    type: T;
    /** the {@link AnnotationKind} */
    kind: K;
    /** the {@link GroupView} to use for the annotation */
    view: View;
    /** the line type to draw */
    line_type: 'bounded' | 'unbounded';
    /** the {@link ViewAggregation} or {@link GroupView} containing the x value of the line start point */
    x1: ViewAggregation<X> | ViewGroup<X>;
    /** the {@link ViewAggregation} or {@link GroupView} containing the y value of the line start point */
    y1: ViewAggregation<Y> | ViewGroup<Y>;
    /** the {@link ViewAggregation} or {@link GroupView} containing the x value of the line end point */
    x2: ViewAggregation<X> | ViewGroup<X>;
    /** the {@link ViewAggregation} or {@link GroupView} containing the y value of the line end point */
    y2: ViewAggregation<Y> | ViewGroup<Y>;
    /** the stroke style for the {@link GroupAnnotationDefinition} */
    stroke_type: 'solid' | 'dashed';
    /** the {@link ViewAggregation} or {@link GroupView} containing the background opacity (normalised in the UI) */
    stroke_thickness: ViewAggregation<'float'> | ViewGroup<'float'>;
    /** the stroke color as a {@link GroupColorDefinition} */
    stroke?: GroupColorDefinition;
} : T extends 'circle' ? {
    /** the {@link AnnotationType} */
    type: T;
    /** the {@link AnnotationKind} */
    kind: K;
    /** the {@link GroupView} to use for the annotation */
    view: View;
    /** the {@link ViewAggregation} or {@link GroupView} containing the x value of the centre */
    cx: ViewAggregation<X> | ViewGroup<X>;
    /** the {@link ViewAggregation} or {@link GroupView} containing the y value of the centre */
    cy: ViewAggregation<Y> | ViewGroup<Y>;
    /** the {@link ViewAggregation} or {@link GroupView} containing the radius (in pixels) */
    radius: ViewAggregation<'float'> | ViewGroup<'float'>;
    /** the background color as a {@link GroupColorDefinition} */
    background?: GroupColorDefinition;
    /** the {@link ViewAggregation} or {@link GroupView} containing the background opacity (normalised in the UI) */
    background_opacity: ViewAggregation<'float'> | ViewGroup<'float'>;
    /** the stroke style for the {@link GroupAnnotationDefinition} */
    stroke_type: 'solid' | 'dashed';
    /** the {@link ViewAggregation} or {@link GroupView} containing the stroke thickness (in pixels) */
    stroke_thickness: ViewAggregation<'float'> | ViewGroup<'float'>;
    /** the stroke color as a {@link GroupColorDefinition} */
    stroke?: GroupColorDefinition;
} : never) : K extends 'instance' ? (T extends 'square' ? {
    /** the {@link AnnotationType} */
    type: T;
    /** the {@link AnnotationKind} */
    kind: K;
    /** the {@link AxisValue} containing the x value of the top-left corner */
    x1: AxisValueTypeOf<AxisTypeOf<X>>;
    /** the {@link AxisValue} containing the y value of the top-left corner */
    y1: AxisValueTypeOf<AxisTypeOf<Y>>;
    /** the {@link AxisValue} containing the x value of the bottom-right corner */
    x2: AxisValueTypeOf<AxisTypeOf<X>>;
    /** the {@link AxisValue} containing the y value of the bottom-right corner */
    y2: AxisValueTypeOf<AxisTypeOf<Y>>;
    /** the stroke style for the {@link GroupAnnotationDefinition} */
    stroke_type: 'solid' | 'dashed';
    /** the number containing the stroke thickness (in pixels) */
    stroke_thickness: number | null;
    /** the stroke color as a {@link ColorValue} */
    stroke: ColorValue | null;
    /** the background color as a {@link ColorValue} */
    background: ColorValue | null;
    /** the number containing the background opacity (normalised in the UI) */
    background_opacity: number | null;
} : T extends 'line' ? {
    /** the {@link AnnotationType} */
    type: T;
    /** the {@link AnnotationKind} */
    kind: K;
    /** the line type to draw */
    line_type: 'bounded' | 'unbounded';
    /** the {@link AxisValue} containing the x value of the line start point */
    x1: AxisValueTypeOf<AxisTypeOf<X>>;
    /** the {@link AxisValue} containing the y value of the line start point */
    y1: AxisValueTypeOf<AxisTypeOf<Y>>;
    /** the {@link AxisValue} containing the x value of the line end point */
    x2: AxisValueTypeOf<AxisTypeOf<X>>;
    /** the {@link AxisValue} containing the y value of the line end point */
    y2: AxisValueTypeOf<AxisTypeOf<Y>>;
    /** the stroke style for the {@link GroupAnnotationDefinition} */
    stroke_type: 'solid' | 'dashed';
    /** the number containing the stroke thickness (in pixels) */
    stroke_thickness: number | null;
    /** the stroke color as a {@link ColorValue} */
    stroke: ColorValue | null;
} : T extends 'circle' ? {
    /** the {@link AnnotationType} */
    type: T;
    /** the {@link AnnotationKind} */
    kind: K;
    /** the {@link AxisValue} containing the x value of the centre */
    cx: AxisValueTypeOf<AxisTypeOf<X>>;
    /** the {@link AxisValue} containing the y value of the centre */
    cy: AxisValueTypeOf<AxisTypeOf<Y>>;
    /** the number containing the radius (in pixels) */
    radius: number;
    /** the background color as a {@link ColorValue} */
    background: ColorValue | null;
    /** the number containing the background opacity (normalised in the UI) */
    background_opacity: number | null;
    /** the stroke style for the {@link GroupAnnotationDefinition} */
    stroke_type: 'solid' | 'dashed';
    /** the number containing the stroke thickness (in pixels) */
    stroke_thickness: number | null;
    /** the stroke color as a {@link ColorValue} */
    stroke: ColorValue | null;
} : never) : never;
/**
 * Create a {@link GroupSquareAnnotation} to display within a {@link Visual}, mapped from a {@link GroupView}.
 *
 * @param definition: the desired {@link GroupAnnotationDefinition}.
 * @return a valid {@link GroupSquareAnnotation}
 *
 * @category Annotation
 *
 * @example
 * ```typescript
 * import group_view from './gen/group.view;
 * // create a square filling the visible y range, between two points [{ x: Start, y: undefined }, { x: End, y: undefined }]
 * const square = GroupSquareAnnotation({
 *     view: group_view,
 *     x1: group_view.groups.Start,
 *     x2: group_view.groups.End,
 *     background: ColorValue('#555555'),
 *     stroke: ColorValue(group_view.groups.Color),
 * })
 * ```
 */
export declare function GroupSquareAnnotation<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType>(config: Omit<GroupAnnotationDefinition<X, Y, 'square', 'mapping'>, 'type' | 'kind'>): GroupAnnotationDefinition<X, Y, 'square'>;
/** @internal */
export declare function toGroupSquareAnnotation<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType>(def: GroupAnnotationDefinition<X, Y, 'square', 'mapping'>): Annotation<X, Y, 'square', 'mapping'>;
/**
 * Create a {@link GroupLineAnnotation} to display within a {@link Visual}, mapped from a {@link GroupView}.
 *
 * @param definition: the desired {@link GroupAnnotationDefinition}.
 * @return a valid {@link GroupLineAnnotation}
 *
 * @category Annotation
 *
 * @example
 * ```typescript
 * import group_view from './gen/group.view;
 * // create a line between two points [{ x: Start, y: MinValue}, { x: End, y:MaxValue }]
 * const line = GroupLineAnnotation({
 *     view: group_view,
 *     x1: group_view.groups.Start,
 *     y1: group_view.aggregations.MinValue,
 *     x2: group_view.groups.End,
 *     y2: group_view.aggregations.MaxValue,
 *     background: ColorValue('#555555'),
 *     stroke: ColorValue(group_view.groups.Color),
 * })
 * ```
 */
export declare function GroupLineAnnotation<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType>(config: Omit<GroupAnnotationDefinition<X, Y, 'line', 'mapping'>, 'type' | 'kind'>): GroupAnnotationDefinition<X, Y, 'line'>;
/** @internal */
export declare function toGroupLineAnnotation<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType>(def: GroupAnnotationDefinition<X, Y, 'line', 'mapping'>): Annotation<X, Y, 'line', 'mapping'>;
/**
 * Create a {@link GroupCircleAnnotation} to display within a {@link Visual}, mapped from a {@link GroupView}.
 *
 * @param definition: the desired {@link GroupAnnotationDefinition}.
 * @return a valid {@link GroupCircleAnnotation}
 *
 * @category Annotation
 *
 * @example
 * ```typescript
 * import group_view from './gen/group.view;
 * // create a circle at a point [{ x: Start, y: MinValue}] with radius TotalValue
 * const circle = GroupCircleAnnotation({
 *     view: group_view,
 *     cx: group_view.groups.Start,
 *     cy: group_view.aggregations.MinValue,
 *     radius: group_view.aggregations.TotalValue,
 *     background: ColorValue('#555555'),
 *     stroke: ColorValue(group_view.groups.Color),
 * })
 * ```
 */
export declare function GroupCircleAnnotation<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType>(config: Omit<GroupAnnotationDefinition<X, Y, 'circle', 'mapping'>, 'type' | 'kind'>): GroupAnnotationDefinition<X, Y, 'circle'>;
/** @internal */
export declare function toGroupCircleAnnotation<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType>(def: GroupAnnotationDefinition<X, Y, 'circle', 'mapping'>): Annotation<X, Y, 'circle', 'mapping'>;
/** @internal */
export declare function toGroupAnnotation<X extends PrimitiveType, Y extends PrimitiveType, T extends AnnotationType = AnnotationType>(def: GroupAnnotationDefinition<X, Y, T>): Annotation<X, Y, T>;
/**
 * Create a {@link RowAnnotationDefinition} to display within a {@link Visual}, either mapped from a {@link RowView}, or an individual instance.
 *
 * @category Annotation
 */
export declare type RowAnnotationDefinition<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType, T extends AnnotationType = AnnotationType, K extends AnnotationKind = AnnotationKind> = K extends 'mapping' ? (T extends 'square' ? {
    /** the {@link AnnotationType} */
    type: T;
    /** the {@link AnnotationKind} */
    kind: K;
    /** the {@link RowView} to use for the annotation */
    view: View;
    /** the {@link Variable} containing the x value of the top-left corner */
    x1?: Variable<X>;
    /** the {@link Variable} containing the y value of the top-left corner */
    y1?: Variable<Y>;
    /** the {@link Variable} containing the x value of the bottom-right corner */
    x2?: Variable<X>;
    /** the {@link Variable} containing the y value of the bottom-right corner */
    y2?: Variable<Y>;
    /** the stroke style for the {@link RowAnnotationDefinition} */
    stroke_type?: 'solid' | 'dashed';
    /** the {@link Variable} containing the stroke thickness (in pixels) */
    stroke_thickness?: Variable<'float'>;
    /** the stroke color as a {@link RowColorDefinition} */
    stroke?: RowColorDefinition;
    /** the background color as a {@link RowColorDefinition} */
    background?: RowColorDefinition;
    /** the {@link Variable} containing the background opacity (normalised in the UI) */
    background_opacity?: Variable<'float'>;
} : T extends 'line' ? {
    /** the {@link AnnotationType} */
    type: T;
    /** the {@link AnnotationKind} */
    kind: K;
    /** the {@link RowView} to use for the annotation */
    view: View;
    /** the line type to draw */
    line_type: 'bounded' | 'unbounded';
    /** the {@link Variable} containing the x value of the line start point */
    x1: Variable<X>;
    /** the {@link Variable} containing the y value of the line start point */
    y1: Variable<Y>;
    /** the {@link Variable} containing the x value of the line end point */
    x2: Variable<X>;
    /** the {@link Variable} containing the y value of the line end point */
    y2: Variable<Y>;
    /** the stroke style for the {@link RowAnnotationDefinition} */
    stroke_type: 'solid' | 'dashed';
    /** the {@link Variable} containing the background opacity (normalised in the UI) */
    stroke_thickness: Variable<'float'>;
    /** the stroke color as a {@link RowColorDefinition} */
    stroke?: RowColorDefinition;
} : T extends 'circle' ? {
    /** the {@link AnnotationType} */
    type: T;
    /** the {@link AnnotationKind} */
    kind: K;
    /** the {@link RowView} to use for the annotation */
    view: View;
    /** the {@link Variable} containing the x value of the centre */
    cx: Variable<X>;
    /** the {@link Variable} containing the y value of the centre */
    cy: Variable<Y>;
    /** the {@link Variable} containing the radius (in pixels) */
    radius: Variable<'float'>;
    /** the background color as a {@link RowColorDefinition} */
    background?: RowColorDefinition;
    /** the {@link Variable} containing the background opacity (normalised in the UI) */
    background_opacity: Variable<'float'>;
    /** the stroke style for the {@link RowAnnotationDefinition} */
    stroke_type: 'solid' | 'dashed';
    /** the {@link Variable} containing the stroke thickness (in pixels) */
    stroke_thickness: Variable<'float'>;
    /** the stroke color as a {@link RowColorDefinition} */
    stroke?: RowColorDefinition;
} : never) : K extends 'instance' ? (T extends 'square' ? {
    /** the {@link AnnotationType} */
    type: T;
    /** the {@link AnnotationKind} */
    kind: K;
    /** the {@link AxisValue} containing the x value of the top-left corner */
    x1: AxisValueTypeOf<AxisTypeOf<X>>;
    /** the {@link AxisValue} containing the y value of the top-left corner */
    y1: AxisValueTypeOf<AxisTypeOf<Y>>;
    /** the {@link AxisValue} containing the x value of the bottom-right corner */
    x2: AxisValueTypeOf<AxisTypeOf<X>>;
    /** the {@link AxisValue} containing the y value of the bottom-right corner */
    y2: AxisValueTypeOf<AxisTypeOf<Y>>;
    /** the stroke style for the {@link RowAnnotationDefinition} */
    stroke_type: 'solid' | 'dashed';
    /** the number containing the stroke thickness (in pixels) */
    stroke_thickness: number | null;
    /** the stroke color as a {@link ColorValue} */
    stroke: ColorValue | null;
    /** the background color as a {@link ColorValue} */
    background: ColorValue | null;
    /** the number containing the background opacity (normalised in the UI) */
    background_opacity: number | null;
} : T extends 'line' ? {
    /** the {@link AnnotationType} */
    type: T;
    /** the {@link AnnotationKind} */
    kind: K;
    /** the line type to draw */
    line_type: 'bounded' | 'unbounded';
    /** the {@link AxisValue} containing the x value of the line start point */
    x1: AxisValueTypeOf<AxisTypeOf<X>>;
    /** the {@link AxisValue} containing the y value of the line start point */
    y1: AxisValueTypeOf<AxisTypeOf<Y>>;
    /** the {@link AxisValue} containing the x value of the line end point */
    x2: AxisValueTypeOf<AxisTypeOf<X>>;
    /** the {@link AxisValue} containing the y value of the line end point */
    y2: AxisValueTypeOf<AxisTypeOf<Y>>;
    /** the stroke style for the {@link RowAnnotationDefinition} */
    stroke_type: 'solid' | 'dashed';
    /** the number containing the stroke thickness (in pixels) */
    stroke_thickness: number | null;
    /** the stroke color as a {@link ColorValue} */
    stroke: ColorValue | null;
} : T extends 'circle' ? {
    /** the {@link AnnotationType} */
    type: T;
    /** the {@link AnnotationKind} */
    kind: K;
    /** the {@link AxisValue} containing the x value of the centre */
    cx: AxisValueTypeOf<AxisTypeOf<X>>;
    /** the {@link AxisValue} containing the y value of the centre */
    cy: AxisValueTypeOf<AxisTypeOf<Y>>;
    /** the number containing the radius (in pixels) */
    radius: number;
    /** the background color as a {@link ColorValue} */
    background: Color | null;
    /** the number containing the background opacity (normalised in the UI) */
    background_opacity: number | null;
    /** the stroke style for the {@link RowAnnotationDefinition} */
    stroke_type: 'solid' | 'dashed';
    /** the number containing the stroke thickness (in pixels) */
    stroke_thickness: number | null;
    /** the stroke color as a {@link ColorValue} */
    stroke: ColorValue | null;
} : never) : never;
/**
 * Create a {@link RowSquareAnnotation} to display within a {@link Visual}, mapped from a {@link RowView}.
 *
 * @param definition: the desired {@link RowAnnotationDefinition}.
 * @return a valid {@link RowSquareAnnotation}
 *
 * @category Annotation
 *
 * @example
 * ```typescript
 * import row_view from './gen/row.view;
 * // create a square filling the visible y range, between two points [{ x: Start, y: undefined }, { x: End, y: undefined }]
 * const square = RowSquareAnnotation({
 *     view: group_view,
 *     x1: row_view.fields.Start,
 *     x2: row_view.fields.End,
 *     background: ColorValue('#555555'),
 *     stroke: ColorValue(fields.fields.Color),
 * })
 * ```
 */
export declare function RowSquareAnnotation<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType>(config: Omit<RowAnnotationDefinition<X, Y, 'square', 'mapping'>, 'type' | 'kind'>): RowAnnotationDefinition<X, Y, 'square'>;
/** @internal */
export declare function toRowSquareAnnotation<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType>(def: RowAnnotationDefinition<X, Y, 'square', 'mapping'>): Annotation<X, Y, 'square', 'mapping'>;
/**
 * Create a {@link RowLineAnnotation} to display within a {@link Visual}, mapped from a {@link RowView}.
 *
 * @param definition: the desired {@link RowAnnotationDefinition}.
 * @return a valid {@link RowLineAnnotation}
 *
 * @category Annotation
 *
 * @example
 * ```typescript
 * import row_view from './gen/row.view;
 * // create a line between two points [{ x: Start, y: MinValue}, { x: End, y:MaxValue }]
 * const line = RowLineAnnotation({
 *     view: row_view,
 *     x1: row_view.fields.Start,
 *     y1: row_view.fields.MinValue,
 *     x2: row_view.fields.End,
 *     y2: row_view.fields.MaxValue,
 *     background: ColorValue('#555555'),
 *     stroke: ColorValue(row_view.fields.Color),
 * })
 * ```
 */
export declare function RowLineAnnotation<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType>(config: Omit<RowAnnotationDefinition<X, Y, 'line', 'mapping'>, 'type' | 'kind'>): RowAnnotationDefinition<X, Y, 'line'>;
/** @internal */
export declare function toRowLineAnnotation<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType>(def: RowAnnotationDefinition<X, Y, 'line', 'mapping'>): Annotation<X, Y, 'line', 'mapping'>;
/**
 * Create a {@link RowCircleAnnotation} to display within a {@link Visual}, mapped from a {@link RowView}.
 *
 * @param definition: the desired {@link RowAnnotationDefinition}.
 * @return a valid {@link RowCircleAnnotation}
 *
 * @category Annotation
 *
 * @example
 * ```typescript
 * import row_view from './gen/row.view;
 * // create a circle at a point [{ x: Start, y: Value }] with radius Value
 * const circle = RowCircleAnnotation({
 *     view: row_view,
 *     cx: row_view.fields.Start,
 *     cy: row_view.fields.Value,
 *     radius: row_view.fields.Value,
 *     background: ColorValue('#555555'),
 *     stroke: ColorValue(group_view.groups.Color),
 * })
 * ```
 */
export declare function RowCircleAnnotation<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType>(config: Omit<RowAnnotationDefinition<X, Y, 'circle', 'mapping'>, 'type' | 'kind'>): RowAnnotationDefinition<X, Y, 'circle'>;
/** @internal */
export declare function toRowCircleAnnotation<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType>(def: RowAnnotationDefinition<X, Y, 'circle', 'mapping'>): Annotation<X, Y, 'circle', 'mapping'>;
/** @internal */
export declare function toRowAnnotation<X extends PrimitiveType, Y extends PrimitiveType, T extends AnnotationType = AnnotationType>(def: RowAnnotationDefinition<X, Y, T>): Annotation<X, Y, T>;
