// Â© Copyright 2018- 2022 - Elara AI Pty Ltd ACN 627 124 903
//
// Licensed under the EDK Licence version LICENSE-1.04.
//
// You may only use this file in accordance with the terms and conditions contained in EDK
// Licence - Version LICENSE-1.04. The full version of the EDK Licence is available at:
// https://elaraai.github.io/docs/license

import { ArrayType, DictType, EastType, NumericType, PrimitiveType, StructType } from '../east/types';
import { Clear, ClearDefinition, Edit, EditDefinition, Select, SelectDefinition, Tooltip, TooltipDefinition } from './Interaction';
import { Color, ColorValueDefinition, GroupColorDefinition, KeyColor, RowColorDefinition, RowKeyColorDefinition } from './Color';
import { EastFunction, Variable } from '../east/functions';
import { View, ViewAggregation, ViewGroup } from '../analytics';
/**
 * Defines the a continous axis type
 *
 * @category Series
 */
export declare type ContinuousType = "float" | "integer" | "datetime";
/**
 * Defines an ordinal axis type
 *
 * @category Series
 */
export declare type OrdinalType = "string";
/**
 * Defines a type of probability distribution
 *
 * @category Series
 */
export declare type DistributionType = "Histogram" | "TriangularKDE" | "GaussianKDE";
/**
 * Defines a probability distribution normalization method
 *
 * @category Series
 */
export declare type NormalizationType = "ProbabilityCumulative" | "ProbabilityDensity" | "ProbabilitySum" | "SampleDensity" | "SampleSum" | "PercentCumulative" | "PercentDensity" | "PercentSum";
/**
 * Defines the options for a {@link DistributionType}.
 *
 * @category Series
 */
export declare type DistributionOptions = {
    /** the {@link DistributionType} to apply */
    distribution: DistributionType;
    /** the {@link NormalizationType} to apply in the distribution */
    normalization: NormalizationType;
    /** the minimum value to consider in the distribution */
    minimum: number | null;
    /** the numbe rof bins in the histogram */
    n_bins: number | null;
    /** the histogram step size to apply */
    step: number | null;
};
/**
 * Defines the {@link CurveType}'s for lines.
 *
 * @category Series
 */
export declare type CurveType = 'curve_linear' | 'curve_basis' | 'curve_basis_closed' | 'curve_monotone_x' | 'curve_monotone_y' | 'curve_natural' | 'curve_step' | 'curve_step_after' | 'curve_step_before';
/** @internal */
export declare type SeriesMode = 'raw' | 'flat' | 'stacked';
/** @internal */
export declare type SeriesKey = 'none' | 'value' | 'aggregation';
/** Aggregate series, require groups and agrgegations to defined in views  */
/** @internal */
export declare type GroupDefaultSeries = {
    type: 'default';
    kind: 'group';
    view: string;
    series_mode: 'raw';
    color: Color | null;
    tooltip: Tooltip | null;
    dash: Variable<ArrayType<'float'>> | null;
    opacity: Variable<'float'> | null;
};
/** @internal */
export declare type GroupHTMLSeries = {
    type: 'group_html';
    kind: 'group';
    series_mode: 'raw';
    view: string;
    value: EastFunction<'string'>;
    color: Color | null;
    tooltip: null;
};
/** @internal */
export declare function isGroupHTMLSeries(config: Series): config is GroupHTMLSeries;
/** @internal */
export declare function asGroupHTMLSeries(config: Series): GroupHTMLSeries;
/**
 * Defines a {@link GroupHTMLSeriesDefinition} to display string {@link View} content as a html area.
 *
 * @category Series
 */
export declare type GroupHTMLSeriesDefinition = {
    /** the {@link SeriesDefinition} type */
    type: 'group_html';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** the {@link View} to display */
    view: View;
    /** the {@link EastFunction} containing the html to display */
    value: EastFunction<'string'>;
    /** the foreground {@link Color} */
    color?: ColorValueDefinition;
    /** @internal */
    tooltip?: null;
};
/**
 * Create a {@link GroupHTMLSeries} to display string {@link View} content as a html area.
 *
 * @param definition: the desired {@link GroupHTMLSeriesDefinition}
 * @returns a valid {@link GroupHTMLSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import total_view from "./gen/total.view"
 *
 *  // create an inline text element
 *  const series =  GroupHTMLSeries({
 *      view: total_view,
 *      value: StringJoin`<p>
 *          Did you know that <b>{total_view.fields.TotalQty}</b>
 *          were sold resulting in total revenue of
 *          <b>{PrintTruncatedCurrency(total_view.fields.TotalAmount)}</b>?
 *      </p>`
 *  })
 * ```
 */
export declare function GroupHTMLSeries(config: Omit<GroupHTMLSeriesDefinition, 'kind' | 'type'>): GroupHTMLSeriesDefinition;
/** @internal */
export declare type GroupFlowInput = {
    prev: Variable<'string'> | null;
    curr: Variable<'string'>;
    next: Variable<'string'> | null;
};
/**
 * Defines a {@link GroupFlowInputDefinition} to display a {@link GroupFlowSeries} value.
 *
 * @category Series
 */
export declare type GroupFlowInputDefinition = {
    /** the {@link ViewAggregation} for the previous node */
    prev: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the current node */
    curr: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the next node */
    next: ViewAggregation<'string'> | ViewGroup<'string'>;
} | {
    /** @internal */
    prev?: null;
    /** the {@link ViewAggregation} for the current node */
    curr: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the next node */
    next: ViewAggregation<'string'> | ViewGroup<'string'>;
} | {
    /** the {@link ViewAggregation} for the previous node */
    prev: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the current node */
    curr: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** @internal */
    next?: null;
};
/**
 * Create a {@link GroupFlowInputDefinition} to display a {@link GroupFlowSeries} value.
 *
 * @category Series
 */
export declare function GroupFlowInput(config: GroupFlowInputDefinition): GroupFlowInputDefinition;
/** @internal */
export declare type GroupFlowSeries<Z extends NumericType = NumericType> = {
    type: 'group_flow';
    kind: 'group';
    series_mode: 'raw';
    view: string;
    x: GroupFlowInput;
    y: GroupFlowInput;
    value: Variable<Z>;
    opacity: Variable<'float'> | null;
    color: Color | null;
    tooltip: Tooltip | null;
};
/** @internal */
export declare function isGroupFlowSeries(config: Series): config is GroupFlowSeries;
/** @internal */
export declare function asGroupFlowSeries(config: Series): GroupFlowSeries;
/**
 * Defines a {@link GroupFlowSeriesDefinition} to display a network diagram (Sankey) from {@link View} data.
 *
 * @category Series
 */
export declare type GroupFlowSeriesDefinition<Z extends NumericType = NumericType> = {
    /** the {@link SeriesDefinition} type */
    type: 'group_flow';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** the {@link View} to display */
    view: View;
    /** the {@link GroupFlowInputDefinition} for the x value */
    x: GroupFlowInputDefinition;
    /** the {@link GroupFlowInputDefinition} for the y value */
    y: GroupFlowInputDefinition;
    /** the {@link ViewAggregation} for the flow value */
    value: ViewAggregation<Z>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
};
/**
 * Create a {@link GroupFlowSeries} to display a network diagram (Sankey) from {@link View} data.
 *
 * @param definition: the desired {@link GroupFlowSeriesDefinition}
 * @returns a valid {@link GroupFlowSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create snakey chart
 *  const series =  GroupFlowSeries({
 *      view: group_view,
 *      x: GroupFlowInput({
 *          prev: group_view.aggregations.PreviousCategory,
 *          curr: group_view.aggregations.Category
 *      }),
 *      y: GroupFlowInput({
 *          prev: group_view.aggregations.PreviousProduct,
 *          curr: group_view.aggregations.Product
 *      }),
 *      value: group_view.aggregations.Total,
 *      color: GroupLinearColor(group_view.aggregations.Total)
 *  })
 * ```
 */
export declare function GroupFlowSeries<Z extends NumericType = NumericType>(config: Omit<GroupFlowSeriesDefinition<Z>, 'kind' | 'type'>): GroupFlowSeriesDefinition<Z>;
/** @internal */
export declare type GroupHeatMapSeries<Z extends ContinuousType = ContinuousType> = {
    type: 'group_heatmap';
    kind: 'group';
    series_mode: 'raw';
    view: string;
    x: Variable<'string'>;
    y: Variable<'string'>;
    value: Variable<Z>;
    color: Color | null;
    opacity: Variable<'float'> | null;
    tooltip: Tooltip | null;
};
/** @internal */
export declare function isGroupHeatMapSeries(config: Series): config is GroupHeatMapSeries;
/** @internal */
export declare function asGroupHeatMapSeries(config: Series): GroupHeatMapSeries;
/**
 * Defines a {@link GroupHeatMapSeriesDefinition} to display the magnitude of a variable as color in two dimensions from {@link View} data.
 *
 * @category Series
 */
export declare type GroupHeatMapSeriesDefinition<Z extends ContinuousType = ContinuousType> = {
    /** the {@link SeriesDefinition} type */
    type: 'group_heatmap';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** the {@link View} to display */
    view: View;
    /** the {@link ViewAggregation} for the x axis */
    x: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the y axis */
    y: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the heat value */
    value: ViewAggregation<Z>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
};
/**
 * Create a {@link GroupHeatMapSeries} to display the magnitude of a variable as color in two dimensions from {@link View} data.
 *
 * @param definition: the desired {@link GroupHeatMapSeriesDefinition}
 * @returns a valid {@link GroupHeatMapSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create a heatmap visual
 *  const series =  GroupHeatMapSeries({
 *      view: group_view,
 *      x: group_view.aggregations.Product,
 *      y: group_view.aggregations.Category,
 *      value: group_view.aggregations.Total,
 *      color: GroupLinearColor(group_view.aggregations.Total)
 *  })
 * ```
 */
export declare function GroupHeatMapSeries<Z extends ContinuousType = ContinuousType>(config: Omit<GroupHeatMapSeriesDefinition<Z>, 'kind' | 'type'>): GroupHeatMapSeriesDefinition<Z>;
/** @internal */
export declare type GroupPieSeries<Z extends NumericType = NumericType> = {
    type: 'group_pie';
    kind: 'group';
    series_mode: 'raw';
    view: string;
    x: Variable<'string'>;
    value: Variable<Z>;
    color: Color | null;
    opacity: Variable<'float'> | null;
    tooltip: Tooltip | null;
};
/** @internal */
export declare function isGroupPieSeries(config: Series): config is GroupPieSeries;
/** @internal */
export declare function asGroupPieSeries(config: Series): GroupPieSeries;
/**
 * Defines a {@link GroupPieSeriesDefinition} to display a pie chart, where the arc length of each slice, is proportional to the quantity it represents from {@link View} data.
 *
 * @category Series
 */
export declare type GroupPieSeriesDefinition<Z extends NumericType = NumericType> = {
    /** the {@link SeriesDefinition} type */
    type: 'group_pie';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** the {@link View} to display */
    view: View;
    /** the {@link ViewAggregation} for the category axis */
    x: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the size value */
    value: ViewAggregation<Z>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
};
/**
 * Create a {@link GroupPieSeries} to display a pie chart, where the arc length of each slice, is proportional to the quantity it represents from {@link View} data.
 *
 * @param definition: the desired {@link GroupPieSeriesDefinition}
 * @returns a valid {@link GroupPieSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create a pie chart
 *  const series = GroupPieSeries({
 *      view: group_view,
 *      x: group_view.aggregations.Product,
 *      value: group_view.aggregations.Total,
 *      color: GroupOrdinalColor(group_view.aggregations.Product),
 *  })
 * ```
 */
export declare function GroupPieSeries<Z extends NumericType = NumericType>(config: Omit<GroupPieSeriesDefinition<Z>, 'kind' | 'type'>): GroupPieSeriesDefinition<Z>;
/** @internal */
export declare type GroupBarSeries<X extends NumericType = NumericType> = {
    type: 'group_bar';
    kind: 'group';
    series_mode: 'raw' | 'stacked';
    view: string;
    x: Variable<X>;
    y: Variable<'string'>;
    stack: Variable<'string'> | null;
    color: Color | null;
    opacity: Variable<'float'> | null;
    tooltip: Tooltip | null;
};
/** @internal */
export declare function isGroupBarSeries(config: Series): config is GroupBarSeries;
/** @internal */
export declare function asGroupBarSeries(config: Series): GroupBarSeries;
/**
 * Defines a {@link GroupBarStackedSeriesDefinition} to display a stacked bar chart, presenting categorical data with rectangular bars with lengths proportional to the values that they represent from {@link View} data.
 *
 * @category Series
 */
export declare type GroupBarStackedSeriesDefinition<X extends NumericType = NumericType> = {
    /** the {@link SeriesDefinition} type */
    type: 'group_bar';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** @internal */
    series_mode: 'stacked';
    /** the {@link View} to display */
    view: View;
    /** the {@link ViewAggregation} for the x value */
    x: ViewAggregation<X> | ViewGroup<X>;
    /** the {@link ViewAggregation} for the y value */
    y: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the stack key */
    stack: ViewAggregation<'string'>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
};
/**
 * Create a {@link GroupBarStackedSeries} to display a stacked bar chart, presenting categorical data with rectangular bars with lengths proportional to the values that they represent from {@link View} data.
 *
 * @param definition: the desired {@link GroupBarStackedSeriesDefinition}
 * @returns a valid {@link GroupBarStackedSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create a bar chart
 *  const series = GroupBarStackedSeries({
 *      view: group_view,
 *      x: group_view.aggregations.Total,
 *      y: group_view.aggregations.Product,
 *      key: group_view.aggregations.Category,
 *      color: GroupOrdinalColor(group_view.aggregations.Category),
 *  })
 * ```
 */
export declare function GroupBarStackedSeries<X extends NumericType = NumericType>(config: Omit<GroupBarStackedSeriesDefinition<X>, 'kind' | 'type' | 'series_mode'>): GroupBarStackedSeriesDefinition<X>;
/**
 * Defines a {@link GroupBarValueSeriesDefinition} to display a range chart, presenting categorical data with rectangular bars with widths and offsets proportional to the values that they represent from {@link View} data.
 *
 * @category Series
 */
export declare type GroupBarValueSeriesDefinition<X extends NumericType = NumericType> = {
    /** the {@link SeriesDefinition} type */
    type: 'group_bar';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** @internal */
    series_mode: 'raw';
    /** the {@link View} to display */
    view: View;
    /** the {@link ViewAggregation} for the x value */
    x: ViewAggregation<X> | ViewGroup<X>;
    /** the {@link ViewAggregation} for the y value */
    y: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
};
/**
 * Create a {@link GroupBarVisual} to display a bar chart, presenting categorical data with rectangular bars with lengths proportional to the values that they represent from {@link View} data.
 *
 * @param definition: the desired {@link GroupBarVisualDefinition}
 * @returns a valid {@link GroupBarVisual}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create a bar chart
 *  const series = GroupBarValueSeries({
 *      view: group_view,
 *      x: group_view.aggregations.Total,
 *      y: group_view.aggregations.Product,
 *      color: GroupOrdinalColor(group_view.aggregations.Category),
 *  })
 * ```
 */
export declare function GroupBarValueSeries<X extends NumericType = NumericType>(config: Omit<GroupBarValueSeriesDefinition<X>, 'kind' | 'type' | 'series_mode'>): GroupBarValueSeriesDefinition<X>;
/**
 * Defines a {@link GroupBarSeriesDefinition} to display a range chart, presenting categorical data with rectangular bars with widths and offsets proportional to the values that they represent from {@link View} data.
 *
 * @category Series
 */
export declare type GroupBarSeriesDefinition<X extends NumericType = NumericType> = GroupBarValueSeriesDefinition<X> | GroupBarStackedSeriesDefinition<X>;
/** @internal */
export declare type GroupRangeSeries<X extends NumericType = NumericType> = {
    type: 'group_range';
    kind: 'group';
    series_mode: 'raw';
    view: string;
    x1: Variable<X>;
    x_mid: Variable<X> | null;
    x2: Variable<X>;
    x_label: string | null;
    y: Variable<'string'>;
    label: Variable<'string'> | null;
    opacity: Variable<'float'> | null;
    color: Color | null;
    tooltip: Tooltip | null;
};
/** @internal */
export declare function isGroupRangeSeries(config: Series): config is GroupRangeSeries;
/** @internal */
export declare function asGroupRangeSeries(config: Series): GroupRangeSeries;
/**
 * Defines a {@link GroupRangeSeriesDefinition} to display a range chart, presenting categorical data with rectangular bars with widths and offsets proportional to the values that they represent from {@link View} data.
 *
 * @category Series
 */
export declare type GroupRangeSeriesDefinition<X extends NumericType = NumericType> = {
    /** the {@link SeriesDefinition} type */
    type: 'group_range';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** @internal */
    series_mode: 'raw';
    /** the {@link View} to display */
    view: View;
    /** the {@link ViewAggregation} for the first x value */
    x1: ViewAggregation<X> | ViewGroup<X>;
    /** the {@link ViewAggregation} for the middle x value */
    x_mid?: ViewAggregation<X> | ViewGroup<X>;
    /** the {@link ViewAggregation} for the end x value */
    x2: ViewAggregation<X> | ViewGroup<X>;
    /** the label for the x axis */
    x_label?: string;
    /** the {@link ViewAggregation} for the y value */
    y: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the label for each bar */
    label?: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
};
/**
 * Create a {@link GroupRangeSeries} to display a range chart, presenting categorical data with rectangular bars with widths and offsets proportional to the values that they represent from {@link View} data.
 *
 * @param definition: the desired {@link GroupRangeSeriesDefinition}
 * @returns a valid {@link GroupRangeSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create range chart
 *  const series = GroupRangeSeries({
 *      view: group_view,
 *      x1: group_view.aggregations.Min,
 *      x2: group_view.aggregations.Max,
 *      x_mid: group_view.aggregations.Avg,
 *      y: group_view.aggregations.Category,
 *      color: GroupLinearColor(group_view.aggregations.Total),
 *  })
 * ```
 */
export declare function GroupRangeSeries<X extends NumericType = NumericType>(config: Omit<GroupRangeSeriesDefinition<X>, 'kind' | 'type' | 'series_mode'>): GroupRangeSeriesDefinition<X>;
/** @internal */
export declare type GroupColumnSeries<Y extends NumericType = NumericType> = {
    type: 'group_column';
    kind: 'group';
    series_mode: 'raw' | 'stacked';
    view: string;
    x: Variable<'string'>;
    y: Variable<Y>;
    stack: Variable<'string'> | null;
    opacity: Variable<'float'> | null;
    color: Color | null;
    tooltip: Tooltip | null;
};
/** @internal */
export declare function isGroupColumnSeries(config: Series): config is GroupColumnSeries;
/** @internal */
export declare function asGroupColumnSeries(config: Series): GroupColumnSeries;
/**
 * Defines a {@link GroupColumnStackedSeriesDefinition} to display a stacked column chart, presenting categorical data with rectangular bars with heights proportional to the values that they represent from {@link View} data.
 *
 * @category Series
 */
export declare type GroupColumnStackedSeriesDefinition<Y extends NumericType = NumericType> = {
    /** the {@link SeriesDefinition} type */
    type: 'group_column';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** @internal */
    series_mode: 'stacked';
    /** the {@link View} to display */
    view: View;
    /** the {@link ViewAggregation} for the x value */
    x: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the y value */
    y: ViewAggregation<Y> | ViewGroup<Y>;
    /** the {@link ViewAggregation} for the stack key */
    stack: ViewAggregation<'string'>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
};
/**
 * Create a {@link GroupColumnStackedSeries} to display a column chart, presenting categorical data with rectangular bars with heights proportional to the values that they represent from {@link View} data.
 *
 * @param definition: the desired {@link GroupColumnStackedSeriesDefinition}
 * @returns a valid {@link GroupColumnStackedSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create column chart
 *  const series = GroupColumnStackedSeries({
 *      view: group_view,
 *      x: group_view.aggregations.Category,
 *      y: group_view.aggregations.Total,
 *      key: group_view.aggregations.Product,
 *      color: GroupOrdinalColor(group_view.aggregations.Product),
 *  })
 * ```
 */
export declare function GroupColumnStackedSeries<Y extends NumericType = NumericType>(config: Omit<GroupColumnStackedSeriesDefinition<Y>, 'kind' | 'type' | 'series_mode'>): GroupColumnStackedSeriesDefinition<Y>;
/**
 * Defines a {@link GroupColumnValueSeriesDefinition} to display a column chart, presenting categorical data with rectangular bars with heights proportional to the values that they represent from {@link View} data.
 *
 * @category Series
 */
export declare type GroupColumnValueSeriesDefinition<Y extends NumericType = NumericType> = {
    /** the {@link SeriesDefinition} type */
    type: 'group_column';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** @internal */
    series_mode: 'raw';
    /** the {@link View} to display */
    view: View;
    /** the {@link ViewAggregation} for the x value */
    x: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the y value */
    y: ViewAggregation<Y> | ViewGroup<Y>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
};
/**
 * Create a {@link GroupColumnValueSeries} to display a column chart, presenting categorical data with rectangular bars with heights proportional to the values that they represent from {@link View} data.
 *
 * @param definition: the desired {@link GroupColumnValueSeriesDefinition}
 * @returns a valid {@link GroupColumnValueSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create column chart
 *  const series = GroupColumnValueSeries({
 *      view: group_view,
 *      x: group_view.aggregations.Category,
 *      y: group_view.aggregations.Total,
 *      color: GroupOrdinalColor(group_view.aggregations.Product),
 *  })
 * ```
 */
export declare function GroupColumnValueSeries<Y extends NumericType = NumericType>(config: Omit<GroupColumnValueSeriesDefinition<Y>, 'kind' | 'type' | 'series_mode'>): GroupColumnValueSeriesDefinition<Y>;
/**
 * Defines a {@link GroupColumnSeriesDefinition} to display a column chart, presenting categorical data with rectangular bars with heights proportional to the values that they represent from {@link View} data.
 *
 * @category Series
 */
export declare type GroupColumnSeriesDefinition<Y extends NumericType = NumericType> = GroupColumnValueSeriesDefinition<Y> | GroupColumnStackedSeriesDefinition<Y>;
/** @internal */
export declare type GroupAreaSeries<Y extends NumericType = NumericType> = {
    type: 'group_area';
    kind: 'group';
    series_mode: 'raw' | 'stacked';
    view: string;
    x: Variable<'string'>;
    y: Variable<Y>;
    stack: Variable<'string'> | null;
    opacity: Variable<'float'> | null;
    color: Color | null;
    tooltip: Tooltip | null;
    curve: CurveType;
    point: boolean;
};
/** @internal */
export declare function isGroupAreaSeries(config: Series): config is GroupAreaSeries;
/** @internal */
export declare function asGroupAreaSeries(config: Series): GroupAreaSeries;
/**
 * Defines a {@link GroupAreaSeriesDefinition} to display an area chart, presenting data points connected by shaded line segments from {@link View} data.
 *
 * @category Series
 */
export declare type GroupAreaSeriesDefinition<Y extends NumericType = NumericType> = GroupAreaValueSeriesDefinition<Y> | GroupAreaStackedSeriesDefinition<Y>;
/**
 * Defines a {@link GroupAreaStackedSeriesDefinition} to display a stacked area chart, presenting data points connected by shaded line segments from {@link View} data.
 *
 * @category Series
 */
export declare type GroupAreaStackedSeriesDefinition<Y extends NumericType = NumericType> = {
    /** the {@link SeriesDefinition} type */
    type: 'group_area';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** @internal */
    series_mode: 'stacked';
    /** the {@link View} to display */
    view: View;
    /** the {@link ViewAggregation} for the x value */
    x: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the y value */
    y: ViewAggregation<Y> | ViewGroup<Y>;
    /** the {@link CurveType} of the line */
    curve?: CurveType;
    /** the {@link ViewAggregation} for the stack key value */
    stack: ViewAggregation<'string'>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** set to true to show the points on the line */
    point?: boolean;
};
/**
 * Create a {@link GroupAreaStackedSeries} to display an area chart, presenting data points connected by shaded line segments from {@link View} data.
 *
 * @param definition: the desired {@link GroupAreaStackedSeriesDefinition}
 * @returns a valid {@link GroupAreaStackedSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create an area visual
 *  const = series = GroupAreaStackedSeries({
 *      view: group_view,
 *      x: group_view.aggregations.Category,
 *      y: group_view.aggregations.Total,
 *      key: group_view.aggregations.Product
 *      color: ColorValue()
 *  })
 * ```
 */
export declare function GroupAreaStackedSeries<Y extends NumericType = NumericType>(config: Omit<GroupAreaStackedSeriesDefinition<Y>, 'kind' | 'type' | 'series_mode'>): GroupAreaStackedSeriesDefinition<Y>;
/**
 * Defines a {@link GroupAreaStackedSeriesDefinition} to display an area chart, presenting data points connected by shaded line segments from {@link View} data.
 *
 * @category Series
 */
export declare type GroupAreaValueSeriesDefinition<Y extends NumericType = NumericType> = {
    /** the {@link SeriesDefinition} type */
    type: 'group_area';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** @internal */
    series_mode: 'raw';
    /** the {@link View} to display */
    view: View;
    /** the {@link ViewAggregation} for the x value */
    x: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the  value */
    y: ViewAggregation<Y> | ViewGroup<Y>;
    /** the {@link CurveType} of the line */
    curve?: CurveType;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** set to true to show the points on the line */
    point?: boolean;
};
/**
 * Create a {@link GroupAreaValueSeries} to display an area chart, presenting data points connected by shaded line segments from {@link View} data.
 *
 * @param definition: the desired {@link GroupAreaValueSeriesDefinition}
 * @returns a valid {@link GroupAreaValueSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create an area visual
 *  const = series = GroupAreaValueSeries({
 *      view: group_view,
 *      x: group_view.aggregations.Category,
 *      y: group_view.aggregations.Total,
 *      color: ColorValue()
 *  })
 * ```
 */
export declare function GroupAreaValueSeries<Y extends NumericType = NumericType>(config: Omit<GroupAreaValueSeriesDefinition<Y>, 'kind' | 'type' | 'series_mode'>): GroupAreaValueSeriesDefinition<Y>;
/** @internal */
export declare type GroupRidgelineSeries<Z extends NumericType = NumericType> = {
    type: 'group_ridgeline';
    kind: 'group';
    series_mode: 'raw';
    view: string;
    x: Variable<'string'>;
    y: Variable<'string'>;
    z: Variable<Z>;
    overlap: number;
    opacity: Variable<'float'> | null;
    color: Color | null;
    tooltip: Tooltip | null;
    curve: CurveType;
    point: boolean;
};
/** @internal */
export declare function isGroupRidgelineSeries(config: Series): config is GroupRidgelineSeries;
/** @internal */
export declare function asGroupRidgelineSeries(config: Series): GroupRidgelineSeries;
/**
 * Defines a {@link GroupRidgelineSeriesDefinition} to display a ridge line chart, presenting stacked series of data points connected by shaded line segments from {@link View} data.
 *
 * @category Series
 */
export declare type GroupRidgelineSeriesDefinition<Z extends NumericType = NumericType> = {
    /** the {@link SeriesDefinition} type */
    type: 'group_ridgeline';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** @internal */
    series_mode: 'raw';
    /** the {@link View} to display */
    view: View;
    /** the {@link ViewAggregation} for the x value */
    x: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the y value */
    y: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the z value */
    z: ViewAggregation<Z> | ViewGroup<Z>;
    /** the {@link ViewAggregation} for the max z value */
    overlap?: number;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** the {@link CurveType} to display  */
    curve?: CurveType;
    /** set to true to show the points on the line */
    point?: boolean;
};
/**
 * Create a {@link GroupRidgelineSeries} to display a ridge line chart, presenting stacked series of data points connected by shaded line segments from {@link View} data.
 *
 * @param definition: the desired {@link GroupRidgelineSeriesDefinition}
 * @returns a valid {@link GroupRidgelineSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create ridgeline chart
 *  const series = GroupRidgelineSeries({
 *      view: group_view,
 *      x: group_view.aggregations.Product,
 *      y: group_view.aggregations.Category,
 *      z: group_view.aggregations.Total,
 *      color: GroupOrdinalColor(group_view.aggregations.Product),
 *  })
 * ```
 */
export declare function GroupRidgelineSeries<Z extends NumericType = NumericType>(config: Omit<GroupRidgelineSeriesDefinition<Z>, 'kind' | 'type' | 'series_mode'>): GroupRidgelineSeriesDefinition<Z>;
/** @internal */
export declare type GroupLineSeries<Y extends NumericType = NumericType> = {
    type: 'group_line';
    kind: 'group';
    series_mode: 'raw' | 'stacked';
    view: string;
    x: Variable<'string'>;
    y: Variable<Y>;
    stack: Variable<'string'> | null;
    opacity: Variable<'float'> | null;
    color: Color | null;
    tooltip: Tooltip | null;
    curve: CurveType;
    point: boolean;
};
/** @internal */
export declare function isGroupLineSeries(config: Series): config is GroupLineSeries;
/** @internal */
export declare function asGroupLineSeries(config: Series): GroupLineSeries;
/**
 * Defines a {@link GroupLineStackedSeriesDefinition} to display a stacked line chart, presenting data points connected by line segments from {@link View} data.
 *
 * @category Series
 */
export declare type GroupLineStackedSeriesDefinition<Y extends NumericType = NumericType> = {
    /** the {@link SeriesDefinition} type */
    type: 'group_line';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** @internal */
    series_mode: 'stacked';
    /** the {@link View} to display */
    view: View;
    /** the {@link ViewAggregation} for the z value */
    x: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the y value */
    y: ViewAggregation<Y> | ViewGroup<Y>;
    /** the {@link CurveType} of the line */
    curve?: CurveType;
    /** the {@link ViewAggregation} for the stack key value */
    stack: ViewAggregation<'string'>;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** set to true to show the points on the line */
    point?: boolean;
};
/**
 * Create a {@link GroupLineStackedSeries} to display a stacked line chart, presenting data points connected by line segments from {@link View} data.
 *
 * @param definition: the desired {@link GroupLineStackedSeriesDefinition}
 * @returns a valid {@link GroupLineStackedSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create line chart
 *  const series = GroupLineStackedSeries({
 *      view: group_view,
 *      x: group_view.aggregations.Category,
 *      y: group_view.aggregations.Total,
 *      key: group_view.aggregations.Product,
 *      color: ColorValue()
 *  })
 * ```
 */
export declare function GroupLineStackedSeries<Y extends NumericType = NumericType>(config: Omit<GroupLineStackedSeriesDefinition<Y>, 'kind' | 'type' | 'series_mode'>): GroupLineStackedSeriesDefinition<Y>;
/**
 * Defines a {@link GroupLineStackedSeriesDefinition} to display a line chart, presenting data points connected by line segments from {@link View} data.
 *
 * @category Series
 */
export declare type GroupLineValueSeriesDefinition<Y extends NumericType = NumericType> = {
    /** the {@link SeriesDefinition} type */
    type: 'group_line';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** @internal */
    series_mode: 'raw';
    /** the {@link View} to display */
    view: View;
    /** the {@link ViewAggregation} for the x value */
    x: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the y value */
    y: ViewAggregation<Y> | ViewGroup<Y>;
    /** the {@link CurveType} of the line */
    curve?: CurveType;
    /** the {@link ViewAggregation} for a nesting key value */
    stack?: ViewAggregation<'string'>;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** set to true to show the points on the line */
    point?: boolean;
};
/**
 * Create a {@link GroupLineValueSeries} to display a line chart, presenting data points connected by line segments from {@link View} data.
 *
 * @param definition: the desired {@link GroupLineValueSeriesDefinition}
 * @returns a valid {@link GroupLineValueSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create line chart
 *  const series = GroupLineValueSeries({
 *      view: group_view,
 *      x: group_view.aggregations.Product,
 *      y: group_view.aggregations.Total,
 *      color: ColorValue()
 *  })
 * ```
 */
export declare function GroupLineValueSeries<Y extends NumericType = NumericType>(config: Omit<GroupLineValueSeriesDefinition<Y>, 'kind' | 'type' | 'series_mode'>): GroupLineValueSeriesDefinition<Y>;
/**
 * Defines a {@link GroupLineSeriesDefinition} to display a line chart, presenting data points connected by line segments from {@link View} data.
 *
 * @category Series
 */
export declare type GroupLineSeriesDefinition<Y extends NumericType = NumericType> = GroupLineValueSeriesDefinition<Y> | GroupLineStackedSeriesDefinition<Y>;
/** @internal */
export declare type GroupCombinedSeries<Y extends NumericType = NumericType> = {
    type: 'group_combined';
    kind: 'group';
    series_mode: 'raw' | 'stacked';
    view: string;
    x: Variable<'string'>;
    line: GroupCombinedSeriesLine<Y>;
    column: GroupCombinedSeriesColumn<Y>;
    tooltip: null;
};
/** @internal */
export declare function isGroupCombinedSeries(config: Series): config is GroupCombinedSeries;
/** @internal */
export declare function asGroupCombinedSeries(config: Series): GroupCombinedSeries;
/** @internal */
export declare type GroupCombinedSeriesColumn<Y extends NumericType = NumericType> = {
    y: Variable<Y>;
    opacity: Variable<'float'> | null;
    color: Color | null;
    tooltip: Tooltip | null;
};
/**
 * Defines a {@link GroupCombinedSeriesColumnDefinition} to display a column on a {@link GroupCombinedSeries} chart.
 *
 * @category Series
 */
export declare type GroupCombinedSeriesColumnDefinition<Y extends NumericType = NumericType> = {
    /** the {@link ViewAggregation} for the y line value */
    y: ViewAggregation<Y> | ViewGroup<Y>;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
};
/**
 * Create a {@link GroupCombinedSeriesColumnDefinition} to display a column on a {@link GroupCombinedSeries} chart.
 *
 * @param definition: the desired {@link GroupCombinedSeriesColumnDefinition}
 * @returns a valid {@link GroupCombinedSeriesColumnDefinition}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create line chart
 *  const column = GroupCombinedSeriesColumn({
 *      y: group_view.aggregations.Ratio,
 *      color: ColorValue()
 *  })
 * ```
 */
export declare function GroupCombinedSeriesColumn<Y extends NumericType = NumericType>(config: GroupCombinedSeriesColumnDefinition<Y>): GroupCombinedSeriesColumnDefinition<Y>;
/** @internal */
export declare type GroupCombinedSeriesLine<Y extends NumericType = NumericType> = {
    y: Variable<Y>;
    opacity: Variable<'float'> | null;
    color: Color | null;
    tooltip: Tooltip | null;
    curve: CurveType;
    point: boolean;
};
/**
 * Defines a {@link GroupCombinedSeriesLineDefinition} to display a line on a {@link GroupCombinedSeries} chart.
 *
 * @category Series
 */
export declare type GroupCombinedSeriesLineDefinition<Y extends NumericType = NumericType> = {
    /** the {@link ViewAggregation} for the y line value */
    y: ViewAggregation<Y> | ViewGroup<Y>;
    /** the {@link CurveType} of the line */
    curve?: CurveType;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** set to true to show the points on the line */
    point?: boolean;
};
/**
 * Create a {@link GroupCombinedSeriesLineDefinition} to display a Line on a {@link GroupCombinedSeries} chart.
 *
 * @param definition: the desired {@link GroupCombinedSeriesLineDefinition}
 * @returns a valid {@link GroupCombinedSeriesLineDefinition}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create line chart
 *  const Line = GroupCombinedSeriesLine({
 *      y: group_view.aggregations.Ratio,
 *      color: ColorValue()
 *  })
 * ```
 */
export declare function GroupCombinedSeriesLine<Y extends NumericType = NumericType>(config: GroupCombinedSeriesLineDefinition<Y>): GroupCombinedSeriesLineDefinition<Y>;
/**
 * Defines a {@link GroupCombinedSeriesDefinition} to display a line chart, presenting data points connected by line segments from {@link View} data.
 *
 * @category Series
 */
export declare type GroupCombinedSeriesDefinition<Y extends NumericType = NumericType> = {
    /** the {@link SeriesDefinition} type */
    type: 'group_combined';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** @internal */
    series_mode: 'raw';
    /** the {@link View} to display */
    view: View;
    /** the {@link ViewAggregation} for the x value */
    x: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the y line value */
    line: GroupCombinedSeriesLineDefinition<Y>;
    /** the {@link ViewAggregation} for the y column value */
    column: GroupCombinedSeriesColumnDefinition<Y>;
};
/**
 * Create a {@link GroupCombinedValueSeries} to display a line chart, presenting data points connected by line segments from {@link View} data.
 *
 * @param definition: the desired {@link GroupCombinedValueSeriesDefinition}
 * @returns a valid {@link GroupCombinedValueSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create line chart
 *  const series = GroupCombinedValueSeries({
 *      view: group_view,
 *      x: group_view.aggregations.Product,
 *      line: GroupCombinedSeriesLine({
 *          y: group_view.aggregations.Ratio,
 *          color: ColorValue()
 *      }),
 *      column: GroupCombinedSeriesColumn({
 *          y: group_view.aggregations.Total,
 *          color: ColorValue()
 *      }),
 *  })
 * ```
 */
export declare function GroupCombinedSeries<Y extends NumericType = NumericType>(config: Omit<GroupCombinedSeriesDefinition<Y>, 'kind' | 'type' | 'series_mode'>): GroupCombinedSeriesDefinition<Y>;
/** @internal */
export declare type GroupScatterSeries<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType, Z extends NumericType = NumericType> = {
    type: 'group_scatter';
    kind: 'group';
    series_mode: 'raw';
    view: string;
    x: Variable<X>;
    y: Variable<Y>;
    size: Variable<Z>;
    opacity: Variable<'float'> | null;
    color: Color | null;
    tooltip: Tooltip | null;
};
/** @internal */
export declare function isGroupScatterSeries(config: Series): config is GroupScatterSeries;
/** @internal */
export declare function asGroupScatterSeries(config: Series): GroupScatterSeries;
/**
 * Defines a {@link GroupScatterSeriesDefinition} to display a scatter chart, presenting dots to represent values from {@link View} data.
 *
 * @category Series
 */
export declare type GroupScatterSeriesDefinition<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType, Z extends NumericType = NumericType> = {
    /** the {@link SeriesDefinition} type */
    type: 'group_scatter';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** the {@link View} to display */
    view: View;
    /** the {@link ViewAggregation} for the x value */
    x: ViewAggregation<X> | ViewGroup<X>;
    /** the {@link ViewAggregation} for the y value */
    y: ViewAggregation<Y> | ViewGroup<Y>;
    /** the {@link ViewAggregation} representing the size of the point */
    size: ViewAggregation<Z>;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
};
/**
 * Create a {@link GroupScatterSeries} to display a scatter chart, presenting dots to represent values from {@link View} data.
 *
 * @param definition: the desired {@link GroupScatterSeriesDefinition}
 * @returns a valid {@link GroupScatterSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create scatter chart
 *  const series = GroupScatterSeries({
 *      view: group_view,
 *      x: group_view.aggregations.Product,
 *      y: group_view.aggregations.Category,
 *      size: group_view.aggregations.Total,
 *      color: GroupOrdinalColor(group_view.aggregations.Area)
 *  }),
 * ```
 */
export declare function GroupScatterSeries<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType, Z extends NumericType = NumericType>(config: Omit<GroupScatterSeriesDefinition<X, Y, Z>, 'kind' | 'type'>): GroupScatterSeriesDefinition<X, Y, Z>;
/** @internal */
export declare type GroupTreeMapSeries<Z extends NumericType = NumericType> = {
    type: 'group_treemap';
    kind: 'group';
    series_mode: 'raw';
    view: string;
    x: Variable<'string'>;
    value: Variable<Z>;
    opacity: Variable<'float'> | null;
    color: Color | null;
    tooltip: Tooltip | null;
};
/** @internal */
export declare function isGroupTreeMapSeries(config: Series): config is GroupTreeMapSeries;
/** @internal */
export declare function asGroupTreeMapSeries(config: Series): GroupTreeMapSeries;
/**
 * Defines a {@link GroupTreeMapSeriesDefinition} to map a scatter chart, presenting relative value using rectangles from {@link View} data.
 *
 * @category Series
 */
export declare type GroupTreeMapSeriesDefinition<Z extends NumericType = NumericType> = {
    /** the {@link SeriesDefinition} type */
    type: 'group_treemap';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** the {@link View} to display */
    view: View;
    /** the {@link ViewAggregation} for the category value */
    x: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the size value */
    value: ViewAggregation<Z>;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
};
/**
 * Create a {@link GroupTreeMapSeries} to display a map chart, presenting relative value using rectangles from {@link View} data.
 *
 * @param definition: the desired {@link GroupTreeMapSeriesDefinition}
 * @returns a valid {@link GroupTreeMapSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create tree map visual
 *  const series = GroupTreeMapSeries({
 *      view: group_view,
 *      x: group_view.aggregations.Product,
 *      value: group_view.aggregations.Total,
 *      color: GroupLinearColor(group_view.aggregations.Total)
 *  })
 * ```
 */
export declare function GroupTreeMapSeries<Z extends NumericType = NumericType>(config: Omit<GroupTreeMapSeriesDefinition<Z>, 'kind' | 'type'>): GroupTreeMapSeriesDefinition<Z>;
/** @internal */
export declare type GroupTableColumn = {
    value: Variable<PrimitiveType>;
    color: Color | null;
    opacity: Variable<'float'> | null;
    background: Color | null;
    tooltip: Tooltip | null;
};
/**
 * Defines a {@link GroupTableColumnDefinition} to display a table column from {@link View} data.
 *
 * @category Series
 */
export declare type GroupTableColumnDefinition = {
    value: ViewAggregation<PrimitiveType>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the backgroun {@link GroupColorDefinition} */
    background?: GroupColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
};
/**
 * Defines a {@link GroupTableColumnDefinition} to display a table column from {@link View} data.
 *
 * @param definition: the desired {@link GroupTableColumnDefinition}
 * @returns a valid {@link GroupTableColumn}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create tree map visual
 *  const column = GroupTableColumn({
 *      value: group_view.aggregations.Total,
 *      color: GroupLinearColor(group_view.aggregations.Total),
 *      tooltip: Tooltip({
 *          title: Const("Values"),
 *          description: StringJoin`<p>The total is <b>${group_view.fields.Total}</b>.</p>`,
 *          values: {
 *              Avg: group_view.fields.Avg,
 *              Max: group_view.fields.Max,
 *              Min: group_view.fields.Min,
 *          }
 *      })
 *  })
 * ```
 */
export declare function GroupTableColumn(config: GroupTableColumnDefinition): GroupTableColumnDefinition;
/** @internal */
export declare type GroupTableSeries = {
    type: 'group_table';
    kind: 'group';
    series_mode: 'raw';
    view: string;
    columns: GroupTableColumn[];
    tooltip: null;
};
/** @internal */
export declare function isGroupTableSeries(config: Series): config is GroupTableSeries;
/** @internal */
export declare function asGroupTableSeries(config: Series): GroupTableSeries;
/**
 * Defines a {@link GroupTableSeriesDefinition} to display a table, presenting cells of values from {@link View} data.
 *
 * @category Series
 */
export declare type GroupTableSeriesDefinition = {
    /** the {@link SeriesDefinition} type */
    type: 'group_table';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** the {@link View} to display */
    view: View;
    /** the {@link GroupTableColumnDefinition} values */
    columns: GroupTableColumnDefinition[];
};
/**
 * Create a {@link GroupTableSeries} to display a table, presenting cells of values from {@link View} data.
 *
 * @param definition: the desired {@link GroupTableSeriesDefinition}
 * @returns a valid {@link GroupTableSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create table visual
 *  const series = GroupTableSeries({
 *      view: group_view,
 *      columns: [
 *          GroupTableColumn({
 *              value: group_view.aggregations.Product,
 *              color: GroupOrdinalColor(group_view.aggregations.Product),
 *          }),
 *          GroupTableColumn({
 *              value: group_view.aggregations.Total,
 *              background: GroupLinearColor(group_view.aggregations.Total),
 *              tooltip: Tooltip({
 *                  title: Const("Values"),
 *                  description: StringJoin`<p>The total is <b>${group_view.fields.Total}</b>.</p>`,
 *                  values: {
 *                      Avg: group_view.fields.Avg,
 *                      Max: group_view.fields.Max,
 *                      Min: group_view.fields.Min,
 *                  }
 *              })
 *          }),
 *      ],
 *  })
 * ```
 */
export declare function GroupTableSeries(config: Omit<GroupTableSeriesDefinition, 'kind' | 'type' | 'tooltip'>): GroupTableSeriesDefinition;
/** @internal */
export declare type GroupKPIValue = {
    value: Variable<PrimitiveType>;
    color: Color | null;
    opacity: Variable<'float'> | null;
    background: Color | null;
    tooltip: Tooltip | null;
};
/**
 * Defines a {@link GroupKPIValueDefinition} to display a KPI value from {@link View} data.
 *
 * @category Series
 */
export declare type GroupKPIValueDefinition = {
    value: ViewAggregation<PrimitiveType>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the backgroun {@link GroupColorDefinition} */
    background?: GroupColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
};
/**
 * Defines a {@link GroupKPIValueDefinition} to display a KPI value from {@link View} data.
 *
 * @param definition: the desired {@link GroupKPIValueDefinition}
 * @returns a valid {@link GroupKPIValue}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create tree map visual
 *  const column = GroupKPIValue({
 *      value: group_view.aggregations.Total,
 *      color: GroupLinearColor(group_view.aggregations.Total),
 *      tooltip: Tooltip({
 *          title: Const("Values"),
 *          description: StringJoin`<p>The total is <b>${group_view.fields.Total}</b>.</p>`,
 *          values: {
 *              Avg: group_view.fields.Avg,
 *              Max: group_view.fields.Max,
 *              Min: group_view.fields.Min,
 *          }
 *      })
 *  })
 * ```
 */
export declare function GroupKPIValue(config: GroupKPIValueDefinition): GroupKPIValueDefinition;
/** @internal */
export declare type GroupKPISeries = {
    type: 'group_kpi';
    kind: 'group';
    series_mode: 'raw';
    view: string;
    columns: GroupKPIValue[];
    tooltip: null;
};
/** @internal */
export declare function isGroupKPISeries(config: Series): config is GroupKPISeries;
/** @internal */
export declare function asGroupKPISeries(config: Series): GroupKPISeries;
/**
 * Defines a {@link GroupKPISeriesDefinition} to display a KPI panel, presenting KPI values from {@link View} data.
 *
 * @category Series
 */
export declare type GroupKPISeriesDefinition = {
    /** the {@link SeriesDefinition} type */
    type: 'group_kpi';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** the {@link View} to display */
    view: View;
    /** the {@link GroupKPIValueDefinition} values */
    columns: GroupKPIValueDefinition[];
};
/**
 * Create a {@link GroupKPISeries} to display a KPI panel, presenting KPI values from {@link View} data.
 *
 * @param definition: the desired {@link GroupKPISeriesDefinition}
 * @returns a valid {@link GroupKPISeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create table visual
 *  const series = GroupKPISeries({
 *      view: group_view,
 *      columns: [
 *          GroupKPIValue({
 *              value: group_view.aggregations.Product,
 *              color: GroupOrdinalColor(group_view.aggregations.Product),
 *          }),
 *          GroupKPIValue({
 *              value: group_view.aggregations.Total,
 *              background: GroupLinearColor(group_view.aggregations.Total),
 *              tooltip: Tooltip({
 *                  title: Const("Values"),
 *                  description: StringJoin`<p>The total is <b>${group_view.fields.Total}</b>.</p>`,
 *                  values: {
 *                      Avg: group_view.fields.Avg,
 *                      Max: group_view.fields.Max,
 *                      Min: group_view.fields.Min,
 *                  }
 *              })
 *          }),
 *      ],
 *  })
 * ```
 */
export declare function GroupKPISeries(config: Omit<GroupKPISeriesDefinition, 'kind' | 'type' | 'tooltip'>): GroupKPISeriesDefinition;
/** @internal */
export declare type GroupPivotSeries<Z extends PrimitiveType = PrimitiveType> = {
    type: 'group_pivot';
    kind: 'group';
    series_mode: 'raw';
    view: string;
    row_pivot: Variable<'string'>;
    col_pivot: Variable<'string'>;
    value: Variable<Z>;
    color: Color | null;
    opacity: Variable<'float'> | null;
    background: Color | null;
    tooltip: Tooltip | null;
};
/** @internal */
export declare function isGroupPivotSeries(config: Series): config is GroupPivotSeries;
/** @internal */
export declare function asGroupPivotSeries(config: Series): GroupPivotSeries;
/**
 * Defines a {@link GroupPivotSeriesDefinition} to display a pivot, presenting one or more discrete value categories from {@link View} data.
 *
 * @category Series
 */
export declare type GroupPivotSeriesDefinition<Z extends PrimitiveType = PrimitiveType> = {
    /** the {@link SeriesDefinition} type */
    type: 'group_pivot';
    /** the {@link SeriesDefinition} kind */
    kind: 'group';
    /** the {@link View} to display */
    view: View;
    /** the {@link ViewAggregation} for the row value */
    row_pivot: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the col value */
    col_pivot: ViewAggregation<'string'> | ViewGroup<'string'>;
    /** the {@link ViewAggregation} for the cell value */
    value: ViewAggregation<Z>;
    /** the foreground {@link GroupColorDefinition} */
    color?: GroupColorDefinition;
    /** the {@link ViewAggregation} for the foreground opacity */
    opacity?: ViewAggregation<'float'>;
    /** the background {@link GroupColorDefinition} */
    background?: GroupColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
};
/**
 * Create a {@link GroupPivotSeries} to display a pivot, presenting one or more discrete value categories from {@link View} data.
 *
 * @param definition: the desired {@link GroupPivotSeriesDefinition}
 * @returns a valid {@link GroupPivotSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import group_view from "./gen/group.view"
 *
 *  // create a pivot visual
 *  const series = GroupPivotSeries({
 *      view: group_view,
 *      col_pivot: group_view.aggregations.Product,
 *      row_pivot: group_view.aggregations.Category,
 *      value: group_view.aggregations.Total,
 *      color: GroupLinearColor(group_view.aggregations.Total)
 *  })
 * ```
 */
export declare function GroupPivotSeries<Z extends PrimitiveType = PrimitiveType>(config: Omit<GroupPivotSeriesDefinition<Z>, 'kind' | 'type'>): GroupPivotSeriesDefinition<Z>;
/** @internal */
export declare type GroupSeries = GroupKPISeries | GroupCombinedSeries | GroupHTMLSeries | GroupRidgelineSeries | GroupDefaultSeries | GroupScatterSeries | GroupLineSeries | GroupAreaSeries | GroupColumnSeries | GroupBarSeries | GroupTableSeries | GroupPieSeries | GroupTreeMapSeries | GroupFlowSeries | GroupHeatMapSeries | GroupPivotSeries | GroupRangeSeries;
/**
 * Defines a {@link GroupSeriesDefinition} to display data from {@link View} data.
 *
 * @category Series
 */
export declare type GroupSeriesDefinition = GroupKPISeriesDefinition | GroupCombinedSeriesDefinition | GroupHTMLSeriesDefinition | GroupRidgelineSeriesDefinition | GroupRangeSeriesDefinition | GroupColumnSeriesDefinition | GroupScatterSeriesDefinition | GroupLineSeriesDefinition | GroupAreaSeriesDefinition | GroupBarSeriesDefinition | GroupTableSeriesDefinition | GroupPieSeriesDefinition | GroupTreeMapSeriesDefinition | GroupFlowSeriesDefinition | GroupHeatMapSeriesDefinition | GroupPivotSeriesDefinition;
/**
 * Defines a {@link RowTableColumnType} within a {@link RowTableColumn}.
 *
 * @category Series
 */
export declare type RowTableColumnType = PrimitiveType | 'set' | ArrayType<'integer' | 'float'> | DictType<PrimitiveType> | StructType;
/** @internal */
export declare type RowTableColumn<T extends RowTableColumnType = RowTableColumnType> = T extends "string" ? {
    name: string;
    visible: boolean;
    value: Variable<'string'>;
    opacity: Variable<'float'> | null;
    color: Color | null;
    background: Color | null;
    tooltip: Tooltip | null;
    edit: Edit<'string'> | null;
    clear: Clear | null;
} : T extends "float" ? {
    name: string;
    visible: boolean;
    value: Variable<"float">;
    color: Color | null;
    opacity: Variable<'float'> | null;
    background: Color | null;
    tooltip: Tooltip | null;
    edit: Edit<"float"> | null;
    clear: Clear | null;
} : T extends "datetime" ? {
    name: string;
    visible: boolean;
    value: Variable<"datetime">;
    color: Color | null;
    opacity: Variable<'float'> | null;
    background: Color | null;
    tooltip: Tooltip | null;
    edit: Edit<"datetime"> | null;
    clear: Clear | null;
} : T extends "boolean" ? {
    name: string;
    visible: boolean;
    value: Variable<"boolean">;
    color: Color | null;
    opacity: Variable<'float'> | null;
    background: Color | null;
    tooltip: Tooltip | null;
    edit: Edit<"boolean"> | null;
    clear: Clear | null;
} : T extends "integer" ? {
    name: string;
    visible: boolean;
    value: Variable<"integer">;
    color: Color | null;
    opacity: Variable<'float'> | null;
    background: Color | null;
    tooltip: Tooltip | null;
    edit: Edit<"integer"> | null;
    clear: Clear | null;
} : T extends "set" ? {
    name: string;
    visible: boolean;
    value: Variable<"set">;
    color: Color | null;
    opacity: Variable<'float'> | null;
    background: Color | null;
    tooltip: Tooltip | null;
    edit: Edit<"set"> | null;
    clear: Clear | null;
} : {
    name: string;
    visible: boolean;
    value: Variable<T>;
    color: Color | null;
    opacity: Variable<'float'> | null;
    background: Color | null;
    tooltip: Tooltip | null;
    edit: null;
    clear: null;
};
/**
 * Defines a {@link RowTableColumnDefinition} to display {@link View} data within a {@link RowTableSeries}.
 *
 * @category Series
 */
export declare type RowTableColumnDefinition<T extends RowTableColumnType = RowTableColumnType> = T extends "string" ? {
    /** the column name */
    name?: string;
    /** true if the column should be visible */
    visible?: boolean;
    /** the {@link Variable} for the column value */
    value: Variable<"string">;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the background {@link RowColorDefinition} */
    background?: RowColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** the {@link EditDefinition} to edit the value */
    edit: EditDefinition<'string'> | null;
    /** the {@link ClearDefinition} to clear the value */
    clear: ClearDefinition | null;
} : T extends "float" ? {
    /** the column name */
    name?: string;
    /** true if the column should be visible */
    visible?: boolean;
    /** the {@link Variable} for the column value */
    value: Variable<"float">;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the background {@link RowColorDefinition} */
    background?: RowColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** the {@link EditDefinition} to edit the value */
    edit?: EditDefinition<"float">;
    /** the {@link ClearDefinition} to clear the value */
    clear: ClearDefinition;
} : T extends "datetime" ? {
    /** the column name */
    name?: string;
    /** true if the column should be visible */
    visible?: boolean;
    /** the {@link Variable} for the column value */
    value: Variable<"datetime">;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the background {@link RowColorDefinition} */
    background?: RowColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** the {@link EditDefinition} to edit the value */
    edit?: EditDefinition<"datetime">;
    /** the {@link ClearDefinition} to clear the value */
    clear: ClearDefinition;
} : T extends "boolean" ? {
    /** the column name */
    name?: string;
    /** true if the column should be visible */
    visible?: boolean;
    /** the {@link Variable} for the column value */
    value: Variable<"boolean">;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the background {@link RowColorDefinition} */
    background?: RowColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** the {@link EditDefinition} to edit the value */
    edit?: EditDefinition<"boolean">;
    /** the {@link ClearDefinition} to clear the value */
    clear: ClearDefinition;
} : T extends "integer" ? {
    /** the column name */
    name?: string;
    /** true if the column should be visible */
    visible?: boolean;
    /** the {@link Variable} for the column value */
    value: Variable<"integer">;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the background {@link RowColorDefinition} */
    background?: RowColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** the {@link EditDefinition} to edit the value */
    edit?: EditDefinition<"integer">;
    /** the {@link ClearDefinition} to clear the value */
    clear: ClearDefinition;
} : T extends "set" ? {
    /** the column name */
    name?: string;
    /** true if the column should be visible */
    visible?: boolean;
    /** the {@link Variable} for the column value */
    value: Variable<"set">;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the background {@link RowColorDefinition} */
    background?: RowColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** the {@link EditDefinition} to edit the value */
    edit?: EditDefinition<"set">;
    /** the {@link ClearDefinition} to clear the value */
    clear: ClearDefinition;
} : {
    /** the column name */
    name?: string;
    /** true if the column should be visible */
    visible?: boolean;
    /** the {@link Variable} for the column value */
    value: Variable<T>;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the background {@link RowColorDefinition} */
    background?: RowColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** @internal */
    edit?: undefined;
    /** @internal */
    clear?: undefined;
};
/**
 * Create a {@link RowTableColumnDefinition} to display {@link View} data within a {@link RowTableSeries}.
 *
 * @param definition: the desired {@link RowTableColumnDefinition}
 * @returns a valid {@link RowTableColumn}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a table visual
 *  const column = RowTableColumn({
 *      name: "Product",
 *      value: row_view.fields.Product,
 *      color: RowOrdinalColor(row_view.fields.Product)
 *  })
 * ```
 */
export declare function RowTableColumn<T extends RowTableColumnType = RowTableColumnType>(config: Omit<RowTableColumnDefinition<T>, 'type'>): RowTableColumnDefinition<T>;
/** @internal */
export declare type RowTableSeries = {
    type: 'row_table';
    kind: 'row';
    series_mode: 'flat';
    view: string;
    tooltip: null;
    columns: RowTableColumn[];
    select: Select | null;
};
/** @internal */
export declare function isRowTableSeries(config: Series): config is RowTableSeries;
/** @internal */
export declare function asRowTableSeries(config: Series): RowTableSeries;
/**
 * Defines a {@link RowTableSeriesDefinition} to display a table, presenting editable cells of values from {@link View} data.
 *
 * @category Visual
 */
export declare type RowTableSeriesDefinition = {
    /** the {@link SeriesDefinition} type */
    type: 'row_table';
    /** the {@link SeriesDefinition} kind */
    kind: 'row';
    /** the {@link View} to display */
    view: View | View;
    /** the {@link RowTableColumnDefinition}'s to display */
    columns?: RowTableColumnDefinition[];
    /** the {@link SelectDefinition} to select the value */
    select?: SelectDefinition;
};
/**
 * Create a {@link RowTableSeries} to display a table, presenting editable cells of values from {@link View} data.
 *
 * @param definition: the desired {@link RowTableSeriesDefinition}
 * @returns a valid {@link RowTableSeries}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a table visual
 *  const series = RowTableSeries({
 *      view: row_view,
 *      columns: [
 *          RowTableColumn({
 *              name: "Product",
 *              value: row_view.fields.Product,
 *              color: RowOrdinalColor(row_view.fields.Product)
 *          }),
 *          RowTableColumn({
 *              name: "Date",
 *              value: row_view.fields.Date,
 *          }),
 *          RowTableColumn({
 *              name: "Qty",
 *              value: row_view.fields.Qty,
 *              color: RowLinearColor(row_view.fields.Qty)
 *          }),
 *          RowTableColumn({
 *              name: "Amount",
 *              value: row_view.fields.Amount,
 *              background: RowLinearColor(row_view.fields.Amount)
 *          }),
 *     ]
 *  })
 * ```
 */
export declare function RowTableSeries(config: Omit<RowTableSeriesDefinition, 'kind' | 'type' | 'tooltip'>): RowTableSeriesDefinition;
/** @internal */
export declare type RowListContent = {
    name: string;
    value: Variable<PrimitiveType>;
    color: Color | null;
    opacity: Variable<'float'> | null;
    background: Color | null;
    tooltip: Tooltip | null;
};
/**
 * Defines a {@link RowListContentDefinition} to display {@link View} data within a {@link RowListSeries}.
 *
 * @category Visual
 */
export declare type RowListContentDefinition = {
    /** the list content name */
    name?: string;
    /** the {@link Variable} for the list element value */
    value: Variable<PrimitiveType>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the background {@link RowColorDefinition} */
    background?: RowColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
};
/**
 * Defines a {@link RowListContent} to display {@link View} data within a {@link RowListSeries}.
 *
 * @param definition: the desired {@link RowListContentDefinition}
 * @returns a valid {@link RowListContent}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a list visual
 *  const content = RowListContent({
 *      name: "Category",
 *      value: row_view.fields.Category,
 *      color: RowOrdinalColor(row_view.fields.Category)
 *  })
 * ```
 */
export declare function RowListContent(config: RowListContentDefinition): RowListContentDefinition;
/** @internal */
export declare type RowListSeries = {
    type: 'row_list';
    kind: 'row';
    series_mode: 'raw';
    view: string;
    value: Variable<"string">;
    description: Variable<"string"> | null;
    color: Color | null;
    opacity: Variable<'float'> | null;
    elements: RowListContent[];
    tooltip: null;
    select: Select | null;
    edit: Edit<"string"> | null;
    clear: Clear | null;
};
/** @internal */
export declare function isRowListSeries(config: Series): config is RowListSeries;
/** @internal */
export declare function asRowListSeries(config: Series): RowListSeries;
/**
 * Defines a {@link RowListSeriesDefinition} to display a list, presenting a list of combined values from {@link View} data.
 *
 * @category Visual
 */
export declare type RowListSeriesDefinition = {
    /** the {@link SeriesDefinition} type */
    type: 'row_list';
    /** the {@link SeriesDefinition} kind */
    kind: 'row';
    /** the {@link View} to display */
    view: View;
    /** the {@link Variable} for the header value */
    value: Variable<"string">;
    /** the {@link Variable} for the description value */
    description?: Variable<"string">;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the {@link RowListContentDefinition}'s to display */
    elements?: RowListContentDefinition[];
    /** the {@link SelectDefinition} to edit the value */
    select?: SelectDefinition;
    /** the {@link EditDefinition} to edit the value */
    edit?: EditDefinition<"string">;
    /** the {@link ClearDefinition} to clear the value */
    clear?: ClearDefinition;
};
/**
 * Create a {@link RowListSeries} to display a list, presenting a list of combined values from {@link View} data.
 *
 * @param definition: the desired {@link RowListSeriesDefinition}
 * @returns a valid {@link RowListSeries}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a list visual
 *  const series = RowListSeries({
 *      view: row_view,
 *      value: row_view.fields.Category,
 *      description: row_view.fields.Lorem,
 *      color: RowLinearColor(row_view.fields.Integer),
 *      elements: [
 *          RowListContent({
 *              name: "Date",
 *              value: row_view.fields.Date
 *          }),
 *          RowListContent({
 *              name: "Category",
 *              value: row_view.fields.Category,
 *              color: RowOrdinalColor(row_view.fields.Category)
 *          }),
 *          RowListContent({
 *              name: "Active",
 *              value: row_view.fields.Active
 *          }),
 *      ],
 *  });
 * ```
 */
export declare function RowListSeries(config: Omit<RowListSeriesDefinition, 'tooltip' | 'kind' | 'type'>): RowListSeriesDefinition;
/** @internal */
export declare type RowPivotSeries = {
    type: 'row_pivot';
    kind: 'row';
    series_mode: 'raw';
    view: string;
    row_pivot: Variable<'string'>;
    row_order: Variable<PrimitiveType> | null;
    col_pivot: Variable<'string'>;
    col_order: Variable<PrimitiveType> | null;
    value: Variable<StructType<Record<string, PrimitiveType>>>;
    label: Variable<'string'> | null;
    color: Color | null;
    opacity: Variable<'float'> | null;
    background: Color | null;
    tooltip: Tooltip | null;
};
/** @internal */
export declare function isRowPivotSeries(config: Series): config is RowPivotSeries;
/** @internal */
export declare function asRowPivotSeries(config: Series): RowPivotSeries;
/**
 * Defines a {@link RowPivotSeriesDefinition} to display a pivot, presenting one or more discrete value categories from {@link View} data.
 *
 * @category Series
 */
export declare type RowPivotSeriesDefinition = {
    /** the {@link SeriesDefinition} type */
    type: 'row_pivot';
    /** the {@link SeriesDefinition} kind */
    kind: 'row';
    /** the {@link View} to display */
    view: View;
    /** the {@link Variable} for the row value */
    row_pivot: Variable<'string'>;
    /** the {@link Variable} for the row order */
    row_order?: Variable<PrimitiveType>;
    /** the {@link Variable} for the col value */
    col_pivot: Variable<'string'>;
    /** the {@link Variable} for the col order */
    col_order?: Variable<PrimitiveType>;
    /** the {@link Variable} containing the cell label */
    label?: Variable<'string'>;
    /** the {@link Variable} containing the cell value */
    value: Variable<StructType<Record<string, PrimitiveType>>>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the background {@link RowColorDefinition} */
    background?: RowColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
};
/**
 * Create a {@link RowPivotSeries} to display a pivot, presenting one or more discrete value categories from {@link View} data.
 *
 * @param definition: the desired {@link RowPivotSeriesDefinition}
 * @returns a valid {@link RowPivotSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a pivot visual
 *  const series = RowPivotSeries({
 *      view: row_view,
 *      col_pivot: row_view.aggregations.Product,
 *      row_pivot: row_view.aggregations.Category,
 *      value: row_view.aggregations.Total,
 *      color: GroupLinearColor(row_view.aggregations.Total)
 *  })
 * ```
 */
export declare function RowPivotSeries(config: Omit<RowPivotSeriesDefinition, 'kind' | 'type'>): RowPivotSeriesDefinition;
/** @internal */
export declare type RowTreeSeries = {
    type: 'row_tree';
    kind: 'row';
    series_mode: 'raw';
    view: string;
    value: Record<string, Variable>;
    opacity: Variable<'float'> | null;
    color: Color | null;
    tooltip: null;
    select: Select | null;
    selected_only: boolean | null;
};
/** @internal */
export declare function isRowTreeSeries(config: Series): config is RowTreeSeries;
/** @internal */
export declare function asRowTreeSeries(config: Series): RowTreeSeries;
/**
 * Defines a {@link RowTreeSeriesDefinition} to display a tree, presenting nested values from {@link View} data.
 *
 * @category Visual
 */
export declare type RowTreeSeriesDefinition = {
    /** the {@link SeriesDefinition} type */
    type: 'row_tree';
    /** the {@link SeriesDefinition} kind */
    kind: 'row';
    /** the {@link View} to display */
    view: View;
    /** the {@link Variable} for the tree root */
    value: Record<string, Variable>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the {@link SelectDefinition} to select the value */
    select?: SelectDefinition;
    /** set to true to only display selected values */
    selected_only?: boolean;
};
/**
 * Create a {@link RowTreeSeries} to display a tree, presenting nested values from {@link View} data.
 *
 * @param definition: the desired {@link RowTreeSeriesDefinition}
 * @returns a valid {@link RowTreeSeries}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a tree visual
 *  const series = RowTreeSeries({
 *      view: row_view,
 *      value: row_view.fields
 *  })
 * ```
 */
export declare function RowTreeSeries(config: Omit<RowTreeSeriesDefinition, 'kind' | 'type' | 'tooltip'>): RowTreeSeriesDefinition;
/** @internal */
export declare type FormInput<T extends EastType = EastType> = T extends "string" ? {
    type: 'string';
    name: string;
    value: Variable<'string'>;
    color: Color | null;
    opacity: Variable<'float'> | null;
    edit: Edit<'string'> | null;
    clear: Clear | null;
} : T extends "float" ? {
    type: "float";
    name: string;
    value: Variable<"float">;
    opacity: Variable<'float'> | null;
    color: Color | null;
    edit: Edit<"float"> | null;
    clear: Clear | null;
} : T extends "datetime" ? {
    type: 'datetime';
    name: string;
    value: Variable<'datetime'>;
    opacity: Variable<'float'> | null;
    color: Color | null;
    edit: Edit<'datetime'> | null;
    clear: Clear | null;
} : T extends "boolean" ? {
    type: 'boolean';
    name: string;
    value: Variable<"boolean">;
    opacity: Variable<'float'> | null;
    color: Color | null;
    edit: Edit<"boolean"> | null;
    clear: Clear | null;
} : T extends "integer" ? {
    type: 'integer';
    name: string;
    value: Variable<'integer'>;
    opacity: Variable<'float'> | null;
    color: Color | null;
    edit: Edit<"integer"> | null;
    clear: Clear | null;
} : never;
/**
 * Defines a {@link FormInputDefinition} to display a form element from {@link View} data within a {@link RowFormSeries}.
 *
 * @category Visual
 */
export declare type FormInputDefinition<T extends EastType = EastType> = T extends "string" ? {
    /** the form value type */
    type: 'string';
    /** the form value name */
    name?: string;
    /** the {@link Variable} for the input value */
    value: Variable<'string'>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the {@link EditDefinition} to edit the value */
    edit?: EditDefinition<'string'>;
    /** the {@link ClearDefinition} to clear the value */
    clear?: ClearDefinition;
} : T extends "float" ? {
    /** the form value type */
    type: "float";
    /** the form value name */
    name?: string;
    /** the {@link Variable} for the input value */
    value: Variable<"float">;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the {@link EditDefinition} to edit the value */
    edit?: EditDefinition<"float">;
    /** the {@link ClearDefinition} to clear the value */
    clear?: ClearDefinition;
    /** @internal */
    range?: undefined;
} : T extends "datetime" ? {
    /** the form value type */
    type: 'datetime';
    /** the form value name */
    name?: string;
    /** the {@link Variable} for the input value */
    value: Variable<'datetime'>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the {@link EditDefinition} to edit the value */
    edit?: EditDefinition<'datetime'>;
    /** the {@link ClearDefinition} to clear the value */
    clear?: ClearDefinition;
} : T extends "boolean" ? {
    /** the form value type */
    type: 'boolean';
    /** the form value name */
    name?: string;
    /** the {@link Variable} for the input value */
    value: Variable<'boolean'>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the {@link EditDefinition} to edit the value */
    edit?: EditDefinition<'boolean'>;
    /** the {@link ClearDefinition} to clear the value */
    clear?: ClearDefinition;
} : T extends "integer" ? {
    /** the form value type */
    type: 'integer';
    /** the form value name */
    name?: string;
    /** the {@link Variable} for the input value */
    value: Variable<'integer'>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the {@link EditDefinition} to edit the value */
    edit?: EditDefinition<'integer'>;
    /** the {@link ClearDefinition} to clear the value */
    clear?: ClearDefinition;
} : never;
/**
 * Defines a {@link FormInput} to display a form element from {@link View} data within a {@link RowFormSeries}.
 *
 * @param definition: the desired {@link FormInputDefinition}
 * @returns a valid {@link FormInput}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a form visual
 *  const input = FormInput({
 *      name: "Date",
 *      value: row_view.fields.Date
 *  })
 * ```
 */
export declare function FormInput<T extends EastType = EastType>(config: Omit<FormInputDefinition<T>, 'type'>): FormInputDefinition<T>;
/** @internal */
export declare type RowFormSeries = {
    type: 'row_form';
    kind: 'row';
    series_mode: 'raw';
    view: string;
    elements: FormInput[];
    tooltip: null;
    select: Select | null;
    selected_only: boolean | null;
};
/** @internal */
export declare function isRowFormSeries(config: Series): config is RowFormSeries;
/** @internal */
export declare function asRowFormSeries(config: Series): RowFormSeries;
/**
 * Defines a {@link RowFormSeriesDefinition} to display a form, presenting editable values from {@link View} data.
 *
 * @category Visual
 */
export declare type RowFormSeriesDefinition = {
    /** the {@link SeriesDefinition} type */
    type: 'row_form';
    /** the {@link SeriesDefinition} kind */
    kind: 'row';
    /** the {@link View} to display */
    view: View;
    /** the {@link FormInputDefinition}'s to display */
    elements: FormInputDefinition[];
    /** the {@link SelectDefinition} to select the value */
    select?: SelectDefinition;
    /** set to true to only display selected value */
    selected_only?: boolean;
};
/**
 * Create a {@link RowFormSeries} to display a form, presenting editable values from {@link View} data.
 *
 * @param definition: the desired {@link RowFormSeriesDefinition}
 * @returns a valid {@link RowFormSeries}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a form visual
 *  const series = RowFormSeries({
 *      view: row_view,
 *      elements: [
 *          FormInput({
 *              name: "Date",
 *              value: row_view.fields.Date
 *          }),
 *          FormInput({
 *              name: Active,
 *              value: row_view.fields.Active
 *          }),
 *          FormInput({
 *              name: "Category",
 *              value: row_view.fields.Category
 *          }),
 *      ],
 *  })
 * ```
 */
export declare function RowFormSeries(config: Omit<RowFormSeriesDefinition, 'kind' | 'type'>): RowFormSeriesDefinition;
/** @internal */
export declare type RowHTMLSeries = {
    type: 'row_html';
    kind: 'row';
    series_mode: 'raw';
    view: string;
    value: EastFunction<'string'>;
    tooltip: null;
    select: Select | null;
    selected_only: boolean | null;
};
/** @internal */
export declare function isRowHTMLSeries(config: Series): config is RowHTMLSeries;
/** @internal */
export declare function asRowHTMLSeries(config: Series): RowHTMLSeries;
/**
 * Defines a {@link RowHTMLSeriesDefinition} to display html content, presenting string values from {@link View} data.
 *
 * @category Visual
 */
export declare type RowHTMLSeriesDefinition = {
    /** the {@link SeriesDefinition} type */
    type: 'row_html';
    /** the {@link SeriesDefinition} kind */
    kind: 'row';
    /** the {@link View} to display */
    view: View;
    /** the {@link Variable} for the html value */
    value: EastFunction<'string'>;
    /** the {@link SelectDefinition} to select the value */
    select?: SelectDefinition;
    /** set to true to only display selected values */
    selected_only?: boolean;
};
/**
 * Create a {@link RowHTMLSeries} to display html content, presenting string values from {@link View} data.
 *
 * @param definition: the desired {@link RowHTMLSeriesDefinition}
 * @returns a valid {@link RowHTMLSeries}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a html chart
 *  const series = RowHTMLSeries({
 *      view: row_view,
 *      value: StringJoin`<p>
 *          Did you know that <b>{row_view.fields.TotalQty}</b>
 *          were sold resulting in total revenue of
 *          <b>{PrintTruncatedCurrency(row_view.fields.TotalAmount)}</b>?
 *      </p>`
 *  })
 * ```
 */
export declare function RowHTMLSeries(config: Omit<RowHTMLSeriesDefinition, 'kind' | 'type' | 'tooltip'>): RowHTMLSeriesDefinition;
/** @internal */
export declare type RowTimelineInput = {
    start: Variable<"datetime">;
    end: Variable<"datetime"> | null;
    label: Variable<'string'> | null;
    tooltip: Tooltip | null;
    color: Color | null;
    opacity: Variable<'float'> | null;
    border: Color | null;
    dash: Variable<ArrayType<'float'>> | null;
    prev_primary: Variable<"string"> | Variable<'set'> | null;
    next_primary: Variable<"string"> | Variable<'set'> | null;
    select: Select | null;
};
/**
 * Defines a {@link RowTimelineInputDefinition} to display {@link View} data within a {@link RowTimelineSeries}.
 *
 * @category Series
 */
export declare type RowTimelineInputDefinition = {
    /** the {@link Variable} for the bar start value */
    start: Variable<"datetime">;
    /** the {@link Variable} for the bar end value */
    end?: Variable<"datetime">;
    /** the {@link Variable} for the bar label */
    label?: Variable<'string'>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for opacity */
    opacity?: Variable<'float'>;
    /** the border {@link RowColorDefinition} */
    border?: RowColorDefinition;
    /** the {@link Variable} for the dash value */
    dash?: Variable<ArrayType<'float'>>;
    /** the {@link Variable} for the prev bar primary value */
    prev_primary?: Variable<"string"> | Variable<'set'>;
    /** the {@link Variable} for the next bar primary value */
    next_primary?: Variable<"string"> | Variable<'set'>;
    /** the {@link SelectDefinition} to select the value */
    select?: SelectDefinition;
};
/**
 * Create a {@link RowTimelineInput} to display {@link View} data within a {@link RowTimelineSeries}.
 *
 * @param definition: the desired {@link RowTimelineInputDefinition}
 * @returns a valid {@link RowTimelineInput}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a timeline chart
 *  const input = RowTimelineInput({
 *      start: row_view.fields.Date,
 *      end: row_view.fields.EndDate,
 *      color: RowFixedColor(row_view.fields.Color),
 *      border:  RowFixedColor(row_view.fields.Color),
 *      opacity: row_view.fields.Price,
 *  })
 * ```
 */
export declare function RowTimelineInput(config: RowTimelineInputDefinition): RowTimelineInputDefinition;
/** @internal */
export declare type RowTimelineSeries = {
    type: 'row_timeline';
    kind: 'row';
    series_mode: 'flat';
    view: string;
    x: RowTimelineInput[];
    y: Variable<"string">;
    tooltip: null;
    select: null;
};
/** @internal */
export declare function isRowTimelineSeries(config: Series): config is RowTimelineSeries;
/** @internal */
export declare function asRowTimelineSeries(config: Series): RowTimelineSeries;
/**
 * Defines a {@link RowTimelineSeriesDefinition} to display a timeline, presenting durations accross time from {@link View} data.
 *
 * @category Visual
 */
export declare type RowTimelineSeriesDefinition = {
    /** the {@link SeriesDefinition} type */
    type: 'row_timeline';
    /** the {@link SeriesDefinition} kind */
    kind: 'row';
    /** the {@link View} to display */
    view: View | View;
    /** the {@link RowTimelineInputDefinition}'s to display  */
    x: RowTimelineInputDefinition[];
    /** the {@link Variable} for the y value */
    y: Variable<"string">;
};
/**
 * Create a {@link RowTimelineSeries} to display a timeline, presenting durations accross time from {@link View} data.
 *
 * @param definition: the desired {@link RowTimelineSeriesDefinition}
 * @returns a valid {@link RowTimelineSeries}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a timeline chart
 *  const series = RowTimelineSeries({
 *      view: row_view,
 *      y: row_view.primary_key,
 *      x: [
 *          RowTimelineInput({
 *              start: row_view.fields.Date,
 *              end: row_view.fields.EndDate,
 *              color: RowFixedColor(row_view.fields.Color),
 *              border:  RowFixedColor(row_view.fields.Color),
 *              opacity: row_view.fields.Price,
 *          })
 *      ]
 *  })
 * ```
 */
export declare function RowTimelineSeries(config: Omit<RowTimelineSeriesDefinition, 'kind' | 'type'>): RowTimelineSeriesDefinition;
/** @internal */
export declare type RowGeoSeries = {
    type: 'row_geo';
    kind: 'row';
    series_mode: 'raw';
    view: string;
    lat: Variable<"float">;
    lon: Variable<"float">;
    color: Color | null;
    tooltip: Tooltip | null;
    select: Select | null;
    selected_only: boolean | null;
};
/** @internal */
export declare function isRowGeoSeries(config: RowGeoSeries): config is RowGeoSeries;
/** @internal */
export declare function asRowGeoSeries(config: RowGeoSeries): RowGeoSeries;
/**
 * Defines a {@link RowGeoSeriesDefinition} to display a goegraphic chart, presenting spatial data from {@link View} data.
 *
 * @category Visual
 */
export declare type RowGeoSeriesDefinition = {
    /** the {@link SeriesDefinition} type */
    type: 'row_geo';
    /** the {@link SeriesDefinition} kind */
    kind: 'row';
    /** the {@link View} to display */
    view: View;
    /** the {@link Variable} for the latitude value */
    lat: Variable<"float">;
    /** the {@link Variable} for the longitude value */
    lon: Variable<"float">;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** the {@link SelectDefinition} to select the value */
    select?: SelectDefinition;
    /** set to true to only display selected values */
    selected_only?: boolean;
};
/**
 * Create a {@link RowGeoSeries} to display a goegraphic chart, presenting spatial data from {@link View} data.
 *
 * @param definition: the desired {@link RowGeoSeriesDefinition}
 * @returns a valid {@link RowGeoSeries}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create geo chart
 *  const series = RowGeoSeries({
 *      view: row_view,
 *      lat: row_view.fields.Latitude,
 *      lon: row_view.fields.Longitude,
 *      color: RowOrdinalColor(row_view.fields.Category)
 *  })
 * ```
 */
export declare function RowGeoSeries(config: Omit<RowGeoSeriesDefinition, 'kind' | 'type'>): RowGeoSeriesDefinition;
/** @internal */
export declare type RowLineItem<Y extends NumericType = NumericType> = {
    name: string;
    value: Variable<Y> | Variable<DictType<Y>>;
    color: Color | KeyColor | null;
    opacity: Variable<'float'> | null;
    tooltip: Tooltip | null;
    select: Select | null;
    dash: Variable<ArrayType<'float'>> | null;
    curve: CurveType;
    point: boolean;
};
/**
 * Defines a {@link RowLineDictDefinition} to display {@link View} dict data within a {@link RowLineSeries}.
 *
 * @category Visual
 */
export declare type RowLineDictDefinition<Y extends NumericType = NumericType> = {
    /** the value type */
    type: DictType<Y>;
    /** the item name */
    name?: string;
    /** the {@link Variable} for the line y value */
    value: Variable<DictType<Y>>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowKeyColorDefinition;
    /** the {@link Variable} for opacity */
    opacity?: Variable<'float'>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** the {@link SelectDefinition} to select the value */
    select?: SelectDefinition;
    /** the {@link Variable} for the dash value */
    dash?: Variable<ArrayType<'float'>>;
    /** the line {@link CurveType} */
    curve?: CurveType;
    /** set to true to show the points on the line */
    point?: boolean;
};
/**
 * Create a {@link RowLineDict} to display {@link View} dict data within a {@link RowLineSeries}.
 *
 * @param definition: the desired {@link RowLineDictDefinition}
 * @returns a valid {@link RowLineDict}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a dictionary line
 *  const line = RowLineDict({
 *      value: row_view.fields.RateCard,
 *  })
 * ```
 */
export declare function RowLineDict(config: Omit<RowLineDictDefinition, 'type'>): RowLineDictDefinition;
/**
 * Defines the style to display for a line.
 *
 * @category Visual
 */
export declare type RowLineValueStyle = {
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for opacity */
    opacity?: Variable<'float'>;
    /** the {@link Variable} for the dash value */
    dash?: Variable<ArrayType<'float'>>;
    /** the {@link CurveType} of the line */
    curve?: CurveType;
    /** set to true to show the points on the line */
    point?: boolean;
};
/**
 * Defines a {@link RowLineDictDefinition} to display {@link View} data within a {@link RowLineSeries}.
 *
 * @category Visual
 */
export declare type RowLineValueDefinition<Y extends NumericType = NumericType> = {
    /** the value type */
    type: Y;
    /** the item name */
    name?: string;
    /** the {@link Variable} for the line y value */
    value: Variable<NumericType>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for opacity */
    opacity?: Variable<'float'>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** the {@link SelectDefinition} to select the value */
    select?: SelectDefinition;
    /** the {@link Variable} for the dash value */
    dash?: Variable<ArrayType<'float'>>;
    /** the {@link CurveType} of the line */
    curve?: CurveType;
    /** set to true to show the points on the line */
    point?: boolean;
};
/**
 * Create a {@link RowLineValue} to display {@link View} data within a {@link RowLineSeries}.
 *
 * @param definition: the desired {@link RowLineValueDefinition}
 * @returns a valid {@link RowLineValue}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a line value
 *  const input = RowLineValue({
 *      value: row_view.fields.Qty,
 *      color: ColorValue(),
 *  })
 * ```
 */
export declare function RowLineValue(config: Omit<RowLineValueDefinition, 'type'>): RowLineValueDefinition;
/**
 * Defines a {@link RowLineItemDefinition} to display {@link View} data within a {@link RowLineValue}.
 *
 * @category Visual
 */
export declare type RowLineItemDefinition<Y extends NumericType = NumericType> = RowLineDictDefinition<Y> | RowLineValueDefinition<Y>;
/** @internal */
export declare type RowLineSeries<X extends ContinuousType = ContinuousType> = {
    type: 'row_line';
    kind: 'row';
    series_mode: 'raw';
    x: Variable<X>;
    y: RowLineItem<NumericType>[];
    y_heading: string;
    y_all: boolean;
    tooltip: null;
    view: string;
};
/** @internal */
export declare function isRowLineSeries(config: Series): config is RowLineSeries;
/** @internal */
export declare function asRowLineSeries(config: Series): RowLineSeries;
/**
 * Defines a {@link RowLineSeriesDefinition} to display a line chart, presenting data points connected by line segments from {@link View} data.
 *
 * @category Visual
 */
export declare type RowLineSeriesDefinition<X extends ContinuousType = ContinuousType> = {
    /** the {@link SeriesDefinition} type */
    type: 'row_line';
    /** the {@link SeriesDefinition} kind */
    kind: 'row';
    /** @internal */
    series_mode: 'raw';
    /** the {@link Variable} for the line x value */
    x: Variable<X>;
    /** the {@link RowLineItemDefinition}'s to display  */
    y: RowLineItemDefinition<NumericType>[];
    /** the y axis heading */
    y_heading?: string;
    /** set to true if all items should be displayed */
    y_all?: boolean;
    /** the {@link View} to display */
    view: View;
};
/**
 * Create a {@link RowLineSeries} to display a line chart, presenting data points connected by line segments from {@link View} data.
 *
 * @param definition: the desired {@link RowLineSeriesDefinition}
 * @returns a valid {@link RowLineSeries}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a line chart
 *  const series = RowLineSeries({
 *      view: row_view,
 *      x: row_view.fields.EndDate,
 *      y_heading: "Values",
 *      y: [
 *          RowLineValue({
 *              value: row_view.fields.Qty,
 *              color: ColorValue(),
 *          }),
 *          RowLineDict({
 *              value: row_view.fields.RateCard,
 *          })
 *      ]
 *  })
 * ```
 */
export declare function RowLineSeries<X extends ContinuousType = ContinuousType>(config: Omit<RowLineSeriesDefinition<X>, 'kind' | 'type' | 'series_mode'>): RowLineSeriesDefinition<X>;
/** @internal */
export declare type RowAreaItem<Y extends NumericType = NumericType> = {
    name: string;
    value: Variable<Y> | Variable<DictType<Y>>;
    color: Color | KeyColor | null;
    opacity: Variable<'float'> | null;
    tooltip: Tooltip | null;
    select: Select | null;
    dash: Variable<ArrayType<'float'>> | null;
    curve: CurveType;
    point: boolean;
};
/**
 * Defines a {@link RowAreaDictDefinition} to display {@link View} dict data within a {@link RowAreaSeries}.
 *
 * @category Visual
 */
export declare type RowAreaDictDefinition<Y extends NumericType = NumericType> = {
    /** the value type */
    type: DictType<Y>;
    /** the item name */
    name?: string;
    /** the {@link Variable} for the line y value */
    value: Variable<DictType<Y>>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowKeyColorDefinition;
    /** the {@link Variable} for opacity */
    opacity?: Variable<'float'>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** the {@link SelectDefinition} to select the value */
    select?: SelectDefinition;
    /** the {@link Variable} for the dash value */
    dash?: Variable<ArrayType<'float'>>;
    /** the line {@link CurveType} */
    curve?: CurveType;
    /** set to true to show the points on the line */
    point?: boolean;
};
/**
 * Create a {@link RowAreaDict} to display {@link View} dict data within a {@link RowAreaSeries}.
 *
 * @param definition: the desired {@link RowAreaDictDefinition}
 * @returns a valid {@link RowAreaDict}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a dictionary line
 *  const line = RowAreaDict({
 *      value: row_view.fields.RateCard,
 *  })
 * ```
 */
export declare function RowAreaDict(config: Omit<RowAreaDictDefinition, 'type'>): RowAreaDictDefinition;
/**
 * Defines the style to display for a an area.
 *
 * @category Visual
 */
export declare type RowAreaValueStyle = {
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for opacity */
    opacity?: Variable<'float'>;
    /** the {@link Variable} for the dash value */
    dash?: Variable<ArrayType<'float'>>;
    /** the {@link CurveType} of the line */
    curve?: CurveType;
    /** set to true to show the points on the line */
    point?: boolean;
};
/**
 * Defines a {@link RowAreaDictDefinition} to display {@link View} data within a {@link RowAreaSeries}.
 *
 * @category Visual
 */
export declare type RowAreaValueDefinition<Y extends NumericType = NumericType> = {
    /** the value type */
    type: Y;
    /** the item name */
    name?: string;
    /** the {@link Variable} for the line y value */
    value: Variable<NumericType>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for opacity */
    opacity?: Variable<'float'>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** the {@link SelectDefinition} to select the value */
    select?: SelectDefinition;
    /** the {@link Variable} for the dash value */
    dash?: Variable<ArrayType<'float'>>;
    /** the {@link CurveType} of the line */
    curve?: CurveType;
    /** set to true to show the points on the line */
    point?: boolean;
};
/**
 * Create a {@link RowAreaValue} to display {@link View} data within a {@link RowAreaSeries}.
 *
 * @param definition: the desired {@link RowAreaValueDefinition}
 * @returns a valid {@link RowAreaValue}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a line value
 *  const input = RowAreaValue({
 *      value: row_view.fields.Qty,
 *      color: ColorValue(),
 *  })
 * ```
 */
export declare function RowAreaValue(config: Omit<RowAreaValueDefinition, 'type'>): RowAreaValueDefinition;
/**
 * Defines a {@link RowAreaItemDefinition} to display {@link View} data within a {@link RowAreaValue}.
 *
 * @category Visual
 */
export declare type RowAreaItemDefinition<Y extends NumericType = NumericType> = RowAreaDictDefinition<Y> | RowAreaValueDefinition<Y>;
/** @internal */
export declare type RowAreaSeries<X extends ContinuousType = ContinuousType> = {
    type: 'row_area';
    kind: 'row';
    series_mode: 'raw';
    x: Variable<X>;
    y: RowAreaItem<NumericType>[];
    y_heading: string;
    y_all: boolean;
    tooltip: null;
    view: string;
};
/** @internal */
export declare function isRowAreaSeries(config: Series): config is RowAreaSeries;
/** @internal */
export declare function asRowAreaSeries(config: Series): RowAreaSeries;
/**
 * Defines a {@link RowAreaSeriesDefinition} to display an area chart, presenting data points connected by shaded line segments from {@link View} data.
 *
 * @category Visual
 */
export declare type RowAreaSeriesDefinition<X extends ContinuousType = ContinuousType> = {
    /** the {@link SeriesDefinition} type */
    type: 'row_area';
    /** the {@link SeriesDefinition} kind */
    kind: 'row';
    /** @internal */
    series_mode: 'raw';
    /** the {@link Variable} for the line x value */
    x: Variable<X>;
    /** the {@link RowAreaItemDefinition}'s to display  */
    y: RowAreaItemDefinition<NumericType>[];
    /** the y axis heading */
    y_heading?: string;
    /** set to true if all items should be displayed */
    y_all?: boolean;
    /** the {@link View} to display */
    view: View;
};
/**
 * Create a {@link RowAreaSeries} to display an area chart, presenting data points connected by shaded line segments from {@link View} data.
 *
 * @param definition: the desired {@link RowAreaSeriesDefinition}
 * @returns a valid {@link RowAreaSeries}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a line chart
 *  const series = RowAreaSeries({
 *      view: row_view,
 *      x: row_view.fields.EndDate,
 *      y_heading: "Values",
 *      y: [
 *          RowAreaValue({
 *              value: row_view.fields.Qty,
 *              color: ColorValue(),
 *          }),
 *          RowAreaDict({
 *              value: row_view.fields.RateCard,
 *          })
 *      ]
 *  })
 * ```
 */
export declare function RowAreaSeries<X extends ContinuousType = ContinuousType>(config: Omit<RowAreaSeriesDefinition<X>, 'kind' | 'type' | 'series_mode'>): RowAreaSeriesDefinition<X>;
/** @internal */
export declare type RowScatterSeries<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType, Z extends ContinuousType = ContinuousType> = {
    type: 'row_scatter';
    kind: 'row';
    series_mode: 'raw';
    x: Variable<X>;
    y: Variable<Y>;
    size: Variable<Z> | null;
    color: Color | null;
    opacity: Variable<'float'> | null;
    tooltip: Tooltip | null;
    view: string;
    select: Select | null;
};
/** @internal */
export declare function isRowScatterSeries(config: Series): config is RowScatterSeries;
/** @internal */
export declare function asRowScatterSeries(config: Series): RowScatterSeries;
/**
 * Defines a {@link RowScatterSeriesDefinition} to display a scatter chart, presenting dots to represent values from {@link View} data.
 *
 * @category Visual
 */
export declare type RowScatterSeriesDefinition<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType, Z extends ContinuousType = ContinuousType> = {
    /** the {@link SeriesDefinition} type */
    type: 'row_scatter';
    /** the {@link SeriesDefinition} kind */
    kind: 'row';
    /** the {@link Variable} for the point x value */
    x: Variable<X>;
    /** the {@link Variable} for the point y value */
    y: Variable<Y>;
    /** the {@link Variable} for the point size value */
    size?: Variable<Z>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** the {@link View} to display */
    view: View;
    /** the {@link SelectDefinition} to select the value */
    select?: SelectDefinition;
};
/**
 * Create a {@link RowScatterSeries} to display a scatter chart, presenting dots to represent values from {@link View} data.
 *
 * @param definition: the desired {@link RowScatterSeriesDefinition}
 * @returns a valid {@link RowScatterSeries}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a scatter chart
 *  const series = RowScatterSeries({
 *      view: row_view,
 *      x: row_view.fields.Qty,
 *      y: row_view.fields.Amount,
 *      size: row_view.fields.Amount,
 *      color: RowOrdinalColor(row_view.fields.Category)
 *  })
 * ```
 */
export declare function RowScatterSeries<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType, Z extends ContinuousType = ContinuousType>(config: Omit<RowScatterSeriesDefinition<X, Y, Z>, 'kind' | 'type'>): RowScatterSeriesDefinition<X, Y, Z>;
/** @internal */
export declare type RowMarginalItem<X extends PrimitiveType = PrimitiveType> = {
    name: string;
    value: Variable<X> | Variable<DictType<X>>;
    opacity: Variable<'float'> | null;
    color: Color | null;
    tooltip: Tooltip | null;
};
/**
 * Defines a {@link RowMarginalDictDefinition} to display {@link View} dict data within a {@link RowMarginalSeries}.
 *
 * @category Visual
 */
export declare type RowMarginalDictDefinition<Y extends PrimitiveType = PrimitiveType> = {
    /** the marginal value type */
    type: DictType<Y>;
    /** the marginal value name */
    name?: string;
    /** the {@link Variable} for the line marginal value */
    value: Variable<DictType<Y>>;
    /** the foreground {@link RowKeyColorDefinition} */
    color?: RowKeyColorDefinition;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
};
/**
 * Defines a {@link RowMarginalDict} to display {@link View} dict data within a {@link RowMarginalSeries}.
 *
 * @param definition: the desired {@link RowMarginalDictDefinition}
 * @returns a valid {@link RowMarginalDict}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a marginal analysis chart
 *  const value = RowMarginalDict({
 *      name: "Number 2",
 *      value: row_view.fields.RateCard,
 *      color: ColorValue(colors.Red),
 *  })
 * ```
 */
export declare function RowMarginalDict(config: Omit<RowMarginalDictDefinition, 'type'>): RowMarginalDictDefinition;
/**
 * Defines a {@link RowMarginalValueDefinition} to display {@link View} data within a {@link RowMarginalSeries}.
 *
 * @category Visual
 */
export declare type RowMarginalValueDefinition<Y extends PrimitiveType = PrimitiveType> = {
    /** the marginal value type */
    type: Y;
    /** the marginal value name */
    name?: string;
    /** the {@link Variable} for the line marginal value */
    value: Variable<PrimitiveType>;
    /** the foreground {@link RowKeyColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
};
/**
 * Defines a {@link RowMarginalValue} to display {@link View} dict data within a {@link RowMarginalSeries}.
 *
 * @param definition: the desired {@link RowMarginalValueDefinition}
 * @returns a valid {@link RowMarginalValue}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a marginal analysis chart
 *  const value = RowMarginalValue({
 *      name: "Number 2",
 *      value: row_view.fields.Qty,
 *      color: ColorValue(colors.Red),
 *  })
 * ```
 */
export declare function RowMarginalValue(config: Omit<RowMarginalValueDefinition, 'type'>): RowMarginalValueDefinition;
/**
 * Defines a {@link RowMarginalItemDefinition} to display {@link View} data within a {@link RowMarginalSeries}.
 *
 * @category Visual
 */
export declare type RowMarginalItemDefinition<Y extends PrimitiveType = PrimitiveType> = RowMarginalDictDefinition<Y> | RowMarginalValueDefinition<Y>;
/** @internal */
export declare type RowMarginalSeries<Y extends PrimitiveType = PrimitiveType> = {
    type: 'row_marginal';
    kind: 'row';
    series_mode: 'raw';
    x: RowMarginalItem<PrimitiveType>[];
    x_heading: string;
    y: Variable<Y> | Variable<DictType<Y>>;
    y_heading: string;
    tooltip: null;
    view: string;
};
/** @internal */
export declare function isRowMarginalSeries(config: Series): config is RowMarginalSeries;
/** @internal */
export declare function asRowMarginalSeries(config: Series): RowMarginalSeries;
/**
 * Defines a {@link RowMarginalSeriesDefinition} to display a marginal chart, presenting varying series of dots to represent values from {@link View} data.
 *
 * @category Visual
 */
export declare type RowMarginalSeriesDefinition<X extends PrimitiveType = PrimitiveType> = {
    /** the {@link SeriesDefinition} type */
    type: 'row_marginal';
    /** the {@link SeriesDefinition} kind */
    kind: 'row';
    /** the {@link RowMarginalItemDefinition}'s to display'  */
    x: RowMarginalItemDefinition[];
    /** the x axis heading */
    x_heading?: string;
    /** the {@link Variable} for the y value */
    y: Variable<X> | Variable<DictType<X>>;
    /** the y axis heading */
    y_heading?: string;
    /** @internal */
    tooltip: null;
    /** the {@link View} to display */
    view: View;
};
/**
 * Create a {@link RowMarginalSeries} to display a marginal anaylsis chart, presenting varying series of dots to represent values from {@link View} data.
 *
 * @param definition: the desired {@link RowMarginalSeriesDefinition}
 * @returns a valid {@link RowMarginalSeries}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *  import total_view from "./gen/total.view"
 *
 *  // create a marginal analysis chart
 *  const series = RowMarginalSeries({
 *      view: row_view,
 *      y: row_view.fields.Qty,
 *      x: [
 *          RowMarginalValue({
 *              name: "String 1",
 *              value: row_view.fields.Category,
 *              color: ColorValue(),
 *          }),
 *          RowMarginalValue({
 *              name: "Number 2",
 *              value: row_view.fields.Qty,
 *              color: ColorValue(colors.Red),
 *          }),
 *      ]
 *  })
 * ```
 */
export declare function RowMarginalSeries<X extends PrimitiveType = PrimitiveType>(config: Omit<RowMarginalSeriesDefinition<X>, 'kind' | 'type' | 'tooltip'>): RowMarginalSeriesDefinition<X>;
/** @internal */
export declare type RowRidgelineSeries<X extends ContinuousType = ContinuousType, Z extends NumericType = NumericType> = {
    type: 'row_ridgeline';
    kind: 'row';
    series_mode: 'nested';
    view: string;
    x: Variable<X>;
    z: Variable<Z>;
    overlap: number;
    color: Color | null;
    opacity: Variable<'float'> | null;
    dash: Variable<ArrayType<'float'>> | null;
    tooltip: Tooltip | null;
    curve: CurveType;
    select: Select | null;
    point: boolean;
};
/** @internal */
export declare function isRowRidgelineSeries(config: Series): config is RowRidgelineSeries;
/** @internal */
export declare function asRowRidgelineSeries(config: Series): RowRidgelineSeries;
/**
 * Defines a {@link RowRidgelineSeriesDefinition} to display a ridge line chart, presenting stacked series of data points connected by shaded line segments from {@link View} data.
 *
 * @category Series
 */
export declare type RowRidgelineSeriesDefinition<X extends ContinuousType = ContinuousType, Z extends NumericType = NumericType> = {
    /** the {@link SeriesDefinition} type */
    type: 'row_ridgeline';
    /** the {@link SeriesDefinition} kind */
    kind: 'row';
    /** @internal */
    series_mode: 'nested';
    /** the {@link View} to display */
    view: View;
    /** the {@link Variable} for the x value */
    x: Variable<X>;
    /** the {@link Variable} for the z value */
    z: Variable<Z>;
    /** the {@link Variable} for the max z value */
    overlap?: number;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the {@link Variable} for the dash value */
    dash?: Variable<ArrayType<'float'>>;
    /** the {@link TooltipDefinition} to display on mouseover */
    tooltip?: TooltipDefinition;
    /** the {@link CurveType} of the line */
    curve?: CurveType;
    /** the {@link SelectDefinition} to select the value */
    select?: SelectDefinition;
    /** set to true to show the points on the line */
    point?: boolean;
};
/**
 * Create a {@link RowRidgelineSeries} to display a ridge line chart, presenting stacked series of data points connected by shaded line segments from {@link View} data.
 *
 * @param definition: the desired {@link RowRidgelineSeriesDefinition}
 * @returns a valid {@link RowRidgelineSeries}
 *
 * @category Series
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create ridgeline chart
 *  const series = RowRidgelineSeries({
 *      view: row_view,
 *      x: row_view.aggregations.Product,
 *      y: row_view.aggregations.Category,
 *      z: row_view.aggregations.Total,
 *      z_min: row_view.aggregations.Minimum,
 *      z_max: row_view.aggregations.Maximum,
 *      color: RowOrdinalColor(row_view.aggregations.Product),
 *  })
 * ```
 */
export declare function RowRidgelineSeries<X extends ContinuousType = ContinuousType, Z extends NumericType = NumericType>(config: Omit<RowRidgelineSeriesDefinition<X, Z>, 'kind' | 'type' | 'series_mode'>): RowRidgelineSeriesDefinition<X, Z>;
/** @internal */
export declare type RowDistributionItem<Y extends NumericType = NumericType> = {
    name: string;
    value: Variable<Y> | Variable<DictType<Y>>;
    color: Color | null;
    opacity: Variable<'float'> | null;
    dash: Variable<ArrayType<'float'>> | null;
    curve: CurveType;
};
/**
 * Defines a {@link RowDistributionDictDefinition} to display dict {@link View} data within a {@link RowDistributionSeries}.
 *
 * @category Visual
 */
export declare type RowDistributionDictDefinition<Y extends NumericType = NumericType> = {
    /** the distibution type */
    type: DictType<Y>;
    /** the distribution name */
    name?: string;
    /** the {@link Variable} for the distribution x value */
    value: Variable<DictType<Y>>;
    /** the foreground {@link RowKeyColorDefinition} */
    color?: RowKeyColorDefinition;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the {@link Variable} for the dash value */
    dash?: Variable<ArrayType<'float'>>;
    /** the {@link CurveType} of the line */
    curve?: CurveType;
};
/**
 * Defines a {@link RowDistributionDict} to display dict {@link View} data within a {@link RowDistributionSeries}.
 *
 * @param definition: the desired {@link RowDistributionDictDefinition}
 * @returns a valid {@link RowDistributionDict}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a dsitribution item
 *  const item = RowDistributionDict({
 *      value: row_view.fields.RateCard,
 *  })
 * ```
 */
export declare function RowDistributionDict(config: Omit<RowDistributionDictDefinition, 'type'>): RowDistributionDictDefinition;
/**
 * Defines a {@link RowDistributionValueDefinition} to display {@link View} data within a {@link RowDistributionSeries}.
 *
 * @category Visual
 */
export declare type RowDistributionValueDefinition<Y extends NumericType = NumericType> = {
    /** the distibution type */
    type: Y;
    /** the distribution name */
    name?: string;
    /** the {@link Variable} for the distribution x value */
    value: Variable<NumericType>;
    /** the foreground {@link RowKeyColorDefinition} */
    color?: RowColorDefinition;
    /** the {@link Variable} for the foreground opacity */
    opacity?: Variable<'float'>;
    /** the {@link Variable} for the dash value */
    dash?: Variable<ArrayType<'float'>>;
    /** the {@link CurveType} of the line */
    curve?: CurveType;
};
/**
 * Defines a {@link RowDistributionValue} to display {@link View} dict data within a {@link RowDistributionSeries}.
 *
 * @param definition: the desired {@link RowDistributionValueDefinition}
 * @returns a valid {@link RowDistributionValue}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *
 *  // create a distribution item
 *  const input = RowDistributionValue({
 *      value: row_view.fields.Price,
 *      color: ColorValue(colors.Red),
 *  })
 * ```
 */
export declare function RowDistributionValue(config: Omit<RowDistributionValueDefinition, 'type'>): RowDistributionValueDefinition;
/**
 * Defines a {@link RowDistributionItemDefinition} to display {@link View} data within a {@link RowDistributionSeries}.
 *
 * @category Visual
 */
export declare type RowDistributionItemDefinition<Y extends NumericType = NumericType> = RowDistributionDictDefinition<Y> | RowDistributionValueDefinition<Y>;
/** @internal */
export declare type RowDistributionSeries = {
    type: 'row_distribution';
    kind: 'row';
    series_mode: 'distribution';
    x: RowDistributionItem<NumericType>[];
    x_heading: string;
    x_all: boolean;
    tooltip: null;
    view: string;
    options: DistributionOptions | null;
};
/** @internal */
export declare function isRowDistributionSeries(config: Series): config is RowDistributionSeries;
/** @internal */
export declare function asRowDistributionSeries(config: Series): RowDistributionSeries;
/**
 * Defines a {@link RowDistributionSeriesDefinition} to display a distribution chart, presenting a statistival distribution from {@link View} data.
 *
 * @category Visual
 */
export declare type RowDistributionSeriesDefinition = {
    /** the {@link SeriesDefinition} type */
    type: 'row_distribution';
    /** the {@link SeriesDefinition} kind */
    kind: 'row';
    /** @internal */
    series_mode: 'distribution';
    /** the {@link RowDistributionItemDefinition}'s to display */
    x: RowDistributionItemDefinition<NumericType>[];
    /** the {@link RowDistributionItemDefinition} list heading to display */
    x_heading?: string;
    /** set to true if all items should be displayed */
    x_all?: boolean;
    /** the {@link View} to display */
    view: View;
    /** the {@link DistributionOptions} to apply */
    options?: DistributionOptions | null;
};
/**
 * Create a {@link RowDistributionSeries} to display a distribution chart, presenting a statistival distribution from {@link View} data.
 *
 * @param definition: the desired {@link RowDistributionSeriesDefinition}
 * @returns a valid {@link RowDistributionSeries}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *  import total_view from "./gen/total.view"
 *
 *  // create a distribution visual
 *  const series = RowDistributionSeries({
 *      view: row_view,
 *      x: [
 *          RowDistributionDict({
 *              value: row_view.fields.RateCard,
 *          }),
 *          RowDistributionValue({
 *              value: row_view.fields.Price,
 *              color: ColorValue(colors.Red),
 *          }),
 *      ],
 *  })
 * ```
 */
export declare function RowDistributionSeries(config: Omit<RowDistributionSeriesDefinition, 'kind' | 'type' | 'series_mode' | 'select' | 'tooltip'>): RowDistributionSeriesDefinition;
/** @internal */
export declare type RowHexbinSeries<X extends NumericType = NumericType, Y extends NumericType = NumericType> = {
    type: 'row_hexbin';
    kind: 'row';
    series_mode: 'raw';
    x: Variable<X> | Variable<DictType<X>>;
    y: Variable<Y> | Variable<DictType<Y>>;
    color: Color | null;
    tooltip: null;
    view: string;
    size: number | null;
};
/** @internal */
export declare function isRowHexbinSeries(config: Series): config is RowHexbinSeries;
/** @internal */
export declare function asRowHexbinSeries(config: Series): RowHexbinSeries;
/**
 * Defines a {@link RowHexbinSeriesDefinition} to display a hex chart, presenting hexagons to represent value density from {@link View} data.
 *
 * @category Visual
 */
export declare type RowHexbinSeriesDefinition<X extends NumericType = NumericType, Y extends NumericType = NumericType> = {
    /** the {@link SeriesDefinition} type */
    type: 'row_hexbin';
    /** the {@link SeriesDefinition} kind */
    kind: 'row';
    /** the {@link Variable} for the distribution x value */
    x: Variable<X>;
    /** the {@link Variable} for the distribution y value */
    y: Variable<Y>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowKeyColorDefinition;
    /** the hexagon size to apply */
    size?: number;
    /** the {@link View} to display */
    view: View;
} | {
    /** the {@link SeriesDefinition} type */
    type: 'row_hexbin';
    /** the {@link SeriesDefinition} kind */
    kind: 'row';
    /** the {@link Variable} for the distribution x value */
    x: Variable<DictType<X>>;
    /** the {@link Variable} for the distribution y value */
    y: Variable<DictType<Y>>;
    /** the foreground {@link RowColorDefinition} */
    color?: RowColorDefinition;
    /** the hexagon size to apply */
    size?: number;
    /** the {@link View} to display */
    view: View;
};
/**
 * Create a {@link RowHexbinSeries} to display a hex chart, presenting hexagons to represent value density from {@link View} data.
 *
 * @param definition: the desired {@link RowHexbinSeriesDefinition}
 * @returns a valid {@link RowHexbinSeries}
 *
 * @category Visual
 *
 * @example
 * ```typescript
 *  // get a predefined view
 *  import row_view from "./gen/row.view"
 *  import total_view from "./gen/total.view"
 *
 *  // create a hexbin visual
 *  const series = RowHexbinSeries({
 *      view: row_view,
 *      x: row_view.fields.Qty,
 *      y: row_view.fields.Amount,
 *      color: ColorValue(),
 *  })
 * ```
 */
export declare function RowHexbinSeries<X extends NumericType = NumericType, Y extends NumericType = NumericType>(config: Omit<RowHexbinSeriesDefinition<X, Y>, 'kind' | 'type' | 'tooltip'>): RowHexbinSeriesDefinition<X, Y>;
/** @internal */
export declare type RowSeries = RowPivotSeries | RowRidgelineSeries | RowHTMLSeries | RowMarginalSeries | RowHexbinSeries | RowDistributionSeries | RowAreaSeries | RowLineSeries | RowScatterSeries | RowGeoSeries | RowTableSeries | RowListSeries | RowTimelineSeries | RowFormSeries | RowTreeSeries;
/**
 * Defines a {@link RowSeriesDefinition} to display {@link View} data.
 *
 * @category Visual
 */
export declare type RowSeriesDefinition = RowPivotSeriesDefinition | RowRidgelineSeriesDefinition | RowHTMLSeriesDefinition | RowMarginalSeriesDefinition | RowHexbinSeriesDefinition | RowDistributionSeriesDefinition | RowAreaSeriesDefinition | RowTreeSeriesDefinition | RowLineSeriesDefinition | RowScatterSeriesDefinition | RowGeoSeriesDefinition | RowTableSeriesDefinition | RowListSeriesDefinition | RowTimelineSeriesDefinition | RowFormSeriesDefinition;
/** @internal */
export declare type Series = GroupSeries | RowSeries;
/**
 * Defines a {@link RowSeriesDefinition} to display {@link View} data.
 *
 * @category Visual
 */
export declare type SeriesDefinition = GroupSeriesDefinition | RowSeriesDefinition;
/** @internal */
export declare type StackableSeries = GroupBarSeries | GroupColumnSeries | GroupAreaSeries | GroupLineSeries;
/** @internal */
export declare type LayeredSeries = GroupCombinedSeries | GroupRidgelineSeries | GroupLineSeries | GroupAreaSeries | GroupColumnSeries | GroupBarSeries | GroupRangeSeries;
/** @internal */
export declare function toGroupHTMLSeries(def: GroupHTMLSeriesDefinition): GroupHTMLSeries;
/** @internal */
export declare function toGroupFlowSeries<Z extends NumericType = NumericType>(def: GroupFlowSeriesDefinition<Z>): GroupFlowSeries<Z>;
/** @internal */
export declare function toGroupHeatMapSeries<Z extends ContinuousType = ContinuousType>(def: GroupHeatMapSeriesDefinition<Z>): GroupHeatMapSeries<Z>;
/** @internal */
export declare function toGroupPieSeries<Z extends NumericType = NumericType>(def: GroupPieSeriesDefinition<Z>): GroupPieSeries<Z>;
/** @internal */
export declare function toGroupBarSeries<X extends NumericType = NumericType>(def: GroupBarSeriesDefinition<X>): GroupBarSeries<X>;
/** @internal */
export declare function toGroupRangeSeries<X extends NumericType = NumericType>(def: GroupRangeSeriesDefinition<X>): GroupRangeSeries<X>;
/** @internal */
export declare function toGroupColumnSeries<Y extends NumericType = NumericType>(def: GroupColumnSeriesDefinition<Y>): GroupColumnSeries<Y>;
/** @internal */
export declare function toGroupAreaSeries<Y extends NumericType = NumericType>(def: GroupAreaSeriesDefinition<Y>): GroupAreaSeries<Y>;
/** @internal */
export declare function toGroupRidgelineSeries<Z extends NumericType = NumericType>(def: GroupRidgelineSeriesDefinition<Z>): GroupRidgelineSeries<Z>;
/** @internal */
export declare function toGroupLineSeries<Y extends NumericType = NumericType>(def: GroupLineSeriesDefinition<Y>): GroupLineSeries<Y>;
/** @internal */
export declare function toGroupScatterSeries<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType, Z extends NumericType = NumericType>(def: GroupScatterSeriesDefinition<X, Y, Z>): GroupScatterSeries<X, Y, Z>;
/** @internal */
export declare function toGroupTreeMapSeries<Z extends NumericType = NumericType>(def: GroupTreeMapSeriesDefinition<Z>): GroupTreeMapSeries<Z>;
/** @internal */
export declare function toGroupTableColumn(def: GroupTableColumnDefinition, fields: Record<string, Variable>): GroupTableColumn;
/** @internal */
export declare function toGroupTableSeries(def: GroupTableSeriesDefinition): GroupTableSeries;
/** @internal */
export declare function toGroupKPIColumn(def: GroupKPIValueDefinition, fields: Record<string, Variable>): GroupKPIValue;
/** @internal */
export declare function toGroupKPISeries(def: GroupKPISeriesDefinition): GroupKPISeries;
/** @internal */
export declare function toGroupCombinedSeriesLine<Y extends NumericType = NumericType>(def: GroupCombinedSeriesLineDefinition<Y>, fields: Record<string, Variable>): GroupCombinedSeriesLine<Y>;
/** @internal */
export declare function toGroupCombinedSeriesColumn<Y extends NumericType = NumericType>(def: GroupCombinedSeriesColumnDefinition<Y>, fields: Record<string, Variable>): GroupCombinedSeriesColumn<Y>;
/** @internal */
export declare function toGroupCombinedSeries<Y extends NumericType = NumericType>(def: GroupCombinedSeriesDefinition<Y>): GroupCombinedSeries<Y>;
/** @internal */
export declare function toGroupPivotSeries<Z extends PrimitiveType = PrimitiveType>(def: GroupPivotSeriesDefinition<Z>): GroupPivotSeries<Z>;
/** @internal */
export declare function toGroupSeries(def: GroupSeriesDefinition): GroupSeries;
/** @internal */
export declare function toRowTableSeries(def: RowTableSeriesDefinition): RowTableSeries;
/** @internal */
export declare function toRowPivotSeries(def: RowPivotSeriesDefinition): RowPivotSeries;
/** @internal */
export declare function toRowListSeries(def: RowListSeriesDefinition): RowListSeries;
/** @internal */
export declare function toRowTreeSeries(def: RowTreeSeriesDefinition): RowTreeSeries;
/** @internal */
export declare function toRowFormSeries(def: RowFormSeriesDefinition): RowFormSeries;
/** @internal */
export declare function toRowHTMLSeries(def: RowHTMLSeriesDefinition): RowHTMLSeries;
/** @internal */
export declare function toRowTimelineInput(def: RowTimelineInputDefinition, fields: Record<string, Variable<EastType>>): RowTimelineInput;
/** @internal */
export declare function toRowTimelineSeries(def: RowTimelineSeriesDefinition): RowTimelineSeries;
/** @internal */
export declare function toRowGeoSeries(def: RowGeoSeriesDefinition): RowGeoSeries;
/** @internal */
export declare function toRowLineSeries<X extends ContinuousType = ContinuousType>(def: RowLineSeriesDefinition<X>): RowLineSeries<X>;
/** @internal */
export declare function toRowAreaSeries<X extends ContinuousType = ContinuousType>(def: RowAreaSeriesDefinition<X>): RowAreaSeries<X>;
/** @internal */
export declare function toRowScatterSeries<X extends PrimitiveType = PrimitiveType, Y extends PrimitiveType = PrimitiveType>(def: RowScatterSeriesDefinition<X, Y>): RowScatterSeries<X, Y>;
/** @internal */
export declare function toRowRidgelineSeries<X extends ContinuousType = ContinuousType, Z extends NumericType = NumericType>(def: RowRidgelineSeriesDefinition<X, Z>): RowRidgelineSeries<X, Z>;
/** @internal */
export declare function toRowMarginalSeries<X extends PrimitiveType = PrimitiveType>(def: RowMarginalSeriesDefinition<X>): RowMarginalSeries<X>;
/** @internal */
export declare function toRowDistributionSeries(def: RowDistributionSeriesDefinition): RowDistributionSeries;
/** @internal */
export declare function toRowHexbinSeries<X extends NumericType = NumericType, Y extends NumericType = NumericType>(def: RowHexbinSeriesDefinition<X, Y>): RowHexbinSeries<X, Y>;
/** @internal */
export declare function toRowSeries(def: RowSeriesDefinition): RowSeries;
/** @internal */
export declare function toSeries(def: SeriesDefinition): Series;
