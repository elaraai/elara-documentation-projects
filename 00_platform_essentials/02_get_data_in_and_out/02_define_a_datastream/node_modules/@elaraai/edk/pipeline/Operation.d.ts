// Â© Copyright 2018- 2022 - Elara AI Pty Ltd ACN 627 124 903
//
// Licensed under the EDK Licence version LICENSE-1.04.
//
// You may only use this file in accordance with the terms and conditions contained in EDK
// Licence - Version LICENSE-1.04. The full version of the EDK Licence is available at:
// https://elaraai.github.io/docs/license

import { Table } from '../data/Table';
import { RestApiRequest, RestApiRequestDefinition, RestApiResponse, RestApiResponseDefinition } from '../datasource/DataSource';
import { Aggregation, AggregationDefinition } from '../east/aggregation';
import { Expression } from '../east/definition';
import { EastFunction, Variable } from '../east/functions';
import { ArrayType, DictType, EastType, PrimitiveType, StructType } from '../east/types';
import { DistributionType, NormalizationType } from '../page/Series';
/** @internal */
export interface SelectOperation {
    type: "select";
    output_table?: Table;
    selections: Record<string, EastFunction>;
    primary_key: EastFunction<"string">;
    logging: boolean;
}
/**
 * Defines a {@link SelectOperationDefinition} to select {@link Expression}'s from a {@link Table}.
 *
 * @category Operation
 */
export declare type SelectOperationDefinition = {
    /** @internal */
    type: "select";
    /** the {@link Expression}'s to 'Select' */
    selections: Record<string, Expression>;
    /** true if all other {@link Table}  {@link Expression}'s should be kept */
    keep_all?: boolean;
    /** the {@link Expression} key that evaluates to a unique value */
    primary_key?: Expression<"string">;
};
/**
 * Create a {@link SelectOperation} to select {@link Expression}'s from a {@link Table}.
 *
 * @param definition: the desired {@link SelectOperationDefinition}
 * @returns a valid {@link SelectOperation}
 *
 * @category Operation
 *
 * @example
 *  ```typescript
 *  // get a predefined pipeline table
 *  import sales from "./gen/sales.pipeline"
 *
 *  const table = sales.output_table;
 *
 * //To keep existing `Expression` values for a {@link Table}, and create a new date variable as a function of said `Expression`'s.
 *  const select = SelectOperation({
 *      keep_all: true,
 *      selections: {
 *          NewDate: AddDuration(table.fields.Date, 2, 'day')
 *      },
 *  })
 * ```
 */
export declare function SelectOperation(def: Omit<SelectOperationDefinition, 'type'>): SelectOperationDefinition;
/** @internal */
export interface FilterOperation {
    type: "filter";
    output_table?: Table;
    predicate: EastFunction<"boolean">;
    logging: boolean;
}
/**
 * Create a {@link FilterOperationDefinition} to filter {@link Value}'s from a {@link Table} by an {@link Expression}.
 *
 * @category Operation
 */
export declare type FilterOperationDefinition = {
    /** @internal */
    type: "filter";
    /** evaluate to false to exclude a {@link Row} in the output */
    predicate: Expression<"boolean">;
};
/**
 * Create a {@link FilterOperation} to filter {@link Value}'s from a {@link Table} by an {@link Expression}.
 *
 * @param definition the desired {@link FilterOperationDefinition}
 * @returns a valid {@link FilterOperation}
 *
 * @category Operation
 *
 * @example
 *  ```typescript
 *  // get a predefined pipeline table
 *  import sales from "./gen/sales.pipeline"
 *
 *  const table = sales.output_table;
 *
 * //Create a `FilterOperation` to filter out {@link Row}'s where the date isn't a weekday.
 * const filter = FilterOperation({
 *      predicate: IsWeekday(table.fields.Date)
 * })
 * ```
 */
export declare function FilterOperation(def: Omit<FilterOperationDefinition, 'type'>): FilterOperationDefinition;
/**
 * A type of relational join operation to apply in a {@link JoinOperation}.
 *
 * @category Operation
 */
export declare type JoinType = "Inner" | "Left" | "Right" | "Full" | "Fuzzy";
/** @internal */
export interface JoinOperation {
    type: "join";
    output_table?: Table;
    source_table: string;
    logging: boolean;
    source_key: EastFunction<"string">;
    target_key: EastFunction<"string">;
    source_selections: Record<string, EastFunction>;
    target_selections: Record<string, EastFunction>;
    output_key: EastFunction<"string">;
    join_type: JoinType;
    fuzzy_source_key?: EastFunction<"string">;
    fuzzy_target_key?: EastFunction<"string">;
    threshold?: number;
}
/**
 * Defines a join of a source {@link Table} into the target {@link Table} with a relational join.
 *
 * @category Operation
 */
export declare type JoinOperationDefinition = {
    /** @internal */
    type: 'join';
    /** the {@link Table} to join into the target */
    source_table: Table;
    /** the {@link Expression} defining the source join key */
    source_key: Expression<"string">;
    /** the {@link Expression} defining the target join key */
    target_key: Expression<"string">;
    /** the {@link Expression}'s to select from the source */
    source_selections?: Record<string, Expression>;
    /** the {@link Expression}'s to select from the target */
    target_selections?: Record<string, Expression>;
    /** true if all other source {@link Table} {@link Expression}'s should be kept */
    source_keep_all?: boolean;
    /** true if all other target {@link Table} {@link Expression}'s should be kept */
    target_keep_all?: boolean;
    /** the {@link Expression} key that evaluates to a unique value */
    output_key?: Expression<"string">;
    /** @internal */
    fuzzy_source_key?: Expression<"string">;
    /** @internal */
    fuzzy_target_key?: Expression<"string">;
    /** @internal */
    threshold?: number;
    /** the type of {@link JoinType} to apply */
    join_type?: JoinType;
};
/**
 * Create a join of a source {@link Table} into the target {@link Table} with a relational join.
 *
 * @param definition: the desired {@link JoinOperationDefinition}
 * @returns a valid {@link JoinOperation}
 *
 * @category Operation
 *
 * @example
 *  ```typescript
 * //Create a `JoinOperation` to Left Join a source {@link Table} into the target {@link Table} based on an integer key.
 * const join = JoinOperation({
 *     source_table: other_table,
 *     source_key: Print(Variable('source_key', 'integer')),
 *     target_key: Print(Variable('target_key', 'integer')),
 *     source_selections: {
 *         string: test_two.output.fields.string,
 *         date: test_two.output.fields.date,
 *         number: test_two.output.fields.number,
 *         integer: test_two.output.fields.integer,
 *     },
 *     target_selections: {
 *         object: test_one.output.fields.object,
 *     },
 *     join_type: 'Inner',
 *     output_key: ELARA.Variable("string", 'string')
 * })
 * ```
 */
export declare function JoinOperation(def: Omit<JoinOperationDefinition, 'type'>): JoinOperationDefinition;
/** @internal */
export interface HttpOperation {
    type: "http";
    output_table?: Table;
    identifier_variable: Variable<'string'>;
    request: RestApiRequest;
    response?: RestApiResponse<StructType>;
    logging: boolean;
}
/**
 * Defines a {@link HttpOperationDefinition} to perform an authenticated http query based on target rows, and produce selections from response.
 *
 * @category Operation
 */
export declare type HttpOperationDefinition = {
    /** @internal */
    type: "http";
    /** the {@link Variable} to place the identifier */
    identifier_variable?: Variable<'string'>;
    /** the {@link RestApiRequest} to perform */
    request: Omit<RestApiRequestDefinition, 'paginate' | 'n_pages_variable'>;
    /** the {@link RestApiResponse} to produce a {@link StructType} */
    response?: RestApiResponseDefinition<StructType>;
};
/**
 * Create a {@link HttpOperation} to perform an authenticated http query based on target rows, and produce selections from response.
 *
 * @param definition: the desired {@link HttpOperationDefinition}
 * @returns a valid {@link HttpOperation}
 *
 * @category Operation
 *
 * @example
 *  ```typescript
 *  // get a predefined pipeline table
 *  import sales from "./gen/sales.pipeline"
 *
 *  const table = sales.output_table;
 *
 *  // create a sales promotion response body type
 *  const response_body_type = StructType({
 *      id: 'string',
 *      promotion: StructType({
 *          name: 'string',
 *          discount: 'float',
 *          products: 'set'
 *      }),
 *      channel: StructType({
 *          name: 'string',
 *          total: 'float',
 *      }),
 *  });
 *
 *  // create a sales promotion request response header type
 *  const response_header_type = StructType({
 *      server: 'string',
 *      connection: 'string',
 *      // ...
 *      etag: 'string',
 *  });
 *
 *  // query some details for each sale with some key value authentication
 *  const element = HttpOperation({
 *      request: RestApiRequest({
 *          url: StringJoin`https://api.com/sales/${sales.fields.Id}/detail`,
 *          method: 'GET',
 *          accept: 'application/json',
 *          headers: Struct({
 *              Accept: Const("application/vnd.github.v3+json"),
 *              Authorization: StringJoin`Bearer ${Base64ToHex(Environment("AUTH_KEY"))}`,
 *          }),
 *      },
 *      response: RestApiResponse({
 *          headers: Parse(Variable("headers", response_header_type)),
 *          headers_variable: Variable("headers", response_header_type),
 *          body: Parse(Variable("body", response_body_type)),
 *          body_variable: Variable("body", response_body_type),
 *          value: Variable("body", response_body_type),
 *      }),
 * })
 * ```
 */
export declare function HttpOperation(def: Omit<HttpOperationDefinition, 'type'>): HttpOperationDefinition;
/** @internal */
export interface DisaggregateOperation {
    type: "disaggregate";
    output_table?: Table;
    logging: boolean;
    collection: EastFunction<"set" | ArrayType | DictType>;
    value: Variable;
    key?: Variable;
    selections: Record<string, EastFunction>;
    primary_key: EastFunction<"string">;
}
/**
 * Defines a {@link DisaggregateOperation} of a 'set' collection within a {@link Table} {@link Row} into multiple {@link Row}'s.
 *
 * @category Operation
 */
export declare type SetDisaggregateOperationDefinition = {
    /** @internal */
    type: "disaggregate";
    /** the {@link Expression} defining the collection */
    collection: Expression<"set">;
    /** the {@link Variable} defining the {@link Value} */
    value: Variable<"string">;
    /** @internal */
    key?: undefined;
    /** the {@link Expression}'s to select from the target */
    selections: Record<string, Expression>;
    /** true if all other target {@link Table} {@link Expression}'s should be kept */
    keep_all?: boolean;
    /** the {@link Expression} key that evaluates to a unique value */
    primary_key: Expression<"string">;
};
/**
 * Defines a {@link DisaggregateOperation} of a {@link ArrayType} collection within a {@link Table} {@link Row} into multiple {@link Row}'s.
 *
 * @category Operation
 */
export declare type ArrayDisaggregateOperationDefinition<T extends EastType> = {
    /** @internal */
    type: "disaggregate";
    /** the {@link Expression} defining the collection */
    collection: Expression<ArrayType<T>>;
    /** the {@link Variable} defining the {@link Value} */
    value: Variable<T>;
    /** the {@link Variable} defining the indexd in the array */
    key?: Variable<"integer">;
    /** the {@link Expression}'s to select from the target */
    selections: Record<string, Expression>;
    /** true if all other target {@link Table} {@link Expression}'s should be kept */
    keep_all?: boolean;
    /** the {@link Expression} key that evaluates to a unique value */
    primary_key: Expression<"string">;
};
/**
 * Defines a {@link DisaggregateOperation} of a {@link DictType} collection within a {@link Table} {@link Row} into multiple {@link Row}'s.
 *
 * @category Operation
 */
export declare type DictDisaggregateOperationDefinition<T extends EastType> = {
    /** @internal */
    type: "disaggregate";
    /** the {@link Expression} defining the collection */
    collection: Expression<DictType<T>>;
    /** the {@link Variable} defining the {@link Value} */
    value: Variable<T>;
    /** the {@link Variable} defining the dictionary key */
    key?: Variable<"string">;
    /** the {@link Expression}'s to select from the target */
    selections: Record<string, Expression>;
    /** true if all other target {@link Table} {@link Expression}'s should be kept */
    keep_all?: boolean;
    /** the {@link Expression} key that evaluates to a unique value */
    primary_key: Expression<"string">;
};
/** @internal */
export declare type DisaggregateOperationDefinition = SetDisaggregateOperationDefinition | ArrayDisaggregateOperationDefinition<EastType> | DictDisaggregateOperationDefinition<EastType>;
/**
 * Creates a {@link DisaggregateOperation} of a 'set' collection within a {@link Table} {@link Row} into multiple {@link Row}'s.
 *
 * @param definition: the desired {@link SetDisaggregateOperationDefinition}
 * @returns a valid {@link DisaggregateOperation}
 *
 * @category Operation
 *
 * @example
 * ```typescript
 *  // get a predefined pipeline table
 *  import sales from "./gen/sales.pipeline"
 *
 *  const table = sales.output_table;
 *  //Create a `DisaggregateOperation` for a set.
 *  const disaggregate = DisaggregateOperation({
 *      // dissaggregate an array of tags
 *      collection: sales.fields.tags,
 *      // each dict value will populate a discount code variable
 *      value: Variable('Tag', 'string'),
 *      // get the tag from each sale
 *      selections: {
 *          Tag: Variable('Tag', 'string'),
 *      },
 *      // keep all original variables from the sale
 *      keep_all: true,
 *      // the primary key must be unique, combine the unique sale id with unique set value
 *      primary_key: StringJoin`${sales.fields.id}.${Variable('Tag', 'string')}`
 *  })
 * ```
 */
export declare function DisaggregateOperation(def: Omit<SetDisaggregateOperationDefinition, 'type'>): SetDisaggregateOperationDefinition;
/**
 * Creates a {@link DisaggregateOperation} of a {@link ArrayType} collection within a {@link Table} {@link Row} into multiple {@link Row}'s.
 *
 * @param definition: the desired {@link ArrayDisaggregateOperationDefinition}
 * @returns a valid {@link DisaggregateOperation}
 *
 * @category Operation
 *
 * @example
 * ```typescript
 *  // get a predefined pipeline table
 *  import sales from "./gen/sales.pipeline"
 *
 *  const table = sales.output_table;
 *
 *  const discount_code_type = StructType({ code: string, discount: number })
 *
 *  //Create a `DisaggregateOperation` for an array.
 *  const disaggregate = DisaggregateOperation({
 *      // dissaggregate an array of discount codes and amounts
 *      collection: sales.fields.discount_codes,
 *      // each dict value will populate a discount code variable
 *      value: Variable('DiscountCode', discount_code_type),
 *      // each array value will have in index
 *      key: Variable('Index', 'integer'),
 *      // seperate the discount code and amount from each value, and record the index
 *      selections: {
 *          Code: GetField(Variable('DiscountCode', discount_code_type), 'code'),
 *          Discount: GetField(Variable('DiscountCode', discount_code_type), 'discount'),
 *          Index: Variable('Index', 'integer'),
 *      },
 *      // keep all original variables from the sale
 *      keep_all: true,
 *      // the primary key must be unique, combine the unique sale id with each product variant
 *      primary_key: StringJoin`${sales.fields.id}.${Variable('Index', 'integer')}`
 *  })
 * ```
 */
export declare function DisaggregateOperation<T extends EastType>(def: Omit<ArrayDisaggregateOperationDefinition<T>, 'type'>): ArrayDisaggregateOperationDefinition<T>;
/**
 * Creates a {@link DisaggregateOperation} of a {@link DictType} collection within a {@link Table} {@link Row} into multiple {@link Row}'s.
 *
 * @param definition: the desired {@link DictDisaggregateOperationDefinition}
 * @returns a valid {@link DisaggregateOperation}
 *
 * @category Operation
 *
 * @example
 * ```typescript
 *  // get a predefined pipeline table
 *  import sales from "./gen/sales.pipeline"
 *
 *  const table = sales.output_table;
 *  //Create a `DisaggregateOperation` for a dict.
 *  const disaggregate = DisaggregateOperation({
 *      // dissaggregate a rate card number dictionary of product variant to rate into seperate rows
 *      collection: sales.fields.price_card,
 *      // each dict value will populate a rate variable
 *      value: Variable('Rate', 'float'),
 *      // each dict key will populate a variant variable
 *      key: Variable('Variant', 'string'),
 *      selections: {
 *          Rate: Variable('Rate', 'float'),
 *          Variant: Variable('Variant', 'string'),
 *      },
 *      // keep all original variables from the sale
 *      keep_all: true,
 *      // the primary key must be unique, combine the unique sale id with each product variant
 *      primary_key: StringJoin`${sales.fields.id}.${Variable('Variant', 'string')}`
 *  })
 * ```
 */
export declare function DisaggregateOperation<T extends EastType>(def: Omit<DictDisaggregateOperationDefinition<T>, 'type'>): DictDisaggregateOperationDefinition<T>;
/** @internal */
export interface AggregateOperation {
    type: "aggregate";
    output_table?: Table;
    logging: boolean;
    group_field: Variable<PrimitiveType>;
    group_value: EastFunction<PrimitiveType>;
    aggregations: Record<string, Aggregation>;
}
/**
 * Defines an {@link AggregateOperationDefinition} to aggregate (or group) a {@link Table} {@link Row} into fewer {@link Row}'s based on a {@link Expression}.
 *
 * @category Operation
 */
export declare type AggregateOperationDefinition = {
    /** @internal */
    type: "aggregate";
    /** the {@link Variable} defining the output group */
    group_field: string | Variable<PrimitiveType>;
    /** the {@link Expression} defining the group value */
    group_value: Expression<PrimitiveType>;
    /** the {@link AggregationDefinition}'s to generate within each group */
    aggregations?: Record<string, AggregationDefinition>;
};
/**
 * Create an {@link AggregateOperation} to aggregate (or group) a {@link Table} {@link Row} into fewer {@link Row}'s based on a {@link Expression}.
 *
 * @param definition: the desired {@link AggregateOperationDefinition}
 * @returns a valid {@link AggregateOperation}
 *
 * @category Operation
 *
 * @example
 * ```typescript
 *  // get a predefined pipeline table
 *  import sales from "./gen/sales.pipeline"
 *
 *  const table = sales.output_table;
 *  //Create a `AggregateOperation` to calculate the total sales and average of product categorys every week day.
 *  const aggregate = AggregateOperation({
 *      // the group value will be placed in the "Group" variable
 *      group_field: Variable('Group', 'string'),
 *      // group the input by day of week and product category
 *      group_value: StringJoin`${DayofWeek(sales.fields.Date)}.${sales.fields.Category}`,
 *      // get the tag from each sale
 *      aggregations: {
 *          // the day will be unique since its part of the key
 *          Day: Unique(DayofWeek(sales.fields.Date)),
 *          // the category will be unique since its part of the key
 *          Category: Unique(sales.fields.Category),
 *          // sum the sales within each key
 *          TotalSales: Sum(sales.fields.Amount),
 *          // get the average sales within each key
 *          AvgSales: Mean(sales.fields.Amount),
 *      },
 *  })
 * ```
 */ export declare function AggregateOperation(def: Omit<AggregateOperationDefinition, 'type'>): AggregateOperationDefinition;
/** @internal */
export interface OffsetOperation {
    type: "offset";
    output_table?: Table;
    logging: boolean;
    group_key: EastFunction<"string" | "boolean" | "float" | "integer">;
    sort_key: EastFunction<PrimitiveType>;
    offset: number;
    offset_exists?: Variable<"boolean"> | undefined;
    offset_selections: Record<string, EastFunction>;
}
/**
 * Defines an {@link OffsetOperationDefinition} to select data from neighboring {@link Row}s of a {@link Table}, sorted according to a specified sort key (and optionally partitioned into seperate groups via a group key).
 *
 * @category Operation
 */
export declare type OffsetOperationDefinition = {
    /** @internal */
    type: "offset";
    /** an optional {@link Expression} defining the group key */
    group_key?: EastFunction<PrimitiveType>;
    /** an {@link Expression} defining the sort key */
    sort_key: EastFunction<PrimitiveType>;
    /** the offset to the row requested, e.g. `1` or `-1` indicates the next or previous row (respectively) according to `sort_key` */
    offset: number;
    /** an optional boolean {@link Variable} indicating if the offset row exists within the group, which for example may be `false` for the first or last row. */
    offset_exists?: Variable<"boolean">;
    /** the {@link Expression}'s to select from the offset row */
    offset_selections: Record<string, Expression>;
};
/**
 * Create an {@link OffsetOperation} to select data from neighboring {@link Row}s of a {@link Table}, sorted according to a specified sort key (and optionally partitioned into seperate groups via a group key).
 *
 * @param definition: the desired {@link OffsetOperationDefinition}
 * @returns a valid {@link OffsetOperation}
 *
 * @category Operation
 *
 * @example
 * ```typescript
 * // Get a predefined pipeline table
 * import shifts from "./gen/shifts.pipeline"
 *
 * const table = shifts.output_table;
 * // Create an `OffsetOperation` to find the previous shift done by each employee
 * OffsetOperation({
 *     offset: -1,
 *     group_key: Variable('EmployeeId', 'string'),
 *     sort_key: Variable('ShiftDate, 'datetime'),
 *     offset_exists: Variable("PreviousShiftExists", "boolean"),
 *     offset_selections: {
 *         PreviousShiftExists: Variable("PreviousShiftExists", "boolean"),
 *         PreviousShiftId: Variable('PreviousShiftId, 'string'),
 *     },
 * })
 *
 * ```
 */
export declare function OffsetOperation(def: Omit<OffsetOperationDefinition, 'type'>): OffsetOperationDefinition;
/** @internal */
export interface DistributionOperation {
    type: "distribution";
    output_table?: Table;
    logging: boolean;
    group_key?: EastFunction<"string" | "boolean" | "float" | "integer"> | undefined;
    distribution: DistributionType;
    normalization: NormalizationType;
    samples: EastFunction<'float'>;
    group?: Variable<"string" | "boolean" | "float" | "integer"> | undefined;
    value: Variable<'float'>;
    probability: Variable<'float'>;
    bin: Variable<'integer'>;
    minimum?: number | undefined;
    n_bins?: bigint | undefined;
    step?: number | undefined;
}
/**
 * Defines an {@link DistributionOperationDefinition} to calculate the probability distributions for samples in {@link Row}s within a {@link Table}, based on a group key.
 *
 * @category Operation
 */
export declare type DistributionOperationDefinition = {
    /** @internal */
    type: "distribution";
    /** the function for the samples */
    samples: EastFunction<'float'>;
    /** an optional {@link Expression} defining the group key */
    group_key?: Expression<"string" | "boolean" | "float" | "integer">;
    /** the {@link DistributionType} to apply */
    distribution?: DistributionType;
    /** the {@link NormalizationType} to apply in the distribution */
    normalization?: NormalizationType;
    /** the variable to place the group into */
    group?: Variable<"string" | "boolean" | "float" | "integer">;
    /** the variable to place the values into */
    value?: Variable<'float'>;
    /** the variable to place the proabilities into */
    probability?: Variable<'float'>;
    /** the variable to place the bin number into */
    bin?: Variable<'integer'>;
    /** the minimum value to consider in the distribution */
    minimum?: number;
    /** the numbe rof bins in the histogram */
    n_bins?: bigint;
    /** the histogram step size to apply */
    step?: number;
};
/**
 * Create an {@link DistributionOperation} to calculate the probability distributions for samples in {@link Row}s within a {@link Table}, based on a group key.
 *
 * @param definition: the desired {@link DistributionOperationDefinition}
 * @returns a valid {@link DistributionOperation}
 *
 * @category Operation
 *
 * @example
 * ```typescript
 *  // Get a predefined pipeline table
 *  import shifts from "./gen/shifts.pipeline"
 *
 *  const table = shifts.output_table;
 *  // Create an `DistributionOperation` to find the distribtion of hours per employee
 *  const dist = DistributionOperation({
 *      samples: test_one.output.fields.number,
 *      group_key: test_one.output.fields.string,
 *      distribution: 'GaussianKDE',
 *      normalization: 'ProbabilityDensity'
 *  })
 * ```
 */
export declare function DistributionOperation(def: Omit<DistributionOperationDefinition, 'type'>): DistributionOperationDefinition;
/** @internal */
export declare type Operation = DistributionOperation | SelectOperation | FilterOperation | DisaggregateOperation | AggregateOperation | HttpOperation | JoinOperation | OffsetOperation;
/**
 * Defines an {@link OperationDefinition} to perform operations to {@link Row}'s based on {@link Expression}'s'.
 *
 * @category Operation
 */
export declare type OperationDefinition = DistributionOperationDefinition | SelectOperationDefinition | FilterOperationDefinition | JoinOperationDefinition | DisaggregateOperationDefinition | AggregateOperationDefinition | HttpOperationDefinition | OffsetOperationDefinition;
/** @internal */
export declare function toOperation(in_key: EastFunction<"string">, in_fields: Record<string, Variable>, def: OperationDefinition, logging: boolean): [op: Operation, primary_key: EastFunction<"string">, fields: Record<string, Variable>, logging: boolean];
