// Â© Copyright 2018- 2022 - Elara AI Pty Ltd ACN 627 124 903
//
// Licensed under the EDK Licence version LICENSE-1.04.
//
// You may only use this file in accordance with the terms and conditions contained in EDK
// Licence - Version LICENSE-1.04. The full version of the EDK Licence is available at:
// https://elaraai.github.io/docs/license

/**
 * A subset of {@link EastValue} relating to primitive values.
 *
 * @category Type
 */
export declare type PrimitiveValue = null | string | number | boolean | bigint | Date;
/**
 * A subset of {@link EastValue} relating to numeric values.
 *
 * @category Type
 */
export declare type NumericValue = number | bigint;
/**
 * An {@link ArrayValue}
 *
 * @category Type
 */
export declare type ArrayValue = Value[];
/**
 * A {@link SetValue}
 *
 * @category Type
 */
export declare type SetValue = Set<string>;
/**
 * A {@link DictValue}
 *
 * @category Type
 */
export declare type DictValue = Map<string, Value>;
export declare const __variants: unique symbol;
export declare type __variants = typeof __variants;
/**
 * A {@link VariantValue}
 *
 * @category Type
 */
export declare type VariantValue = {
    [__variants]: Record<string, EastType>;
    type: string;
    value: Value;
};
/**
 * Construct a {@link VariantValue} with the given tag and value.
 *
 * @category Type
 *
 * @param variants A record matching variant tags to associated East data types
 * @param type A "tag" string identifying which variant this value is
 * @param value The data assocated with this variant (if required)
 *
 * @example
 * ```ts
 * let prices: number[] // a list of historical prices
 *
 * // ...
 * // Find the average price, if any are known
 * AveragePrice: prices.length > 0 ?
 *     Variant({ Some: "float", None: "null" }, "Some", prices.reduce((x,y) => x+y) / prices.length) :
 *     Variant({ Some: "float", None: "null" }, "None")
 * // ...
 * ```
 */
export declare function Variant<Variants extends Record<string, EastType>, Tag extends {
    [K in keyof Variants]: Variants[K] extends "null" ? K : never;
}[keyof Variants]>(variants: Variants, type: Tag): {
    [__variants]: Variants;
    type: Tag;
    value: null;
};
/**
 * Construct a {@link VariantValue} with the given tag and a `null` value.
 *
 * @category Type
 *
 * @param variants A record matching variant tags to associated East data types
 * @param type A "tag" string identifying which variant this value is
 *
 * @example
 * ```ts
 * let prices: number[] // a list of historical prices
 *
 * // ...
 * // Find the average price, if any are known
 * AveragePrice: prices.length > 0 ?
 *     Variant({ Some: "float", None: "null" }, "Some", prices.reduce((x,y) => x+y) / prices.length) :
 *     Variant({ Some: "float", None: "null" }, "None")
 * // ...
 * ```
 */
export declare function Variant<Variants extends Record<string, EastType>, Tag extends keyof Variants>(variants: Variants, type: Tag, value: ValueTypeOf<Variants[Tag]>): {
    [__variants]: Variants;
    type: Tag;
    value: ValueTypeOf<Variants[Tag]>;
};
/**
 * Return a helper function that constructs {@link VariantValue}s with the given tag and (optional) value.
 *
 * @category Type
 *
 * @param variants A record matching variant tags to associated East data types
 *
 * @example
 * ```ts
 * let prices: number[] // a list of historical prices
 * const Maybe = Variant({ Some: "float", None: "null" })
 *
 * // ...
 * // Find the average price, if any are known
 * AveragePrice: prices.length > 0 ?
 *     Maybe("Some", prices.reduce((x,y) => x+y) / prices.length) :
 *     Maybe("None")
 * // ...
 * ```
 */
export declare function Variant<Variants extends Record<string, EastType>>(variants: Variants): (<Tag extends keyof Variants>(type: Tag, value: ValueTypeOf<Variants[Tag]>) => {
    [__variants]: Variants;
    type: Tag;
    value: ValueTypeOf<Variants[Tag]>;
}) & (<Tag extends {
    [K in keyof Variants]: Variants[K] extends "null" ? K : never;
}[keyof Variants]>(type: Tag) => {
    [__variants]: Variants;
    type: Tag;
    value: null;
});
/**
 * A {@link StructValue}
 *
 * @category Type
 */
export declare type StructValue = {
    [key: string]: Value;
};
/**
 * A {@link Value}
 *
 * @category Type
 */
export declare type Value = PrimitiveValue | ArrayValue | SetValue | DictValue | VariantValue | StructValue;
/**
 * A subset of {@link EastType} relating to numeric values.
 *
 * @category Type
 */
export declare type NumericType = "float" | "integer";
/**
 * A subset of {@link EastType} relating to primitive values.
 *
 * @category Type
 */
export declare type PrimitiveType = "null" | "boolean" | "string" | "float" | "integer" | "datetime";
/**
 * A set of strings
 *
 * @category Type
 */
export declare type SetType = "set";
/**
 * A 0-indexed array of {@link EastType}
 *
 * @category Type
 */
export declare type ArrayType<T extends EastType = EastType> = {
    type: "array";
    values: T;
};
/**
 * A string key map of {@link EastType}
 *
 * @category Type
 */
export declare type DictType<T extends EastType = EastType> = {
    type: "dict";
    values: T;
};
/**
 * An object of {@link EastType}
 *
 * @category Type
 */
export declare type VariantType<T extends Record<string, EastType> = Record<string, EastType>> = {
    type: "variant";
    tags: T;
};
/**
 * An object of {@link EastType}
 *
 * @category Type
 */
export declare type StructType<T extends Record<string, EastType> = Record<string, EastType>> = {
    type: "struct";
    fields: T;
};
/**
 * An {@link Expression} type
 *
 * @category Type
 */
export declare type EastType = PrimitiveType | SetType | {
    type: "array";
    values: EastType;
} | {
    type: "dict";
    values: EastType;
} | {
    type: "variant";
    tags: Record<string, EastType>;
} | {
    type: "struct";
    fields: Record<string, EastType>;
};
/** @internal */
export declare type JsonValue = string | number | boolean | JsonValue[] | {
    [key: string]: JsonValue;
};
/**
 * A subset of {@link EastType} relating to JSON data.
 *
 * @category Type
 *
 */
export declare type JsonType = "boolean" | "string" | "float" | {
    type: "array";
    values: JsonType;
} | {
    type: "struct";
    fields: Record<string, JsonType>;
};
/** @internal */
export declare function isNumericType(type: EastType): type is NumericType;
/** @internal */
export declare function isPrimitiveType(type: EastType): type is PrimitiveType;
/** Return the `EastType` for an array with the given element type. */
/** @internal */
export declare function ArrayType<T extends EastType>(value_type: T): ArrayType<T>;
/** @internal */
export declare function isArrayType(type: EastType): type is ArrayType;
/** Return the `EastType` for a dictionary with the given element type. */
/** @internal */
export declare function DictType<T extends EastType>(value_type: T): DictType<T>;
/** @internal */
export declare function isDictType(type: EastType): type is DictType;
/** Return the `EastType` for a union with the given tags and associated types. */
/** @internal */
export declare function VariantType<T extends Record<string, EastType>>(tag_types: T): VariantType<T>;
/** @internal */
export declare function isVariantType(type: EastType): type is VariantType;
/** Return the `EastType` for a struct with the given field types. */
/** @internal */
export declare function StructType<T extends Record<string, EastType>>(field_types: T): StructType<T>;
/** @internal */
export declare function isStructType(type: EastType): type is StructType;
/** @internal */
export declare function isPrimitiveValue(value: Value): value is PrimitiveValue;
/** @internal */
export declare function isArrayValue(value: Value): value is ArrayValue;
/** @internal */
export declare function isDictValue(value: Value): value is DictValue;
/** @internal */
export declare function isVariantValue(value: Value): value is VariantValue;
/** @internal */
export declare function isStructValue(value: Value): value is StructValue;
/** @internal */
export declare type ValueTypeOf<T> = T extends "null" ? null : T extends "boolean" ? boolean : T extends "string" ? string : T extends "float" ? number : T extends "integer" ? bigint : T extends "datetime" ? Date : T extends "set" ? Set<string> : T extends {
    type: "array";
    values: infer U;
} ? ValueTypeOf<U>[] : T extends {
    type: "dict";
    values: infer U;
} ? Map<string, ValueTypeOf<U>> : T extends {
    type: "variant";
    tags: infer U;
} ? {
    [K in keyof U]: {
        [__variants]: U;
        type: K;
        value: ValueTypeOf<U[K]>;
    };
}[keyof U] : T extends {
    type: "struct";
    fields: infer U;
} ? {
    [K in keyof U]: ValueTypeOf<U[K]>;
} : never;
/** @internal */
export declare type ArrayOf<T extends Value> = T extends (infer U)[] ? U : never;
/** @internal */
export declare type MapOf<T extends Value> = T extends Map<string, infer U> ? U : never;
/** @internal */
export declare type EastTypeOf<T extends Value> = T extends null ? "null" : T extends boolean ? "boolean" : T extends string ? "string" : T extends number ? "float" : T extends bigint ? "integer" : T extends Date ? "datetime" : T extends Set<string> ? "set" : T extends Value[] ? {
    type: "array";
    values: EastTypeOf<ArrayOf<T>>;
} : T extends Map<string, Value> ? {
    type: "dict";
    values: EastTypeOf<MapOf<T>>;
} : T extends {
    [__variants]: infer U;
    type: string;
    value: Value;
} ? {
    type: "variant";
    tags: U;
} : T extends {
    [key: string]: Value;
} ? {
    type: "struct";
    fields: {
        [K in keyof T]: EastTypeOf<T[K]>;
    };
} : never;
/** @internal */
export declare function EastType<T extends Value>(x: T): EastTypeOf<T>;
/** @internal */
export declare type ArrayValuesOf<T extends EastType> = T extends {
    type: "array";
    values: infer U;
} ? U : never;
/** @internal */
export declare function ArrayValueType<T extends Value>(array: T[]): EastTypeOf<T>;
/** @internal */
export declare type DictValuesOf<T extends EastType> = T extends {
    type: "dict";
    values: infer U;
} ? U : never;
/** @internal */
export declare function MapValueType<T extends Value>(map: Map<"string", T>): EastTypeOf<T>;
/** @internal */
export declare function eastTypeEqual(t1: EastType, t2: EastType): boolean;
