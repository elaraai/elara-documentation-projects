// Â© Copyright 2018- 2022 - Elara AI Pty Ltd ACN 627 124 903
//
// Licensed under the EDK Licence version LICENSE-1.04.
//
// You may only use this file in accordance with the terms and conditions contained in EDK
// Licence - Version LICENSE-1.04. The full version of the EDK Licence is available at:
// https://elaraai.github.io/docs/license

import { MergeTypes } from '../utils/types';
import type { AddDurationFunction, AddFunction, AndFunction, ArrayParseSchema, AsciiToBase64Function, Base64ToAsciiFunction, Base64ToHexFunction, CalendarUnit, ConstFunction, ConvertFunction, DayOfMonthFunction, DayOfWeekFunction, DeleteFunction, DictParseSchema, DivideFunction, DurationFunction, EastFunction, EnvironmentFunction, EqualFunction, FilterFunction, FromJsonFunction, GetFieldFunction, GetFunction, GreaterEqualFunction, GreaterFunction, HashFunction, HashType, HexToBase64Function, HMACFunction, HourFunction, IfElseFunction, InFunction, InsertFunction, IntersectFunction, KeysFunction, LessEqualFunction, LessFunction, LetFunction, MapValuesFunction, MillisecondFunction, MinuteFunction, ModuloFunction, MonthFunction, MultiplyFunction, NewArrayFunction, NewDictFunction, NewSetFunction, NewVariantFunction, NotEqualFunction, NotFunction, OnlyKeyFunction, OrFunction, ParseFunction, ParseSchema, RangeFunction, ReduceFunction, RegexContainsFunction, RegexReplaceFunction, RoundFunction, RoundingMode, SecondFunction, SetDiffFunction, SetParseSchema, SizeFunction, SortFunction, SqrtFunction, StringJoinFunction, StructFunction, StructParseSchema, SubsetEqualFunction, SubstringFunction, SubtractDurationFunction, SubtractFunction, SymDiffFunction, TimeUnit, TimeZoneConvertFunction, ToArrayFunction, ToDateTimeFunction, ToDictFunction, ToJsonFunction, ToSetFunction, UnionFunction, URIDecodeFunction, URIEncodeFunction, YearFunction } from './functions';
import { ExpFunction, LogFunction, LowerCaseFunction, PowFunction, UpperCaseFunction, Variable } from './functions';
import { ArrayOf, ArrayType, DictType, EastType, EastTypeOf, MapOf, PrimitiveType, StructType, Value, ValueTypeOf, VariantType } from './types';
/**
 * An {@link Expression} may either be a {@link Value} or {@link EastFunction}
 *
 * @category Type
 *
 */
export declare type Expression<T extends EastType = EastType> = ValueTypeOf<T> | EastFunction<T>;
/** @internal */
export declare type ExpressionTypeOf<T extends Expression> = T extends boolean ? "boolean" : T extends string ? "string" : T extends number ? "float" : T extends bigint ? "integer" : T extends Date ? "datetime" : T extends Set<string> ? "set" : T extends Map<string, Value> ? {
    type: "dict";
    values: EastTypeOf<MapOf<T>>;
} : T extends {
    ast_type: string;
    type: infer U;
} ? U : T extends {
    [key: string]: Value;
} ? {
    type: "struct";
    fields: {
        [K in keyof T]: EastTypeOf<T[K]>;
    };
} : never;
/** @internal */
export declare type ExpressionType<T extends Expression> = T extends Expression<infer U> ? U : never;
/** @internal */
export declare function ExpressionType<T extends EastType>(x: Expression<T>): T;
/** @internal */
export declare type DictValueTypeOf<T extends Map<string, Value> | EastFunction<DictType<EastType>>> = T extends Map<string, Value> ? EastTypeOf<MapOf<T>> : T extends EastFunction<DictType<EastType>> ? T["type"]["values"] : never;
/** @internal */
export declare function isValue(x: Expression<EastType>): x is Value;
/** @internal */
export declare function isFunction(x: Expression<EastType>): x is EastFunction;
/** @internal */
export declare function toEastFunction<T extends EastType>(x: Expression<T>): EastFunction<T>;
/**
 * Fetch an environment variable with a given name.
 *
 * @param name the name of the environment variable
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // fetch current value of the ADMIN_PASSWORD environment variable
 *  password: Environment('ADMIN_PASSWORD'),
 *  // ...
 * ```
 */
export declare function Environment(name: string): EnvironmentFunction<"string">;
/**
 * Declare a constant value. (Note: Use the `Null` to create a constant, null value).
 *
 * @param value the {@link Value} to declare
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // create a constant string 'New Employee'
 *  category: Const('New Employee'),
 *  // ...
 * ```
 */
export declare function Const<T extends Value>(value: T): ConstFunction<EastTypeOf<T>>;
/**
 * Create a `null` value of given data type.
 *
 * @param type the {@link EastType} for the {@link Null} value
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // if Employee is null, replace with 'Unknown' string
 *  Employee: IfElse(
 *      Equal(Variable('Employee', 'string'), Null('string')),
 *      Const('Unknown'),
 *      Variable('Employee', 'string')
 *  ),
 *  // ...
 * ```
 */
export declare function Null<T extends EastType>(type: T): ConstFunction<T>;
/**
 * Defines a new variable in scope that can be accessed by the inner `ast`.
 *
 * @param variable ??
 * @param value ??
 * @param ast ??
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // if name is null, replace with 'Unknown' string
 *  Wage: Let(
 *      Variable("Overtime", "float"),
 *      Max(0, Subtract(Variable("Hours", "float"), 8),
 *      Add(
 *          Multiply(
 *              Variable("NormalRate", "float"),
 *              Subtract(Variable("Hours", "float"), Variable("Overtime", "float"))
 *          ),
 *          Multiply(
 *              Variable("OvertimeRate", "float"),
 *              Variable("Overtime", "float")
 *          )
 *      )
 *  ),
 *  // ...
 * ```
 */
export declare function Let<T extends EastType, U extends EastType, V extends U>(variable: Variable<U>, value: Expression<V>, ast: EastFunction<T>): LetFunction<T>;
/**
 * Return x1 of predicate is true, or x2 otherwise
 *
 * @param predicate the {@link Expression} to test
 * @param x1 the return value if `predicate` is `true`
 * @param x2 the return value if `predicate` is `false`
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // if name is null, replace with 'Unknown' string
 *  new_name: IfElse(
 *      Equal(Variable('name', 'string'), Null('string')),
 *      Const('Unknown'),
 *      Variable('name', 'string')
 *  ),
 *  // ...
 * ```
 */
export declare function IfElse<T extends EastType, U extends T>(predicate: boolean | EastFunction<"boolean">, x1: Expression<T>, x2: Expression<U>): IfElseFunction<T & U>;
/**
 * Convert `from` to the specified `type`.
 *
 * @param from the {@link Expression} to convert
 * @param type the {@link EastType} to convert to
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // convert a percentage to a ratio
 *  Ratio: Divide(Convert(Variable('Percentage', 'integer'), 'float'), 100),
 *  // ...
 * ```
 */
export declare function Convert(from: Expression<"integer">, type: "float"): ConvertFunction<"float">;
/**
 * Convert `from` to the specified `type`.
 *
 * @param from the {@link Expression} to convert
 * @param type the {@link EastType} to convert to
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // convert a ratio to a percentage
 *  Percentage: Convert(Multiply(Variable('Ratio', 'float'), 100), 'integer'),
 *  // ...
 * ```
 */
export declare function Convert(from: Expression<"float">, type: "integer"): ConvertFunction<"integer">;
/** @internal */
export declare function defaultParseSchema(type: EastType): ParseSchema;
/**
 * Parse an input into a East value, using the given format schema.
 *
 * @param from the {@link Expression} to parse
 * @param format the optional format to apply
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // parse a struct containing employee details
 *  EmployeeDetails: Parse(
 *      Variable(
 *          'EmployeeDetails',
 *          StructType({
 *              name: string,
 *              phone: string
 *          })
 *      )
 *  ),
 *  // ...
 * ```
 */
export declare function Parse<T extends StructType>(from: Expression<T>, format: StructParseSchema): ParseFunction<T>;
/**
 * Parse an input into a East value, using the given format schema.
 *
 * @param from the {@link Expression} to parse
 * @param format the optional format to apply
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // parse a dict containing a price card
 *  EmployeeDetails: Parse(Variable('PriceCard', DictType('float'))),
 *  // ...
 * ```
 */
export declare function Parse<T extends DictType>(from: Expression<T>, format: DictParseSchema): ParseFunction<T>;
/**
 * Parse an input into a East value, using the given format schema.
 *
 * @param from the {@link Expression} to parse
 * @param format the optional format to apply
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // parse a struct array containing employee details
 *  EmployeeDetailsList: Parse(
 *      Variable(
 *          'EmployeeDetailsList',
 *          ArrayType(
 *              StructType({
 *                  name: string,
 *                  phone: string
 *              })
 *          )
 *      )
 *  ),
 *  // ...
 * ```
 */
export declare function Parse<T extends ArrayType>(from: Expression<T>, format: ArrayParseSchema): ParseFunction<T>;
/**
 * Parse an input into a East value, using the given format schema.
 *
 * @param from the {@link Expression} to parse
 * @param format the optional format to apply
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // parse set of employee id's
 *  EmployeeIds: Parse(Variable('EmployeeIds', 'set')),
 *  // ...
 * ```
 */
export declare function Parse<T extends "set">(from: Expression<T>, format: SetParseSchema): ParseFunction<T>;
/**
 * Parse an input into a East value, using the given format schema.
 *
 * @param from the {@link Expression} to parse
 * @param format the optional format to apply
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // parse a date variable
 *  Date: Parse(Variable('Date', 'datetime')),
 *  // ...
 * ```
 */
export declare function Parse(from: Expression<"datetime">, format: string): ParseFunction<"datetime">;
export declare function Parse<T extends EastType>(from: Expression<T>): ParseFunction<T>;
/**
 * Print a primitive value to a string (with an optional format string).
 *
 * @param value the {@link Expression} to print
 * @param format the format to apply
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // print a date to string in a specific format
 *  DateString: Print(Variable('Date', 'datetime'), 'DD-MM-YYYY'),
 *  // ...
 * ```
 */
export declare function Print<T extends PrimitiveType | "set">(value: Expression<T>, format?: string): EastFunction<"string">;
/**
 * Return `true` if `value` is `false`, or `false` otherwise.
 *
 * @param value the {@link Expression} to apply
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  NotActive: Not(Variable('Active', 'boolean')),
 *  // ...
 * ```
 */
export declare function Not(value: Expression<"boolean">): NotFunction<"boolean">;
/**
 * Return `true` if all `values` are `true`, or `false` otherwise.
 *
 * @param value one or more {@link Expression}'s to apply
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // set an employee availability to true if they are a "Site Worker" AND they started more than 6 months ago
 *  Available: And(
 *      Equal(
 *          Variable('EmployeeCategory', 'strings'),
 *          Const("Site Worker")
 *      ),
 *      Greater(
 *          Duration(
 *              Variable('StartDate', 'datetime'),
 *              Variable('ContractDate', 'datetime'),
 *              'month'
 *          ),
 *          6
 *      )
 *  ),
 *  // ...
 * ```
 */
export declare function And(): ConstFunction<"boolean">;
export declare function And<T extends EastFunction<"boolean">>(first: T): T;
export declare function And(first: Expression<"boolean">, second: Expression<"boolean">, ...values: Expression<"boolean">[]): AndFunction<"boolean">;
export declare function And(...values: Expression<"boolean">[]): EastFunction<"boolean">;
/**
 * Return `false` if all `values` are `false`, or `true` otherwise.
 *
 * @param value one or more {@link Expression}'s to apply
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // set an employee availability to true if they are a "Site Worker" OR they started more than 6 months ago
 *  Available: Or(
 *      Equal(
 *          Variable('EmployeeCategory', 'string'),
 *          Const("Site Worker")
 *      ),
 *      Greater(
 *          Duration(
 *              Variable('StartDate', 'datetime'),
 *              Variable('ContractDate', 'datetime'),
 *              'month'
 *          ),
 *          6
 *      )
 *  ),
 *  // ...
 * ```
 */
export declare function Or(): ConstFunction<"boolean">;
export declare function Or<T extends EastFunction<"boolean">>(first: T): T;
export declare function Or(first: Expression<"boolean">, second: Expression<"boolean">, ...values: Expression<"boolean">[]): OrFunction<"boolean">;
export declare function Or(...values: Expression<"boolean">[]): EastFunction<"boolean">;
/**
 * Compare two primitive values and return `true` if equal, or `false` otherwise.
 *
 * @param first the first {@link Expression} to compare
 * @param second the second {@link Expression} to compare
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return true if an employee is a "Site Worker"
 *  IsSiteWorker: Equal(
 *      Variable('EmployeeCategory', 'boolean'),
 *      Const("Site Worker")
 *  ),
 *  // ...
 * ```
 */
export declare function Equal<T extends PrimitiveType, U extends T>(first: Expression<T>, second: Expression<U>): EqualFunction<"boolean">;
export declare function Equal<T extends EastType>(first: Expression<T>, second: null): EqualFunction<"boolean">;
export declare function Equal<T extends EastType>(first: null, second: Expression<T>): EqualFunction<"boolean">;
export declare function Equal(first: null, second: null): ConstFunction<"boolean">;
/**
 * Compare two primitive values and return `false` if equal, or `true` otherwise.
 *
 * @param first the first {@link Expression} to compare
 * @param second the second {@link Expression} to compare
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return true if an employee isn't a "Site Worker"
 *  IsNotSiteWorker: NotEqual(
 *      Variable('EmployeeCategory', 'boolean'),
 *      Const("Site Worker")
 *  ),
 *  // ...
 * ```
 */
export declare function NotEqual<T extends PrimitiveType, U extends T>(first: Expression<T>, second: Expression<U>): NotEqualFunction<"boolean">;
export declare function NotEqual<T extends EastType>(first: Expression<T>, second: null): NotEqualFunction<"boolean">;
export declare function NotEqual<T extends EastType>(first: null, second: Expression<T>): NotEqualFunction<"boolean">;
export declare function NotEqual(first: null, second: null): ConstFunction<"boolean">;
/**
 * Compare two primitive values and return `true` if the first is less than the second, or `false` otherwise.
 *
 * @param first the first {@link Expression} to compare
 * @param second the second {@link Expression} to compare
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return true if cost is less than a price
 *  IsProfitable: Less(
 *      Variable('Cost', 'float'),
 *      Variable('Price', 'float')
 *  ),
 *  // ...
 * ```
 */
export declare function Less<T extends PrimitiveType, U extends T>(first: Expression<T>, second: Expression<U>): LessFunction<"boolean">;
/**
 * Compare two primitive values and return `true` if the first is less than or equal to the second, or `false` otherwise.
 *
 * @param first the first {@link Expression} to compare
 * @param second the second {@link Expression} to compare
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return true if purchase price is less than or equal to bank balance
 *  CanPurchase: LessEqual(
 *      Variable('Price', 'float'),
 *      Variable('Balance', 'float')
 *  ),
 *  // ...
 * ```
 */
export declare function LessEqual<T extends PrimitiveType, U extends T>(first: Expression<T>, second: Expression<U>): LessEqualFunction<"boolean">;
/**
 * Compare two primitive values and return `true` if the first is greater than the second, or `false` otherwise.
 *
 * @param first the first {@link Expression} to compare
 * @param second the second {@link Expression} to compare
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return true if more than 8 hours were worked
 *  IsOvertime: Greater(
 *      Variable('HoursWorked', 'float'),
 *      8
 *  ),
 *  // ...
 * ```
 */
export declare function Greater<T extends PrimitiveType, U extends T>(first: Expression<T>, second: Expression<U>): GreaterFunction<"boolean">;
/**
 * Compare two primitive values and return `true` if the first is greater than or equal to the second, or `false` otherwise.
 *
 * @param first the first {@link Expression} to compare
 * @param second the second {@link Expression} to compare
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return true if balance is greater or equal to zero.
 *  IsSolvent: GreaterEqual(
 *      Variable('Balance', 'float'),
 *      0
 *  ),
 *  // ...
 * ```
 */
export declare function GreaterEqual<T extends PrimitiveType, U extends T>(first: Expression<T>, second: Expression<U>): GreaterEqualFunction<"boolean">;
/**
 * Add `first` integer to `second` integer.
 *
 * @param first the first {@link Expression} to add
 * @param second the second {@link Expression} to add
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return the number of stock after a quantity is purchased
 *  NewStockLevel: Add(
 *      Variable('StockLevel', 'float'),
 *      Variable('PurchaseQuantity', 'float')
 *  ),
 *  // ...
 * ```
 */
export declare function Add(first: Expression<"integer">, second: Expression<"integer">): AddFunction<"integer">;
/**
 * Add `first` to `second`.
 *
 * @param first the first {@link Expression} to add
 * @param second the second {@link Expression} to add
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return the bank balance after a sale is deposited
 *  NewBalance: Add(
 *      Variable('Balance', 'float'),
 *      Variable('SaleTotal', 'float')
 *  ),
 *  // ...
 * ```
 */
export declare function Add(first: Expression<"integer" | "float">, second: Expression<"integer" | "float">): AddFunction<"float">;
/**
 * Subtract `second` integer from `first` integer.
 *
 * @param first the {@link Expression} to subtract from
 * @param second the {@link Expression} amount to subtract
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return the number of stock after a quantity is sold
 *  NewStockLevel: Subtract(
 *      Variable('StockLevel', 'float'),
 *      Variable('SaleQuantity', 'float')
 *  ),
 *  // ...
 * ```
 */
export declare function Subtract(first: Expression<"integer">, second: Expression<"integer">): SubtractFunction<"integer">;
/**
 * Subtract `second` from `first`.
 *
 * @param first the {@link Expression} to subtract from
 * @param second the {@link Expression} amount to subtract
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return the bank balance after a purchase is made
 *  NewBalance: Subtract(
 *      Variable('Balance', 'float'),
 *      Variable('PurchaseTotal', 'float')
 *  ),
 *  // ...
 * ```
 */
export declare function Subtract(first: Expression<"integer" | "float">, second: Expression<"integer" | "float">): SubtractFunction<"float">;
/**
 * Multiply `first` integer by `second` integer.
 *
 * @param first the first {@link Expression} to multiply
 * @param second the second {@link Expression} to multiply
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return the number of calendar days in NumberOfWeeks
 *  NumberOfDays: Multiply(
 *      Variable('NumberOfWeeks', 'integer'),
 *      7n
 *  ),
 *  // ...
 * ```
 */
export declare function Multiply(first: Expression<"integer">, second: Expression<"integer">): MultiplyFunction<"integer">;
/**
 * Multiply `first` by `second`.
 *
 * @param first the first {@link Expression} to multiply
 * @param second the second {@link Expression} to multiply
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return the total price of a quantity of products with a given unit price
 *  TotalPrice: Multiply(
 *      Variable('UnitPrice', 'float'),
 *      Variable('Quantity', 'float')
 *  ),
 *  // ...
 * ```
 */
export declare function Multiply(first: Expression<"integer" | "float">, second: Expression<"integer" | "float">): MultiplyFunction<"float">;
/**
 * Divide `first` by `second`.
 *
 * @param first the initial {@link Expression} to divide
 * @param second the {@link Expression} to divide by
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return the average revenue collected each trading day
 *  RevenuePerDay: Divide(
 *      Variable('TotalRevenue', 'float'),
 *      Variable('DaysOpen', 'float')
 *  ),
 *  // ...
 * ```
 */
export declare function Divide(first: Expression<"float" | "integer">, second: Expression<"float" | "integer">): DivideFunction<"float">;
/**
 * Find the remainder when deviding `first` by `second`.
 *
 * @param first the initial {@link Expression} to divide
 * @param second the {@link Expression} to divide by
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return true if X is an even integer, or false if X is an odd integer
 *  IsEven: Equal(
 *      Modulo(
 *          Variable('X', 'integer'),
 *          2n
 *      ),
 *      0n
 *  ),
 *  // ...
 * ```
 */
export declare function Modulo<T extends "float" | "integer">(first: Expression<T>, second: Expression<"integer">): ModuloFunction<T>;
/**
 * Round datetime `value` to a whole time `unit` ("year", "month", "week", "day", "hour", "minute", "second"), using `rounding_mode` of "nearest", "floor" (round down) or "ceiling" (round up).
 *
 * @param value the {@link Expression} to round
 * @param rounding_mode 'nearest', 'floor' (always round down) or 'ceiling' (always round up)
 * @param unit 'year', 'month', 'week', 'day', 'hour', 'minute' or 'second'
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return the instant at the beginning of the week
 *  WholeHoursWorked: Round(
 *      Variable('Date', 'datetime'),
 *      'floor',
 *      'week'
 *  ),
 *  // ...
 * ```
 */
export declare function Round(value: Expression<"datetime">, rounding_mode: RoundingMode, unit: TimeUnit | CalendarUnit): RoundFunction<"datetime">;
/**
 * Round number `value` to an integer, using `rounding_mode` of "nearest" (default), "floor" (round down) or "ceiling" (round up).
 *
 * @param value the {@link Expression} to round
 * @param rounding_mode 'nearest', 'floor' (always round down) or 'ceiling' (always round up)
 * @param unit 'integer'
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return the number of whole hours worked on a shift (rounded down)
 *  WholeHoursWorked: Round(
 *      Variable('HoursWorked', 'float'),
 *      'floor',
 *      'integer'
 *  ),
 *  // ...
 * ```
 */
export declare function Round(value: Expression<"float">, rounding_mode: RoundingMode, type: "integer"): RoundFunction<"integer">;
/**
 * Round number `value` to a whole number, using `rounding_mode` of "nearest" (default), "floor" (round down) or "ceiling" (round up).
 *
 * @param value the {@link Expression} to round
 * @param rounding_mode 'nearest', 'floor' (always round down) or 'ceiling' (always round up)
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return the quantity rounded to the nearest whole number
 *  RoundedQuantity: Round(
 *      Variable('Quantity', 'float'),
 *      'nearest'
 *  ),
 *  // ...
 * ```
 */
export declare function Round(value: Expression<"float">, rounding_mode?: RoundingMode, type?: "float"): RoundFunction<"float">;
/**
 * Round the number to the specified number of significant digits, e.g. 1234.5 -> 1200.0.
 *
 * @param value the {@link Expression} to round
 * @param significant_digits number of significant digits to keep
 *
 * @category Expression
 */
export declare function RoundPrecision(value: Expression<"float">, significant_digits: number): EastFunction<"float">;
/**
 * Round the integer to the specified number of significant digits, e.g. 1234 -> 1200.
 *
 * @param value the {@link Expression} to round
 * @param significant_digits number of significant digits to keep
 *
 @category Expression
 * */
export declare function RoundPrecision(value: Expression<"integer">, significant_digits: number): EastFunction<"integer">;
/**
 * Return the square root of a number.
 *
 * @param value the {@link Expression} to find the square root of
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return the quantity rounded to the nearest whole number
 *  StandardDeviation: Sqrt(Variable('Variance', 'float')),
 *  // ...
 * ```
 */
export declare function Sqrt(value: Expression<"float">): SqrtFunction<"float">;
/**
  * Return the square root of an integer (returning a floating-point number).
 *
 * @param value the {@link Expression} to find the square root of
 *
 * @category Expression
 * ```
 */
export declare function Sqrt(value: Expression<"integer">): SqrtFunction<"float">;
/**
 * Return the natural logarithm of a number (base _e_).
 *
 * @param value the {@link Expression} to find the natural logarithm of
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // transform a positive variable into a logarithmic scale
 *  XLog: Log(Variable('X', 'float')),
 *  // ...
 * ```
 */
export declare function Log(value: Expression<"float">): LogFunction<"float">;
/**
 * Return the (natural) exponential of a number (i.e. power with base _e_).
 *
 * @param value the {@link Expression} for the exponent
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // transform a variable from a logarithmic space to normal space
 *  X: Exp(Variable('X', 'float')),
 *  // ...
 * ```
 */
export declare function Exp(value: Expression<"float">): ExpFunction<"float">;
/**
 * Return `first` to the power of `second`, `first ^ second`.
 *
 * @param value the {@link Expression} for the base
 * @param value the {@link Expression} for the exponent
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // find the cube root of X
 *  Y: Pow(Variable('X', 'float'), 1/3),
 *  // ...
 * ```
 */
export declare function Pow(first: Expression<"float" | "integer">, second: Expression<"float" | "integer">): PowFunction<"float">;
/**
 * Construct a datetime value from a string, with optional format.
 *
 * @param value the string {@link Expression} to parse
 * @param format the format string (by default it expects ISO-8601, e.g. 'YYYY-MM-DDThh:mm:ss.sssZ')
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // parse the date from the US-formated date string
 *  Date: ToDateTime('DateString', 'M-D-YYYY'),
 *  // ...
 * ```
 */
export declare function ToDateTime(value: Expression<"string">, format?: string): ToDateTimeFunction<"datetime">;
/**
 * Find the duration between datetimes `start` and `stop`, in the given time `unit`. Note:
 * returns a negative number if `stop` is prior to `start` (and that the ordering of
 * arguments is reversed compared to {@link Subtract}).
 *
 * @param start the {@link Expression} for the initial datetime
 * @param stop the {@link Expression} for the final datetime
 * @param unit the {@link TimeUnit} to calculate the answer in ('millisecond', 'second', 'minute', 'hour', 'day' or 'week')
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return the length of a shift in hours
 *  ShiftHours: Duration(
 *      Variable('ShiftStart', 'datetime'),
 *      Variable('ShiftStop', 'datetime'),
 *      'hour'
 *  ),
 *  // ...
 * ```
 */
export declare function Duration(start: Expression<"datetime">, stop: Expression<"datetime">, unit: TimeUnit): DurationFunction<"float">;
/**
 * Add the `duration` (in the given time `unit`) to `datetime`.
 *
 * @category Expression*
 *
 * @param datetime the {@link Expression} for the initial datetime
 * @param duration the {@link Expression} for duration
 * @param unit the {@link TimeUnit} of `duration` ('millisecond', 'second', 'minute', 'hour', 'day' or 'week')
 *
 * @example
 * ```typescript
 *  // ...
 *  // return the date payment is due for an invoice according to the invoice terms
 *  DueDate: AddDuration(
 *      Variable('PurchaseDate', 'datetime'),
 *      Variable('InvoiceTermDays', 'float'),
 *      'day'
 *  ),
 *  // ...
 * ```
 */
export declare function AddDuration(datetime: Expression<"datetime">, duration: Expression<"float">, unit: TimeUnit): AddDurationFunction<"datetime">;
/**
 * Subtract the `duration` (in the given time `unit`) from `datetime`.
 *
 * @category Expression
 *
 * @param datetime the {@link Expression} for the initial datetime
 * @param duration the {@link Expression} for duration
 * @param unit the {@link TimeUnit} of `duration` ('millisecond', 'second', 'minute', 'hour', 'day' or 'week')
 *
 * @example
 * ```typescript
 *  // ...
 *  // return the date payment is due for an invoice according to the invoice terms
 *  DueDate: SubtractDuration(
 *      Variable('PurchaseDate', 'datetime'),
 *      Variable('InvoiceTermDays', 'float'),
 *      'day'
 *  ),
 *  // ...
 * ```
 */
export declare function SubtractDuration(datetime: Expression<"datetime">, duration: Expression<"float">, unit: TimeUnit): SubtractDurationFunction<"datetime">;
/**
 * Convert the `datetime` from `input_timezone` to `output_timezone`.
 *
 * Note: all datetimes in East are plain (or "naive") datetimes and conversion should take
 * place using this function. Absolute durations should be calculated in UTC
 * (zone 'Etc/UTC') to account for e.g. day-light-saving changeovers. The list of IANA
 * timezone strings can be found at https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
 *
 * @param datetime the {@link Expression} for the input datetime
 * @param input_timezone the {@link Expression} for the input's timezone (as an IANA timezone string)
 * @param output_timezone the {@link Expression} for the output's timezone (as an IANA timezone string)
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // convert the UTC time into Sydney, Australia time
 *  LocalTime: ConvertTimeZone(
 *      Variable('UtcTime', 'datetime'),
 *      'Etc/UTC'
 *      'Australia/Sydney'
 *  ),
 *  // ...
 * ```
 */
export declare function TimeZoneConvert(datetime: Expression<"datetime">, input_timezone: Expression<"string">, output_timezone: Expression<"string">): TimeZoneConvertFunction<"datetime">;
/**
 * Return the number of whole milliseconds elapsed since the start of the second (0 - 999).
 *
 * @param datetime the {@link Expression} for datetime
 *
 * @category Expression
 */
export declare function Millisecond(datetime: Expression<"datetime">): MillisecondFunction<"integer">;
/**
 * Return the number of whole seconds elapsed since the start of the minute (0 - 59).
 *
 * @param datetime the {@link Expression} for datetime
 *
 * @category Expression
 */
export declare function Second(datetime: Expression<"datetime">): SecondFunction<"integer">;
/**
 * Return the number of whole minutes elapsed since the start of the hour (0 - 59).
 *
 * @param datetime the {@link Expression} for datetime
 *
 * @category Expression
 */
export declare function Minute(datetime: Expression<"datetime">): MinuteFunction<"integer">;
/**
 * Return the number of whole hours elapsed since the start of the day (0 - 23).
 *
 * @param datetime the {@link Expression} for datetime
 *
 * @category Expression
 */
export declare function Hour(datetime: Expression<"datetime">): HourFunction<"integer">;
/**
 * Return the number of whole days elapsed since the start of the week (Monday = 0, ..., Sunday = 6).
 *
 * @param datetime the {@link Expression} for datetime
 *
 * @category Expression
 */
export declare function DayOfWeek(datetime: Expression<"datetime">): DayOfWeekFunction<"integer">;
/**
 * Return the day number of the month (1 - 31).
 *
 * @param datetime the {@link Expression} for datetime
 *
 * @category Expression
 */
export declare function DayOfMonth(datetime: Expression<"datetime">): DayOfMonthFunction<"integer">;
/**
 * Return the month number of the year (January = 1, ..., December = 12).
 *
 * @param datetime the {@link Expression} for datetime
 *
 * @category Expression
 */
export declare function Month(datetime: Expression<"datetime">): MonthFunction<"integer">;
/**
 * Return the number of whole years since 0AD.
 *
 * @param datetime the {@link Expression} for datetime
 *
 * @category Expression
 */
export declare function Year(datetime: Expression<"datetime">): YearFunction<"integer">;
/**
 * Return a substring of `value` between the characters `start` and `stop`.
 *
 * @param value the {@link Expression} for string
 * @param start the {@link Expression} giving the index of the first character to keep (starting at 0)
 * @param stop the {@link Expression} giving the index *after* the final character to keep
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // extract the first two characters of Id
 *  Prefix: Substring(Variable('Id', 'string'), 0, 2),
 *  // ...
 * ```
 */
export declare function Substring(value: Expression<"string">, start: number, stop: number): SubstringFunction<"string">;
/**
 * Return a string concatenating all the `values` strings with the optional `seperator`. Also able to be used as a tagged template string literal.
 *
 * @param values the {@link Expression} containing collection of strings
 * @param seperator the string to place between consecutive values (defaults to "")
 *
 * @category Expression
 *
 * @example
 * ```typescript
 * StringJoin`There are ${Variable("qty", "integer")} items`
 * ```
 * is equivalent to:
 *
 * ```typescript
 * StringJoin(['There are ', Variable("qty", "integer"), ' items'])
 * ```
 *
 * @example
 * ```typescript
 *  // ...
 *  // create string with a comma seperated list of employee names from an array of employee names strings
 *  EmployeeNamesString: StringJoin(
 *      Variable(EmployeeNames, ArrayType<'string'>),
 *      ', ']
 *  )
 *  // ...
 * ```
 *
 * */
export declare function StringJoin(values: Expression<PrimitiveType>[] | Record<string, Expression<PrimitiveType>> | TemplateStringsArray, seperator?: string | Expression<PrimitiveType>, ...args: Expression<PrimitiveType>[]): StringJoinFunction<"string">;
/**
 * Return a string where `value`'s matches to the regular expression `search` string are replaced with value of `replace`.
 *
 * @param value the {@link Expression} with the string to modify
 * @param search the (fixed) regular expressionsearch string to search for
 * @param replace the {@link Expression} for the string to replace matches with
 * @param flags the regular expression flags to apply (default 'g' for global, also 'i' for case insensitive)
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // extract the part of the string before the colon :
 *  FirstPart: RegexReplace(
 *      Variable("ComplexString", "string"),
 *      '.*:(.+)',
 *      '$1'
 *  ),
 *  // ...
 * ```
 */
export declare function RegexReplace(value: Expression<"string">, search: string, replace: Expression<"string">, flags?: string): RegexReplaceFunction<"string">;
/**
 * Return `true` if `value` matches the regular expression `search` string, or `false` otherwise.
 *
 * @param value the {@link Expression} with the string to modify
 * @param search the (fixed) regular expression search string to search for
 * @param flags the regular expression flags to apply (default 'i' for case insensitive)
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // Infer if product is a subscription product based on the
 *  // presence of 'subscription' in the product's name
 *  ProductIsSubscription: RegexContains(
 *      Variable("ProductName", "string"),
 *      'subscription'
 *  ),
 *  // ...
 * ```
 */
export declare function RegexContains(value: Expression<"string">, search: string, flags?: string): RegexContainsFunction<"boolean">;
/**
 * Return a string containing only uppercase characters.
 *
 * @param value the {@link Expression} with the input string
 *
 * @category Expression
 */
export declare function UpperCase(value: Expression<"string">): UpperCaseFunction<"string">;
/**
 * Return a string containing only lowercase characters.
 *
 * @param value the {@link Expression} with the input string
 *
 * @category Expression
 */
export declare function LowerCase(value: Expression<"string">): LowerCaseFunction<"string">;
/**
 * Return a string containing a JSON encoding the East value.
 *
 * @param value the {@link Expression} with the value to encode as JSON
 *
 * @category Expression
 */
export declare function ToJson<T extends EastType>(value: Expression<T>): ToJsonFunction<"string">;
/**
 * Return an East value of type `type` decoded from a JSON string.
 *
 * Note: this expects the JSON to conform to some known schema compatible with `type`.
 *
 * @param type the {@link EastType} to decode to
 * @param value the {@link Expression} with the JSON string to decode
 *
 * @category Expression
 */
export declare function FromJson<T extends EastType>(type: T, value: Expression<"string">): FromJsonFunction<T>;
/**
 * Return the hash of a string with specified algorithm and encoding.
 *
 * @param value the {@link Expression} for the string to hash
 * @param hash the {@link HashType} to employ ('md5', 'sha1', 'sha256', 'sha224', 'sha512', 'sha384', 'sha3' or 'ripemd160')
 * @param encoding the encoding the result should be use ('base64' or 'hex')
 *
 * @category Expression
 */
export declare function Hash(value: Expression<"string">, hash: HashType, encoding: "base64" | "hex"): HashFunction<"string">;
/**
 * Return the HMAC for a string with a given key and specified hashing algorithm and encoding.
 *
 * @param value the {@link Expression} for the string to sign
 * @param key the {@link Expression} for the HMAC key
 * @param hash the {@link HashType} to employ ('md5', 'sha1', 'sha256', 'sha224', 'sha512', 'sha384', 'sha3' or 'ripemd160')
 * @param encoding the encoding the result should be use ('base64' or 'hex')
 *
 * @category Expression
 */
export declare function HMAC(value: Expression<"string">, key: Expression<"string">, hash: HashType, encoding: "base64" | "hex"): HMACFunction<"string">;
/**
 * Convert a Base64 string to an ASCII string.
 *
 * @param value the {@link Expression} for the input Base64 string
 *
 * @category Expression
 */
export declare function Base64ToAscii(value: Expression<"string">): Base64ToAsciiFunction<"string">;
/**
 * Convert an ASCII string to Base64 encoding.
 *
 * @param value the {@link Expression} for the input ASCII string
 *
 * @category Expression
 */
export declare function AsciiToBase64(value: Expression<"string">): AsciiToBase64Function<"string">;
/**
 * Convert a Base64 string to hexadecimal encoding.
 *
 * @param value the {@link Expression} for the input Base64 string
 *
 * @category Expression
 */
export declare function Base64ToHex(value: Expression<"string">): Base64ToHexFunction<"string">;
/**
 * Convert a hexadecimal string to Base64 encoding.
 *
 * @param value the {@link Expression} for the input hexadecimal string
 *
 * @category Expression
 */
export declare function HexToBase64(value: Expression<"string">): HexToBase64Function<"string">;
/**
 * Encode a string suitable for placing as a component inside a URI.
 *
 * @param value the {@link Expression} for the input string
 *
 * @category Expression
 */
export declare function URIEncode(value: Expression<"string">): URIEncodeFunction<"string">;
/**
 * Decode a string from a compoment of a URI.
 *
 * @param value the {@link Expression} for the URI string
 *
 * @category Expression
 */
export declare function URIDecode(value: Expression<"string">): URIDecodeFunction<"string">;
/**
 * Return `true` if the `first` set is a subset, or equal to, the `second` set.
 *
 * @param first the {@link Expression} for the first set
 * @param second the {@link Expression} for the second set
 *
 * @category Expression
 */
export declare function SubsetEqual(first: Expression<"set">, second: Expression<"set">): SubsetEqualFunction<"boolean">;
/**
 * Return a set which is the union of `first` and `second`.
 *
 * @param first the {@link Expression} for the first set
 * @param second the {@link Expression} for the second set
 *
 * @category Expression
 */
export declare function Union(first: Expression<"set">, second: Expression<"set">): UnionFunction<"set">;
/**
 * Return a set which is the intersection of `first` and `second`.
 *
 * @param first the {@link Expression} for the first set
 * @param second the {@link Expression} for the second set
 *
 * @category Expression
 */
export declare function Intersect(first: Expression<"set">, second: Expression<"set">): IntersectFunction<"set">;
/**
 * Return a set which is the set difference of `first` and `second`.
 *
 * @param first the {@link Expression} for the first set
 * @param second the {@link Expression} for the second set
 *
 * @category Expression
 */
export declare function SetDiff(first: Expression<"set">, second: Expression<"set">): SetDiffFunction<"set">;
/**
 * Return a set which is the symmetric difference of `first` and `second`.
 *
 * @param first the {@link Expression} for the first set
 * @param second the {@link Expression} for the second set
 *
 * @category Expression
 */
export declare function SymDiff(first: Expression<"set">, second: Expression<"set">): SymDiffFunction<"set">;
/**
 * Return `true` if `key` is in `set`, or `false` otherwise.
 *
 * @param set the {@link Expression} for the set
 * @param key the {@link Expression} for the value to search for
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // Determine if the product is in the set of currently available products
 *  ProductIsAvailable: In(
 *      Variable("AvailableProductIds", "set"),
 *      Variable("ProductId", "string"),
 *  ),
 *  // ...
 * ```
 */
export declare function In(set: Expression<"set">, key: Expression<"string">): InFunction<"boolean">;
/**
 * Return a dictionary where `key` has been inserted with `value` into `collection`,
 * overwriting an existing value if it exists.
 *
 * Note: currently this mutates `collection`, which can have unintended consequences if it is used elsewhere.
 *
 * @param collection the {@link Expression} for the dictionary
 * @param key the {@link Expression} for the key to insert
 * @param value the {@link Expression} for the value to insert
 *
 * @category Expression
 */
export declare function Insert<T extends EastType, U extends T>(collection: Expression<DictType<T>>, key: Expression<"string">, value: Expression<U>): InsertFunction<DictType<T>>;
/**
 * Return a set where `key` has been inserted into `collection`.
 *
 * Note: currently this mutates `collection`, which can have unintended consequences if it is used elsewhere.
 *
 * @param collection the {@link Expression} for the set
 * @param key the {@link Expression} for the key to insert
 *
 * @category Expression
 */
export declare function Insert(collection: Expression<"set">, key: Expression<"string">): InsertFunction<"set">;
/**
 * Return an array where `value` has been inserted to the end of `collection`.
 *
 * Note: currently this mutates `collection`, which can have unintended consequences if it is used elsewhere.
 *
 * @param collection the {@link Expression} for the array
 * @param value the {@link Expression} for the value to insert
 *
 * @category Expression
 */
export declare function Insert<T extends EastType, U extends T>(collection: Expression<ArrayType<T>>, key: undefined, value?: Expression<U>): InsertFunction<ArrayType<T>>;
/**
 * Return a dictionary with a given `key` deleted from `collection`.
 *
 * Note: currently this mutates `collection`, which can have unintended consequences if it is used elsewhere.
 *
 * @param collection the {@link Expression} for the dictionary
 * @param key the {@link Expression} for the key to delete
 *
 * @category Expression
 */
export declare function Delete<T extends EastType, U extends T>(collection: Expression<DictType<T>>, key: Expression<"string">): DeleteFunction<DictType<T>>;
/**
 * Return a set with a given `key` deleted from `collection`.
 *
 * @param collection the {@link Expression} for the set
 * @param key the {@link Expression} for the key to insert
 *
 * Note: currently this mutates `collection`, which can have unintended consequences if it is used elsewhere.
 *
 * @category Expression
 */
export declare function Delete(collection: Expression<"set">, key: Expression<"string">): DeleteFunction<"set">;
/**
 * Return the set of keys of `dict`.
 *
 * @param dict the {@link Expression} for the dictionary
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // Given a dictionary from product quantities to price, get the set of product ids
 *  ProductIds: Keys(Variable("ProductQuantities", DictType("integer"))),
 *  // ...
 * ```
 */
export declare function Keys(dict: Expression<DictType>): KeysFunction<"set">;
/**
 * Return the only key of `dict`, or else `null` if it has zero or more than two elements.
 *
 * @param dict the {@link Expression} for the dictionary
 *
 * @category Expression
 */
export declare function OnlyKey(dict: Expression<DictType>): OnlyKeyFunction<"string">;
/**
 * Get a value from `collection` corresponding to the given `key`. If `key` is not found, returns `default`.
 *
 * @param collection the {@link Expression} for the dictionary
 * @param key the {@link Expression} for the (string) key
 * @param default the {@link Expression} for the value to return if the key is not found (optional, defaults to `null`)
 *
 * @category Expression
 * @example
 * ```typescript
 *  // ...
 *  // Get the name of a product from a dictionary from id -> name
 *  ProductName: Get(
 *      Variable("ProductNames", DictType("string")),
 *      Variable("ProductId", "string")
 *  ),
 *  // ...
 *  ```
 */
export declare function Get<T extends EastType>(collection: EastFunction<{
    type: "dict";
    values: T;
}>, key: Expression<"string">, defaultValue?: Expression<T> | null): GetFunction<T>;
/**
 * Get a value from `collection` corresponding to the given `key`. If `key` is not found,
 * returns `default`. (Note: the first key of an array is zero).
 *
 * @param collection the {@link Expression} for the array
 * @param key the {@link Expression} for the (integer) key
 * @param default the {@link Expression} for the value to return if the key is not found (optional, defaults to `null`)
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // Get the first item in a list of items
 *  FirstItem: Get(
 *      Variable("Items", ArrayType("string")),
 *      0n
 *  ),
 *  // ...
 * ```
 */
export declare function Get<T extends EastType>(collection: EastFunction<{
    type: "array";
    values: T;
}>, key: Expression<"integer">, defaultValue?: Expression<T> | null): GetFunction<T>;
export declare function Get<T extends Value>(collection: Map<string, T>, key: Expression<"string">, defaultValue?: T | null): GetFunction<EastTypeOf<T>>;
export declare function Get<T extends Value>(collection: T[], key: Expression<"integer">, defaultValue?: T | null): GetFunction<EastTypeOf<T>>;
/**
 * Get the number of elements in a collection.
 *
 * @param collection the {@link Expression} for the array, dictionary or set
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // Get the number of employees on a shift
 *  NumberOfShiftEmployees: Size(
 *      Variable("ShiftEmployeeIds", "set"),
 *  ),
 *  // ...
 * ```
 */
export declare function Size(collection: Expression<"set" | DictType | ArrayType>): SizeFunction<"integer">;
/**
 * Construct an new set with given `values`.
 *
 * @param values a list of {@link Expression}s to insert as keys into the new set (optional)
 *
 * @category Expression
 */
export declare function NewSet(...values: Expression<"string">[]): NewSetFunction<"set">;
/**
 * Construct an new dictionary with the given `keys` and `values`.
 *
 * @param value_type the {@link EastType} the values of the dictionary will be
 * @param keys an array of {@link Expression}s to insert as keys into the new dictionary (optional)
 * @param values an array of {@link Expression}s to insert as values into the new dictionary (must be the same length as `keys`) (optional)
 *
 * @category Expression
 */
export declare function NewDict<T extends EastType>(value_type: T, keys?: Expression<"string">[], values?: Expression<T>[]): NewDictFunction<DictType<T>>;
/**
 * Construct an new array with the given values.
 *
 * @param value_type the {@link EastType} the values of the array will be
 * @param values a list of {@link Expression}s to insert as values into the new array (optional)
 *
 * @category Expression
 */
export declare function NewArray<T extends EastType>(value_type: T, ...values: Expression<T>[]): NewArrayFunction<ArrayType<T>>;
/**
 * Construct an array with a contiguous range of integers, `[start, start+1n, ..., stop-1n, stop]`.
 *
 * The range always includes both `start` and `stop`, unless `start` is greater than `stop`
 * in which case the output is an empty array.
 *
 * @param start an {@link Expression} for the first integer.
 * @param stop an {@link Expression} for the first integer.
 *
 * @category Expression
 *
 * @example
 * ```typescript
 * Range(1, Variable("n", "integer"))
 * ```
 */
export declare function Range(start: Expression<"integer">, stop: Expression<"integer">): RangeFunction<ArrayType<"integer">>;
/**
 * Return a set where each `output_key` is calculated from elements of the input `collection`.
 * Duplicate and null output keys are ignored.
 *
 * @param collection the {@link Expression} for the input set
 * @param output_key the {@link Expression} to calculate the output key, given `input_key`
 * @param input_key the {@link Variable} to assign each key of `collection`
 *
 * @category Expression
 */
export declare function ToSet(collection: Set<string> | EastFunction<"set">, output_key: EastFunction<"string">, input_key: Variable<"string">): ToSetFunction<"set">;
/**
 * Return a set where each `output_key` is calculated from elements of the input `collection`.
 * Duplicate and null output keys are ignored.
 *
 * @param collection the {@link Expression} for the input dictionary
 * @param output_key the {@link Expression} to calculate the output key, given `input_value` and `input_key`
 * @param input_value the {@link Variable} to assign each value of `collection`
 * @param input_key the {@link Variable} to assign each key of `collection` (optional)
 *
 * @category Expression
 */
export declare function ToSet<T extends EastType, U extends T>(collection: EastFunction<{
    type: "dict";
    values: T;
}>, output_value: EastFunction<"string">, input_value: Variable<U>, input_key?: Variable<"string">): ToSetFunction<"set">;
/**
 * Return a set where each `output_key` is calculated from elements of the input `collection`.
 * Duplicate and null output keys are ignored.
 *
 * @param collection the {@link Expression} for the input array
 * @param output_key the {@link Expression} to calculate the output key, given `input_value` and `input_key`
 * @param input_value the {@link Variable} to assign each value of `collection`
 * @param input_key the {@link Variable} to assign each key of `collection` (optional)
 *
 * @category Expression
 */
export declare function ToSet<T extends EastType, U extends T>(collection: EastFunction<{
    type: "array";
    values: T;
}>, output_value: EastFunction<"string">, input_value: Variable<U>, input_key?: Variable<"integer">): ToSetFunction<"set">;
export declare function ToSet<T extends Map<string, Value>, U extends EastTypeOf<MapOf<T>>>(collection: T, output_value: EastFunction<"string">, input_value: Variable<U>, input_key?: Variable<"string">): ToSetFunction<"set">;
export declare function ToSet<T extends Value[], U extends EastTypeOf<ArrayOf<T>>>(collection: T, output_value: EastFunction<"string">, input_value: Variable<U>, input_key?: Variable<"integer">): ToSetFunction<"set">;
/**
 * Return an array where each `output_value` is calculated from each element of the input `collection`.
 *
 * @param collection the {@link Expression} for the input set
 * @param output_value the {@link Expression} to calculate the output value, given `input_key`
 * @param input_key the {@link Variable} to assign each key of `collection`
 *
 * @category Expression
 */
export declare function ToArray<T extends EastType>(collection: Set<string> | EastFunction<"set">, output_value: EastFunction<T>, input_key: Variable<"string">): ToArrayFunction<ArrayType<T>>;
/**
 * Return an array where each `output_value` is calculated from each element of the input `collection`.
 *
 * @param collection the {@link Expression} for the input dictionary
 * @param output_value the {@link Expression} to calculate the output value, given `input_value` and `input_key`
 * @param input_value the {@link Variable} to assign each value of `collection`
 * @param input_key the {@link Variable} to assign each key of `collection` (optional)
 *
 * @category Expression
 */
export declare function ToArray<T extends EastType, U extends EastType, V extends T>(collection: EastFunction<{
    type: "dict";
    values: T;
}>, output_value: EastFunction<U>, input_value: Variable<V>, input_key?: Variable<"string">): ToArrayFunction<ArrayType<U>>;
/**
 * Return an array where each `output_value` is calculated from each element of the input `collection`.
 *
 * @param collection the {@link Expression} for the input array
 * @param output_value the {@link Expression} to calculate the output key, given `input_value` and `input_key`
 * @param input_value the {@link Variable} to assign each value of `collection`
 * @param input_key the {@link Variable} to assign each key of `collection` (optional)
 *
 * @category Expression
 */
export declare function ToArray<T extends EastType, U extends EastType, V extends T>(collection: EastFunction<{
    type: "array";
    values: T;
}>, output_value: EastFunction<U>, input_value: Variable<V>, input_key?: Variable<"integer">): ToArrayFunction<ArrayType<U>>;
export declare function ToArray<T extends Map<string, Value>, U extends EastTypeOf<MapOf<T>>, V extends EastType>(collection: T, output_value: EastFunction<V>, input_value: Variable<U>, input_key?: Variable<"string">): ToArrayFunction<ArrayType<V>>;
export declare function ToArray<T extends Value[], U extends EastTypeOf<ArrayOf<T>>, V extends EastType>(collection: T, output_value: EastFunction<V>, input_value: Variable<U>, input_key?: Variable<"integer">): ToArrayFunction<ArrayType<V>>;
/**
 * Return a dictionary where each `output_key` and `output_value` is calculated from elements of the input `collection`.
 * If the `output_key` is `null` the element is ignored. In case of duplicate keys, the last value is kept.
 *
 * @param collection the {@link Expression} for the input set
 * @param output_value the {@link Expression} to calculate the output value, given `input_key`
 * @param output_key the {@link Expression} to calculate the output key, given `input_key`
 * @param input_key the {@link Variable} to assign each key of `collection`
 *
 * @category Expression
 */
export declare function ToDict<T extends EastType>(collection: Set<string> | EastFunction<"set">, output_value: EastFunction<T>, output_key: Expression<"string">, input_value: Variable<"string">, input_key?: undefined, previous_value?: Variable<T>, initial_value?: Expression<T>): ToDictFunction<DictType<T>>;
/**
 * Return a dictionary where each `output_key` and `output_value` is calculated from elements of the input `collection`.
 * If the `output_key` is `null` the element is ignored. In case of duplicate keys, the last value is kept.
 *
 * @param collection the {@link Expression} for the input dictionary
 * @param output_value the {@link Expression} to calculate the output value, given `input_key`
 * @param output_key the {@link Expression} to calculate the output key, given `input_key`
 * @param input_value the {@link Variable} to assign each value of `collection`
 * @param input_key the {@link Variable} to assign each key of `collection` (optional)
 *
 * @category Expression
 */
export declare function ToDict<T extends Map<string, Value>, U extends EastTypeOf<MapOf<T>>, V extends EastType>(collection: T, output_value: EastFunction<V>, output_key: Expression<"string">, input_value: Variable<U>, input_key?: Variable<"string">, previous_value?: Variable<V>, initial_value?: Expression<V>): ToDictFunction<DictType<V>>;
/**
 * Return a dictionary where each `output_key` and `output_value` is calculated from elements of the input `collection`.
 * If the `output_key` is `null` the element is ignored. In case of duplicate keys, the last value is kept.
 *
 * @param collection the {@link Expression} for the input array
 * @param output_value the {@link Expression} to calculate the output value, given `input_key`
 * @param output_key the {@link Expression} to calculate the output key, given `input_key`
 * @param input_value the {@link Variable} to assign each value of `collection`
 * @param input_key the {@link Variable} to assign each key of `collection` (optional)
 *
 * @category Expression
 */
export declare function ToDict<T extends EastType, U extends EastType, V extends T>(collection: EastFunction<{
    type: "array";
    values: T;
}>, output_value: EastFunction<U>, output_key: Expression<"string">, input_value: Variable<V>, input_key?: Variable<"integer">, previous_value?: Variable<U>, initial_value?: Expression<U>): ToDictFunction<DictType<U>>;
export declare function ToDict<T extends EastType, U extends EastType, V extends T>(collection: EastFunction<{
    type: "dict";
    values: T;
}>, output_value: EastFunction<U>, output_key: Expression<"string">, input_value: Variable<V>, input_key?: Variable<"string">, previous_value?: Variable<U>, initial_value?: Expression<U>): ToDictFunction<DictType<U>>;
export declare function ToDict<T extends Value[], U extends EastTypeOf<ArrayOf<T>>, V extends EastType>(collection: T, output_value: EastFunction<V>, output_key: Expression<"string">, input_value: Variable<U>, input_key?: Variable<"integer">, previous_value?: Variable<V>, initial_value?: Expression<V>): ToDictFunction<DictType<V>>;
/**
 * Return a set containing only values where the `predicate` was `true`.
 *
 * @param collection the {@link Expression} for the input set
 * @param predicate the {@link Expression} to calculate whether to keep the element
 * @param key the {@link Variable} to assign each key of `collection`
 *
 * @category Expression
 *
 * @example
 * ```typescript
 * // ...
 * // Get only the non-null elements of a set
 * SubscriptionProducts: Filter(
 *     Variable("ProductIds", DictType("set")),
 *     Get(
 *         Variable("ProductIsSubscription", "boolean"),
 *         Variable("ProductId", "string")
 *     ),
 *     Variable("ProductId", "string")
 * ),
 * // ...
 * ```
 */
export declare function Filter(collection: Set<string> | EastFunction<"set">, predicate: EastFunction<"boolean">, key: Variable<"string">): FilterFunction<"set">;
/**
 * Return a dictionary containing only values where the `predicate` was `true`.
 *
 * @param collection the {@link Expression} for the input dictionary
 * @param predicate the {@link Expression} to calculate whether to keep the element
 * @param value the {@link Variable} to assign each value of `collection`
 * @param key the {@link Variable} to assign each key of `collection` (optional)
 *
 * @category Expression
 *
 * @example
 * ```typescript
 * // ...
 * // Get only the non-null elements of a dictionary
 * FilteredDict: Filter(
 *     Variable("Dict", DictType("string")),
 *     NotEqual(Variable("Value", "string"), null),
 *     Variable("Value", "string")
 * ),
 * // ...
 * ```
 */
export declare function Filter<T extends EastType>(collection: EastFunction<{
    type: "dict";
    values: T;
}>, predicate: EastFunction<"boolean">, value: Variable<T>, key?: Variable<"string">): FilterFunction<DictType<T>>;
/**
 * Return an array containing only values where the `predicate` was `true`.
 *
 * @param collection the {@link Expression} for the input array
 * @param predicate the {@link Expression} to calculate whether to keep the element
 * @param value the {@link Variable} to assign each value of `collection`
 * @param key the {@link Variable} to assign each key of `collection` (optional)
 *
 * @category Expression
 *
 * @example
 * ```typescript
 * // ...
 * // Get only the non-null elements of an array
 * FilteredArray: Filter(
 *     Variable("Array", ArrayType("string")),
 *     NotEqual(Variable("Value", "string"), null),
 *     Variable("Value", "string"),
 * )
 * // ...
 * ```
 */
export declare function Filter<T extends EastType>(collection: EastFunction<{
    type: "array";
    values: T;
}>, predicate: EastFunction<"boolean">, value: Variable<T>, key?: Variable<"integer">): FilterFunction<ArrayType<T>>;
export declare function Filter<T extends Map<string, Value>, U extends EastTypeOf<MapOf<T>>>(collection: T, predicate: EastFunction<"boolean">, value: Variable<U>, key?: Variable<"string">): FilterFunction<DictType<U>>;
export declare function Filter<T extends Value[], U extends EastTypeOf<ArrayOf<T>>>(collection: T, predicate: EastFunction<"boolean">, value: Variable<U>, key?: Variable<"integer">): FilterFunction<ArrayType<U>>;
/**
 * Return a dictionary mapping the keys of a set through a function. The output keys match
 * the input set.
 *
 * @param collection the {@link Expression} for the input set
 * @param output_value the {@link Expression} to calculate the new dictionary value
 * @param input_key the {@link Variable} to assign each key of `collection`
 *
 * @category Expression
 *
 * @example
 * ```typescript
 * // ...
 * // Create full names for each of a set of employees
 * SomeEmployeeNames: MapDict(
 *     Variable("SomeEmployeeIds", "set"),
 *     StringJoin`${Get(Variable("EmployeeFirstNames", DictType("string")), Variable("EmployeeId", "string"))} ${Get(Variable("EmployeeLastNames", DictType("string")), Variable("EmployeeId", "string"))}`,
 *     Variable("EmployeeId", "string"),
 * ),
 * // ...
 * ```
 */
export declare function MapDict<T extends EastType>(collection: Set<string> | EastFunction<"set">, output_value: EastFunction<T>, input_key: Variable<"string">): MapValuesFunction<DictType<T>>;
/**
 * Return a dictionary mapping the values of a dictionary through a function. The output
 * keys match the keys of the input dictionary.
 *
 * @param collection the {@link Expression} for the input dictionary
 * @param output_value the {@link Expression} to calculate the new dictionary value
 * @param input_value the {@link Variable} to assign each key of `collection`
 * @param input_key the {@link Variable} to assign each key of `collection` (optional)
 *
 * @category Expression
 *
 * @example
 * ```typescript
 * // ...
 * // Calculate the total price from collections of product unit price and quantity
 * ProductTotalPrices: MapDict(
 *     Variable("ProductQuantities", DictType("integer")),
 *     Multiply(
 *         Variable("Quantity", "integer"),
 *         Get(
 *             Variable("ProductUnitPrices", "integer"),
 *             Variable("ProductId", "string")
 *         )
 *     ),
 *     Variable("Quantity", "integer"),
 *     Variable("ProductId", "string")
 * )
 * // ...
 * ```
 */
export declare function MapDict<T extends EastType, U extends EastType, V extends T>(collection: EastFunction<{
    type: "dict";
    values: T;
}>, func: EastFunction<U>, value: Variable<V>, key?: Variable<"string">): MapValuesFunction<DictType<U>>;
export declare function MapDict<T extends Map<string, Value>, U extends EastTypeOf<MapOf<T>>, V extends EastType>(collection: T, func: EastFunction<V>, value: Variable<U>, key?: Variable<"string">): MapValuesFunction<DictType<V>>;
/**
 * Loop over the values in an array in order, performing a reduction.
 *
 * Each reduction starts with an `initial` value. For every element of the collection, the
 * `reducer` calculates a new value based on both the data and the result of the `previous`
 * iteration. The `previous` variable acts to transfer state from one iteration to the next.
 *
 * Reductions can be quite powerful - while many are simple (e.g. summing an array), it
 * is possible to construct rich data structures incrementally through a reduction.
 *
 * @param collection - the {@link Expression} for the input collection to be reduced over
 * @param reducer - an {@link Expression} giving the next value of the reduction, given the values of `previous`, `value` and `key`
 * @param initial - an {@link Expression} for the initial value of the reduction
 * @param previous - a {@link Variable} holding the current state of the reduction
 * @param value - a {@link Variable} holding the next value from the input collection
 * @param key - a {@link Variable} holding the next key from the input collection (optional)
 * @returns The final output of `reducer`, or else `initial` for empty collections
 *
 * @category Expression
 *
 * @example
 * ```typescript
 * // To add up all the values in an array of integers
 * Reduce(
 *     array,
 *     Add(Variable("previous", "integer"), Variable("value", "integer")),
 *     Const(0n),
 *     Variable("previous", "integer"),
 *     Variable("value", "integer")
 * )
 * ```
 */
export declare function Reduce<T extends EastType, U extends EastType, V extends U, W extends U, X extends T>(collection: EastFunction<{
    type: "array";
    values: T;
}>, reducer: EastFunction<V>, initial: Expression<W>, previous: Variable<U>, value: Variable<X>, key?: Variable<"integer">): ReduceFunction<U>;
export declare function Reduce<T extends Value, U extends EastTypeOf<T[]>, V extends EastType, W extends V, X extends V>(collection: T[], reducer: EastFunction<W>, initial: Expression<X>, previous: Variable<V>, value: Variable<U>, key?: Variable<"integer">): ReduceFunction<DictType<V>>;
/**
 * Loop over the values in an array in order, performing a reduction.
 *
 * Each reduction starts with an `initial` value. For every element of the collection, the
 * `reducer` calculates a new value based on both the data and the result of the `previous`
 * iteration. The `previous` variable acts to transfer state from one iteration to the next.
 *
 * Reductions can be quite powerful - while many are simple (e.g. summing an array), it
 * is possible to construct rich data structures incrementally through a reduction.
 *
 * @param collection - the {@link Expression} for the input collection to be reduced over
 * @param reducer - an {@link Expression} giving the next value of the reduction, given the values of `previous`, `value` and `key`
 * @param initial - an {@link Expression} for the initial value of the reduction
 * @param previous - a {@link Variable} holding the current state of the reduction
 * @param key - a {@link Variable} holding the next key from the input collection
 * @returns The final output of `reducer`, or else `initial` for empty collections
 *
 * @category Expression
 *
 * @example
 * ```typescript
 * // Given a `set` of `key`s, calculate the sum of the corresponding values in
 * // an integer dictionary `dict`
 * Reduce(
 *     set,
 *     Add(Variable("previous", "integer"), Get(dict, Variable("key", "string")),
 *     Const(0n),
 *     Variable("previous", "integer"),
 *     Variable("key", "string")
 * )
 * ```
 */
export declare function Reduce<T extends EastType, U extends T, V extends T>(collection: Set<string> | EastFunction<"set">, reducer: EastFunction<U>, initial: Expression<V>, previous: Variable<T>, key: Variable<"string">): ReduceFunction<T>;
/**
 * Loop over the values in an array in order, performing a reduction.
 *
 * Each reduction starts with an `initial` value. For every element of the collection, the
 * `reducer` calculates a new value based on both the data and the result of the `previous`
 * iteration. The `previous` variable acts to transfer state from one iteration to the next.
 *
 * Reductions can be quite powerful - while many are simple (e.g. summing an array), it
 * is possible to construct rich data structures incrementally through a reduction.
 *
 * @param collection - the {@link Expression} for the input collection to be reduced over
 * @param reducer - an {@link Expression} giving the next value of the reduction, given the values of `previous`, `value` and `key`
 * @param initial - an {@link Expression} for the initial value of the reduction
 * @param previous - a {@link Variable} holding the current state of the reduction
 * @param value - a {@link Variable} holding the next value from the input collection
 * @param key - a {@link Variable} holding the next key from the input collection (optional)
 * @returns The final output of `reducer`, or else `initial` for empty collections
 *
 * @category Expression
 *
 * @example
 * ```typescript
 * // To add up all the values in a dictionary integers
 * Reduce(
 *     dict,
 *     Add(Variable("previous", "integer"), Variable("value", "integer")),
 *     Const(0n),
 *     Variable("previous", "integer"),
 *     Variable("value", "integer")
 * )
 * ```
 */
export declare function Reduce<T extends EastType, U extends EastType, V extends U, W extends U, X extends T>(collection: EastFunction<{
    type: "dict";
    values: T;
}>, reducer: EastFunction<V>, initial: Expression<W>, previous: Variable<U>, value: Variable<X>, key?: Variable<"string">): ReduceFunction<U>;
export declare function Reduce<T extends Map<string, Value>, U extends EastTypeOf<MapOf<T>>, V extends EastType, W extends V, X extends V>(collection: T, reducer: EastFunction<W>, initial: Expression<X>, previous: Variable<V>, value: Variable<U>, key?: Variable<"string">): ReduceFunction<DictType<V>>;
/**
 * Sort an array in place, according an ordering defined by the comparison function `isless`.
 * Primitive types will be sorted automatically according to `Less`.
 *
 * @param collection the {@link Expression} for the input array
 * @param isless the {@link Expression} to calculate whether `first` is smaller than `second`
 * @param first the {@link Variable} to assign the first input to `isless`
 * @param input_key the {@link Variable} to assign the second input to `isless`
 *
 * @category Expression
 *
 * @example
 * ```typescript
 * // ...
 * // Sort an array of dates into ascending order
 * SortedDates: Sort(
 *     Variable("Dates", Array("datetime")),
 *     Less(Variable("First", "datetime"), Variable("Second", "datetime")),
 *     Variable("First", "datetime"),
 *     Variable("Second", "datetime")
 * )
 * // ...
 * ```
 */
export declare function Sort<T extends EastType, U extends T, V extends T>(collection: EastFunction<ArrayType<T>>, isless?: Expression<"boolean">, first?: Variable<U>, second?: Variable<V>): SortFunction<ArrayType<T>>;
/**
 * Construct a struct from an expressions for each field.
 *
 * @param fields a record of {@link Expression}s defining the struct
 *
 * @category Expression
 *
 * @example
 * ```typescript
 * // ...
 * // Create an aggregate struct with product data
 * ProductData: Struct({
 *     Id: Variable("ProductId", "string"),
 *     Name: Variable("ProductName", "string"),
 *     UnitPrice: Variable("ProductPrice", "float"),
 *     StockLevel: Variable("ProductStockLevel", "integer"),
 *     StockTakeDate: Variable("ProductStockTakeDate", "datetime"),
 * }),
 * // ...
 * ```
 */
export declare function Struct<T extends Record<string, Expression<EastType>>>(fields: T): StructFunction<{
    type: "struct";
    fields: {
        [K in keyof T]: ExpressionTypeOf<T[K]>;
    };
}>;
/**
 * Fetch the value of one of a struct's fields.
 *
 * @param struct the {@link Expression} for the input struct
 * @param field the name of field to fetch
 *
 * @category Expression
 *
 * @example
 * ```typescript
 * // ...
 * // Get the name of the product from the product data
 * ProductName: GetField(
 *     Variable(product_data, StructType({
 *         Id: "string",
 *         Name: "string",
 *         UnitPrice: "float",
 *         StockLevel: "integer",
 *         StockTakeDate: "datetime",
 *     }),
 *     "Name"
 * ),
 * // ...
 * ```
 */
export declare function GetField<T extends Record<string, EastType>, K extends keyof T>(struct: EastFunction<StructType<T>>, field: K): GetFieldFunction<T[K]>;
export declare function GetField<T extends Record<string, Value>, K extends keyof T>(struct: T, field: K): ConstFunction<EastTypeOf<T[K]>>;
/**
 * Return a helper function that creates {@link Expression}s which construct variants of the given types.
 *
 * @param variants A record matching variant tags to associated East data types
 *
 * @category Expression
 *
 * @example
 * ```typescript
 * const NewMaybe = NewVariant({ Some: "float", None: "null" }
 *
 * // ...
 * // Calculate the average price from an array of historical prices (if any are known)
 * AveragePrice: IfElse(
 *     Greater(Size(Variable("PriceHistory", ArrayType("float"))), 0n),
 *     NewMaybe("Some", Divide(
 *         AddAll(Variable("PriceHistory", ArrayType("float")),
 *         Size(Variable("PriceHistory", ArrayType("float")))))
 *     )),
 *     NewMaybe("None"),
 * )
 * // ...
 * ```
 */
export declare function NewVariant<Variants extends Record<string, EastType>>(variants: Variants): (<Tag extends keyof Variants>(tag: Tag, value: Expression<Variants[Tag]>) => NewVariantFunction<VariantType<Variants>>) & ((tag: {
    [K in keyof Variants]: Variants[K] extends "null" ? K : never;
}[keyof Variants]) => NewVariantFunction<VariantType<Variants>>);
/**
 * Return an {@link Expression} that constructs a variant with a given tag and a `null` value.
 *
 * @param variants A record matching variant tags to associated East data types
 * @param type A "tag" string literal identifying which variant this value is
 *
 * @category Expression
 *
 * @example
 * ```typescript
 * // ...
 * // Calculate the average price from an array of historical prices (if any are known)
 * AveragePrice: IfElse(
 *     Greater(Size(Variable("PriceHistory", ArrayType("float"))), 0n),
 *     NewVariant({ Some: "float", None: "null" }, "Some", Divide(
 *         AddAll(Variable("PriceHistory", ArrayType("float")),
 *         Size(Variable("PriceHistory", ArrayType("float")))))
 *     )),
 *     NewVariant({ Some: "float", None: "null" }, "None"),
 * )
 * // ...
 * ```
 */
export declare function NewVariant<Variants extends Record<string, EastType>>(variants: Variants, tag: {
    [K in keyof Variants]: Variants[K] extends "null" ? K : never;
}[keyof Variants]): NewVariantFunction<VariantType<Variants>>;
/**
* Return an {@link Expression} that constructs a variant with a given tag and value.
*
* @param variants A record matching variant tags to associated East data types
* @param type A "tag" string literal identifying which variant this value is
* @param value The {@link Expression} to create the data assocated with this variant (if required)
*
* @category Expression
*
* @example
* ```typescript
* // ...
* // Last known price is optional
* // Calculate the average price from an array of historical prices (if any are known)
* AveragePrice: IfElse(
*     Greater(Size(Variable("PriceHistory", ArrayType("float"))), 0n),
*     NewVariant({ Some: "float", None: "null" }, "Some", Divide(
*         AddAll(Variable("PriceHistory", ArrayType("float")),
*         Size(Variable("PriceHistory", ArrayType("float")))))
*     )),
*     NewVariant({ Some: "float", None: "null" }, "None"),
* )
* // ...
* ```
*/
export declare function NewVariant<Variants extends Record<string, EastType>, Tag extends keyof Variants>(variants: Variants, tag: Tag, value: Expression<Variants[Tag]>): NewVariantFunction<VariantType<Variants>>;
/**
 * Switch to an expression depending on the tag of a union value.
 *
 * @param input the {@link Expression} for the input variant
 * @param functions the {@link Expression}s to apply to the given tag (each possible tag must be accounted for)
 * @param value the name of the {@link Variable} to give to the data associated with each tag
 *
 * @category Expression
 *
 * @example
 * ```typescript
 * // ...
 * // Get the name of the product from the product data, or else return the string "####"
 * ProductName: Switch(
 *     Variable("ProductName", Variant({ Some: "string", None: "null" })),
 *     {
 *         Some: Variable("name", "string"),
 *         None: "####"
 *     },
 *     "name"
 * )
 * // ...
 * ```
 */
export declare function Switch<Variants extends Record<string, EastType>, Fs extends Record<keyof Variants, EastFunction>>(input: EastFunction<VariantType<Variants>>, functions: Fs, value?: string): MergeTypes<{
    [Tag in keyof Variants]: Fs[Tag]["type"];
}> extends never ? unknown : {
    ast_type: "Switch";
    type: MergeTypes<{
        [Tag in keyof Variants]: Fs[Tag]["type"];
    }>;
    input: EastFunction<VariantType>;
    functions: Record<string, EastFunction>;
    value: string | null;
};
