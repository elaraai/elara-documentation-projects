// Â© Copyright 2018- 2022 - Elara AI Pty Ltd ACN 627 124 903
//
// Licensed under the EDK Licence version LICENSE-1.04.
//
// You may only use this file in accordance with the terms and conditions contained in EDK
// Licence - Version LICENSE-1.04. The full version of the EDK Licence is available at:
// https://elaraai.github.io/docs/license

import { Expression } from './definition';
import { CalendarUnit, EastFunction, TimeUnit, Variable } from './functions';
import { ArrayType, DictType, EastType, NumericType, PrimitiveType, StructType } from './types';
/**
 * Return the lesser of `a` and `b`, ignoring `null`.
 *
 * @category StdLib
 */
export declare function Min<T extends PrimitiveType, U extends T>(a: Expression<T>, b: Expression<U>): EastFunction<U>;
/**
 * Return the greater of `a` and `b`, ignoring `null`.
 *
 * @category StdLib
 */
export declare function Max<T extends PrimitiveType, U extends T>(a: Expression<T>, b: Expression<U>): EastFunction<U>;
/**
 * Return true if `value` is `null` or `false` otherwise.
 *
 * @category StdLib
 */
export declare function IsNull(value: Expression<EastType>): EastFunction<"boolean">;
/**
 * Return true if `value` is `null` or `false` otherwise.
 *
 * @category StdLib
 */
export declare function IsNotNull(value: Expression<EastType>): EastFunction<"boolean">;
/**
 * Round datetime `value` down to a whole time `unit` ("year", "month", "week", "day", "hour", "minute", "second")."
 *
 * @category StdLib
 */
export declare function Floor(value: Expression<"datetime">, unit: TimeUnit | CalendarUnit): EastFunction<"datetime">;
/**
 * Round number `value` down to nearest integer"
 *
 * @category StdLib
 */
export declare function Floor(value: Expression<"float">, type: "integer"): EastFunction<"integer">;
/**
 * Round number `value` down to a whole number."
 *
 * @category StdLib
 */
export declare function Floor(value: Expression<"float">, type?: "float"): EastFunction<"float">;
/**
 * Round datetime `value` up to a whole time `unit` ("year", "month", "week", "day", "hour", "minute", "second")."
 *
 * @category StdLib
 */
export declare function Ceiling(value: Expression<"datetime">, unit: TimeUnit | CalendarUnit): EastFunction<"datetime">;
/**
 * Round number `value` up to a whole number."
 *
 * @category StdLib
 */
export declare function Ceiling(value: Expression<"float">, type?: "float" | "integer"): EastFunction<"float">;
/**
 * Return the number of whole weeks elapsed since the first Monday prior to or of the first day of the month.
 *
 * @category StdLib
 */
export declare function WeekOfMonth(date: Expression<"datetime">): EastFunction<"integer">;
/**
 * Convert a float {@link DictType} to an integer {@link DictType}.
 *
 * @category StdLib
 */
export declare function ConvertFloatDict(dict: EastFunction<DictType<"float">>): EastFunction<DictType<"integer">>;
/**
 * Convert an integer {@link DictType} to an float {@link DictType}.
 *
 * @category StdLib
 */
export declare function ConvertIntegerDict(dict: EastFunction<DictType<"integer">>): EastFunction<DictType<"float">>;
/**
 * Convert a number {@link Expression} to a magnitude string between ['negligible', 'moderate', 'large'].
 *
 * @category StdLib
 */
export declare function Importance(domain: Expression<"float">, range?: [negligible: number, moderate: number]): import("./functions").IfElseFunction<"string">;
/**
 * Return a comma seperated and rounded currency string from an integer.
 *
 * @category StdLib
 */
export declare function PrintTruncatedCurrency(value: Expression<'integer'>): EastFunction<"string">;
/**
 * Return a comma seperated and rounded currency string from a number.
 *
 * @category StdLib
 */
export declare function PrintTruncatedCurrency(value: Expression<'float'>): EastFunction<"string">;
/**
 * Return the a boolean function to determine if a datetime {@link Expression} falls on a Monday.
 *
 * @category StdLib
 */
export declare function IsMonday(date: Expression<"datetime">): EastFunction<"boolean">;
/**
 * Return the a boolean function to determine if a datetime {@link Expression} falls on a Tuesday.
 *
 * @category StdLib
 */
export declare function IsTuesday(date: Expression<"datetime">): EastFunction<"boolean">;
/**
 * Return the a boolean function to determine if a datetime {@link Expression} falls on a Wednesday.
 *
 * @category StdLib
 */
export declare function IsWednesday(date: Expression<"datetime">): EastFunction<"boolean">;
/**
 * Return the a boolean function to determine if a datetime {@link Expression} falls on a Thursday.
 *
 * @category StdLib
 */
export declare function IsThursday(date: Expression<"datetime">): EastFunction<"boolean">;
/**
 * Return the a boolean function to determine if a datetime {@link Expression} falls on a Friday.
 *
 * @category StdLib
 */
export declare function IsFriday(date: Expression<"datetime">): EastFunction<"boolean">;
/**
 * Return the a boolean function to determine if a datetime {@link Expression} falls on a Saturday.
 *
 * @category StdLib
 */
export declare function IsSaturday(date: Expression<"datetime">): EastFunction<"boolean">;
/**
 * Return the a boolean function to determine if a datetime {@link Expression} falls on a Sunday.
 *
 * @category StdLib
 */
export declare function IsSunday(date: Expression<"datetime">): EastFunction<"boolean">;
/**
 * Return the a boolean function to determine if a datetime {@link Expression} falls on a weekend.
 *
 * @category StdLib
 */
export declare function IsWeekend(date: Expression<"datetime">): EastFunction<"boolean">;
/**
 * Return the a boolean function to determine if a datetime {@link Expression} falls on a weekday.
 *
 * @category StdLib
 */
export declare function IsWeekday(date: Expression<"datetime">): EastFunction<"boolean">;
/**
 * Return a {@link Print} function to convert a datetime {@link Expression} to a day of week name.
 *
 * @category StdLib
 */
export declare function DayName(date: Expression<"datetime">): import("./functions").GetFunction<"string">;
/**
 * Return a {@link Print} function to convert a datetime {@link Expression} to an abbreviated day of week name.
 *
 * @category StdLib
 */
export declare function DayNameShort(date: Expression<"datetime">): import("./functions").GetFunction<"string">;
/**
 * Return a {@link Print} function to convert a datetime {@link Expression} to an abbreviated month name.
 *
 * @category StdLib
 */
export declare function MonthNameShort(date: Expression<"datetime">): import("./functions").GetFunction<"string">;
/**
 * Return `value` unless it equals `from`, in which case replace it with `to`.
 *
 * @category StdLib
 */
export declare function Replace<T extends PrimitiveType, U extends T, V extends T>(value: Expression<T>, from: Expression<U>, to: Expression<V>): EastFunction<T>;
export declare function Replace<T extends EastType, U extends T, V extends T>(value: Expression<T>, from: null, to: Expression<V>): EastFunction<T>;
/**
 * Return `true` if `collection` has zero elements, or `false` otherwise.
 *
 * @category StdLib
 */
export declare function IsEmpty(collection: Expression<"set" | DictType>): EastFunction<"boolean">;
/**
 * Return the absolute value of a number or integer {@link Expression}.
 *
 * @category StdLib
 */
export declare function Abs(x: Expression<"integer">): EastFunction<"integer">;
export declare function Abs(x: Expression<"float">): EastFunction<"float">;
/**
 * Add all collection values into a single float or integer {@link Expression}.
 *
 * @category StdLib
 */
export declare function AddAll(collection: Expression<ArrayType<"float">>): EastFunction<"float">;
export declare function AddAll(collection: Expression<ArrayType<"integer">>): EastFunction<"integer">;
export declare function AddAll(collection: Expression<DictType<"float">>): EastFunction<"float">;
export declare function AddAll(collection: Expression<DictType<"integer">>): EastFunction<"integer">;
/**
 * Union all sets in `collection` into a single set {@link Expression}.
 *
 * @category StdLib
 */
export declare function UnionAll(collection: Expression<ArrayType<"set">>): EastFunction<"set">;
export declare function UnionAll(collection: Expression<DictType<"set">>): EastFunction<"set">;
/**
 * Find the minimum value in `collection` {@link Expression}.
 *
 * @category StdLib
 */
export declare function MinAll<T extends PrimitiveType>(collection: Expression<ArrayType<T>>): EastFunction<T>;
export declare function MinAll<T extends PrimitiveType>(collection: Expression<DictType<T>>): EastFunction<T>;
/**
 * Find the maximum value in `collection` {@link Expression}.
 *
 * @category StdLib
 */
export declare function MaxAll<T extends PrimitiveType>(collection: Expression<ArrayType<T>>): EastFunction<T>;
export declare function MaxAll<T extends PrimitiveType>(collection: Expression<DictType<T>>): EastFunction<T>;
/**
 * Return a {@link Print} function to convert a cycle {@link Expression} to an abbreviated week description.
 *
 * @category StdLib
 */
export declare function WeekDescription(cycle: Variable<"integer">): import("./functions").IfElseFunction<"string" | ("string" & {
    type: "array";
    values: EastType;
}) | ("string" & {
    type: "dict";
    values: EastType;
}) | ("string" & {
    type: "variant";
    tags: Record<string, EastType>;
}) | ("string" & {
    type: "struct";
    fields: Record<string, EastType>;
})>;
/**
 * Return the hour of day in am/pm form ("7am", "5pm", etc)
 *
 * @category StdLib
 */
export declare function HourName(hour: Expression<"integer">): EastFunction<"string">;
/**
 * Return the hour of day in am/pm form ("7am", "5pm", etc)
 *
 * @category StdLib
 */
export declare function HourName(hour: Expression<"datetime">): EastFunction<"string">;
/**
 * Print a number with a seperator between the thousands, e.g. 1234 as "1,234"
 *
 * @category StdLib
 */
export declare function PrintSeperated(x: Expression<"integer" | "float">, thousands_seperator: string): EastFunction<"string">;
/**
 * Return a {@link ArrayType} {@link EastFunction} to convert a dictionary into an array of key & value pairs
 *
 * @category StdLib
 */
export declare function ToEntries<T extends EastType>(dict: EastFunction<DictType<T>>): EastFunction<ArrayType<StructType<{
    Key: 'string';
    Value: T;
}>>>;
/**
 * Return a number {@link EastFunction} to peform a + b*x
 *
 * @category StdLib
 */
export declare function AddMultiply(a: Expression<"integer" | "float">, b: Expression<"integer" | "float">, x: Expression<"integer" | "float">): EastFunction<"float">;
/**
 * Return a number {@link EastFunction} to peform ...
 *
 * @category StdLib
 */
export declare function Sigmoid(x: Expression<"float">): EastFunction<"float">;
/**
 * Convenience function to convert a datetime into a string for a key, rounding optional.
 *
 * @category StdLib
 */
export declare function DateKey(value: EastFunction<"datetime">, unit?: TimeUnit | CalendarUnit): EastFunction<"string">;
/**
 * Convenience function to convert one or more expressions into a string for a key.
 *
 * @category StdLib
 */
export declare function PrimaryKey(...values: EastFunction<PrimitiveType>[]): EastFunction<"string">;
/**
 * Multiply `first` by `second` where both are dictionaries.
 *
 * @param first the first {@link Expression} to multiply
 * @param second the second {@link Expression} to multiply
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return the products revenue by multiplying the prices by the qtys
 *  Amounts: MultiplyDict(
 *      Variable('UnitPrices', DictType('float')),
 *      Variable('Quantities', DictType('float'))
 *  ),
 *  // ...
 * ```
 */
export declare function MultiplyDict<X extends "float" | "integer", Y extends "float" | "integer">(first: Expression<DictType<X>>, second: Expression<DictType<Y>>): EastFunction<DictType<'float'>>;
/**
 * Divide `first` by `second` where both are dictionaries.
 *
 * @param first the first {@link Expression} to divide
 * @param second the second {@link Expression} to divide
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return the prices by dividing the total amounts by the qtys
 *  UnitPrices: DivideDict(
 *      Variable('Amounts', DictType('float')),
 *      Variable('Quantities', DictType('float'))
 *  ),
 *  // ...
 * ```
 */
export declare function DivideDict<X extends "float" | "integer", Y extends "float" | "integer">(first: Expression<DictType<X>>, second: Expression<DictType<Y>>): EastFunction<DictType<'float'>>;
/**
 * Add `first` to `second` where both are dictionaries.
 *
 * @param first the first {@link Expression} to add
 * @param second the second {@link Expression} to add
 *
 * @remarks Missing keys between first and second are assumed to have a value of 0.
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return the prices by dividing the total amounts by the qtys
 *  NewBalance: AddDict(
 *      Variable('InitialBalance', DictType('float')),
 *      Variable('Amount', DictType('float'))
 *  ),
 *  // ...
 * ```
 */
export declare function AddDict<T extends NumericType>(d1: EastFunction<DictType<T>>, d2: EastFunction<DictType<T>>): import("./functions").ReduceFunction<DictType<T>, EastType>;
/**
 * Add `first` to `second` where first is a dictionary, and second a scalar.
 *
 * @param first the first {@link Expression} to add
 * @param second the second {@link Expression} to add
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return an updated balance by adding an relevant dictionary values to all dictionary values
 *  NewBalance: AddDict(
 *      Variable('InitialBalance', DictType('float')),
 *      Variable('Amount', 'float')
 *  ),
 *  // ...
 * ```
 */
export declare function AddDictScalar<T extends NumericType>(d1: EastFunction<DictType<T>>, d2: EastFunction<T>): import("./functions").ReduceFunction<DictType<T>, EastType>;
/**
 * Subtract `second` from `first` where both are dictionaries,
 *
 * @param first the first {@link Expression} to subtract
 * @param second the second {@link Expression} to subtract
 *
 * @remarks Missing keys between first and second are assumed to have a value of 0.
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return an updated balance by subtracting an relevant dictionary values from all dictionary values
 *  NewBalance: SubtractDict(
 *      Variable('InitialBalance', DictType('float')),
 *      Variable('Amount', DictType('float'))
 *  ),
 *  // ...
 * ```
 */
export declare function SubtractDict<T extends NumericType>(d1: EastFunction<DictType<T>>, d2: EastFunction<DictType<T>>): import("./functions").ReduceFunction<DictType<T>, EastType>;
/**
 * Subtract `second` from `first` where first is a dictionary, and second a scalar. ,
 *
 * @param first the first {@link Expression} to subtract
 * @param second the second {@link Expression} to subtract
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // ...
 *  // return an updated balance by subtracting an amount from all dictionary values
 *  NewBalance: SubtractDict(
 *      Variable('InitialBalance', DictType('float')),
 *      Variable('Amount', 'float')
 *  ),
 *  // ...
 * ```
 */
export declare function SubtractDictScalar<T extends NumericType>(d1: EastFunction<DictType<T>>, d2: EastFunction<T>): import("./functions").ReduceFunction<DictType<T>, EastType>;
/**
 * Apply a normalised gaussian random number to perturb a variable.
 *
 * @param value the value {@link Expression} to perturb
 * @param random the random {@link Expression} containing the normalised gaussian random number
 *
 * @category Expression
 *
 * @example
 * ```typescript
 *  // perturb `Value` with a random number
 *  Value: Perturb(
 *      Variable('Value', 'float'),
 *      Variable('Random', 'float'),
 *      5.0,
 *      1.0
 *  ),
 *  // ...
 * ```
 */
export declare function Perturb(value: Expression<'float'>, random: Expression<'float'>, mean: Expression<'float'>, stddev: Expression<'float'>): import("./functions").MultiplyFunction<"float">;
