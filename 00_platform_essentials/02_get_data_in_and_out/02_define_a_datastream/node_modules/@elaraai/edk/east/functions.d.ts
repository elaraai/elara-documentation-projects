// Â© Copyright 2018- 2022 - Elara AI Pty Ltd ACN 627 124 903
//
// Licensed under the EDK Licence version LICENSE-1.04.
//
// You may only use this file in accordance with the terms and conditions contained in EDK
// Licence - Version LICENSE-1.04. The full version of the EDK Licence is available at:
// https://elaraai.github.io/docs/license

import { ArrayType, DictType, EastType, PrimitiveType, StructType, ValueTypeOf, VariantType } from './types';
/**
 * A unit of time.
 *
 * @category Utility
 */
export declare type TimeUnit = "millisecond" | "second" | "minute" | "hour" | "day" | "week";
/** @internal */
export declare type TimeSpan = {
    value: number;
    unit: TimeUnit;
};
/**
 * A span of time.
 * @param value: the length of the `TimeSpan`
 * @param unit: the units of the `TimeSpan`
 * @returns The `TimeSpan` definition
 *
 * @category Utility
 *
 * @example
 * ```typescript
 * //Create a timespan of one hour.
 * const timespan = TimeSpan(1, 'hour')
 * ```
 */
export declare function TimeSpan(value: number, unit?: TimeUnit): {
    value: number;
    unit: TimeUnit;
};
/**
 * A unit of calendar time.
 *
 * @category Utility
 */
export declare type CalendarUnit = "month" | "year";
/**
 * A subset ot {@link EastType} relating to {@link Environment}'s'.
 *
 * @category Type
 *
 */
export declare type EnvironmentType<T extends "boolean" | "string" | "float" = "boolean" | "string" | "float"> = EnvironmentFunction<T> | ConstFunction<T> | StringJoinFunction<T> | PrintFunction<T>;
/**
 * Denotes a function returning {@link EastType}.
 *
 * @category Expression
 */
export interface EastFunction<T extends EastType = EastType> {
    type: T;
    ast_type: AstType;
}
/** @internal */
export declare type AstType = "Variable" | "Property" | "Environment" | "Const" | "Let" | "IfElse" | "Convert" | "Parse" | "Print" | "Not" | "And" | "Or" | "Equal" | "NotEqual" | "Less" | "LessEqual" | "Greater" | "GreaterEqual" | "Add" | "Subtract" | "Multiply" | "Divide" | "Modulo" | "Round" | "RoundPrecision" | "Sqrt" | "Log" | "Exp" | "Pow" | "ToDateTime" | "Duration" | "AddDuration" | "SubtractDuration" | "TimeZoneConvert" | "Millisecond" | "Second" | "Minute" | "Hour" | "DayOfWeek" | "DayOfMonth" | "Month" | "Year" | "Substring" | "StringJoin" | "RegexReplace" | "RegexContains" | "UpperCase" | "LowerCase" | "ToJson" | "FromJson" | "Hash" | "HMAC" | "Base64ToAscii" | "AsciiToBase64" | "Base64ToHex" | "HexToBase64" | "URIEncode" | "URIDecode" | "In" | "SubsetEqual" | "Union" | "Intersect" | "SetDiff" | "SymDiff" | "Keys" | "OnlyKey" | "Get" | "NewSet" | "NewDict" | "NewArray" | "Range" | "ToSet" | "ToArray" | "ToDict" | "Insert" | "Delete" | "Size" | "Filter" | "MapDict" | "Reduce" | "Sort" | "Struct" | "GetField" | "NewVariant" | "Switch";
/** @internal */
export declare type Variable<T extends EastType = EastType> = {
    type: T;
    ast_type: "Variable";
    name: string;
};
/** @internal */
export declare function isVariable<T extends EastType>(f: EastFunction<T>): f is Variable<T>;
/**
 * Denotes a variable with a given name and data type.
 *
 * @category Expression
 */
export declare function Variable<T extends EastType>(name: string, type: T): Variable<T>;
/** @internal */
export declare type Property<T extends EastType = EastType> = {
    type: T;
    ast_type: "Property";
    name: string;
};
/** @internal */
export declare function isProperty<T extends EastType>(f: EastFunction<T>): f is Property<T>;
/**
 * Denotes a local property with a given name and data type.
 *
 * @category Expression
 */
export declare function Property<T extends EastType>(name: string, type: T): Property<T>;
/** @internal */
export declare type EnvironmentFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Environment";
    name: string;
};
/** @internal */
export declare function isEnvironmentFunction<T extends EastType>(f: EastFunction<T>): f is EnvironmentFunction<T>;
/** @internal */
export declare type ConstFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Const";
    value: ValueTypeOf<T> | null;
};
/** @internal */
export declare function isConstFunction<T extends EastType>(f: EastFunction<T>): f is ConstFunction<T>;
/** @internal */
export declare type LetFunction<T extends EastType = EastType, U extends EastType = EastType> = {
    type: T;
    ast_type: "Let";
    ast: EastFunction<T>;
    variable: Variable<U>;
    value: EastFunction<U>;
};
/** @internal */
export declare function isLetFunction<T extends EastType>(f: EastFunction<T>): f is LetFunction<T>;
/** @internal */
export declare type IfElseFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "IfElse";
    predicate: EastFunction<"boolean">;
    true: EastFunction<T>;
    false: EastFunction<T>;
};
/** @internal */
export declare function isIfElseFunction<T extends EastType>(f: EastFunction<T>): f is IfElseFunction<T>;
/** @internal */
export declare type ConvertFunction<T extends EastType = EastType, U extends EastType = EastType> = {
    type: T;
    ast_type: "Convert";
    from: EastFunction<U>;
};
/** @internal */
export declare function isConvertFunction<T extends EastType>(f: EastFunction<T>): f is ConvertFunction<T>;
/** @internal */
export declare type ArrayParseSchema = {
    type: "array";
    format: "array";
    values: ParseSchema;
};
/** @internal */
export declare type SetParseSchema = {
    type: "set";
    format: "array";
};
/** @internal */
export declare type DictParseSchema = {
    type: "dict";
    format: "object";
    values: ParseSchema;
};
/** @internal */
export declare type StructParseSchema = {
    type: "struct";
    format: "object";
    fields: Record<string, ParseSchema>;
};
/** @internal */
export declare type ParseSchema = string | SetParseSchema | DictParseSchema | StructParseSchema | ArrayParseSchema | undefined;
/** @internal */
export declare type ParseFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Parse";
    from: EastFunction<T>;
    format?: ParseSchema;
};
/** @internal */
export declare function isParseFunction<T extends EastType>(f: EastFunction<T>): f is ParseFunction<T>;
/** @internal */
export declare type PrintFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Print";
    value: EastFunction<PrimitiveType>;
    format?: string;
};
/** @internal */
export declare function isPrintFunction<T extends EastType>(f: EastFunction<T>): f is PrintFunction<T>;
/** @internal */
export declare type NotFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Not";
    value: EastFunction<"boolean">;
};
/** @internal */
export declare function isNotFunction<T extends EastType>(f: EastFunction<T>): f is NotFunction<T>;
/** @internal */
export declare type AndFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "And";
    first: EastFunction<"boolean">;
    second: EastFunction<"boolean">;
};
/** @internal */
export declare function isAndFunction<T extends EastType>(f: EastFunction<T>): f is AndFunction<T>;
/** @internal */
export declare type OrFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Or";
    first: EastFunction<"boolean">;
    second: EastFunction<"boolean">;
};
/** @internal */
export declare function isOrFunction<T extends EastType>(f: EastFunction<T>): f is OrFunction<T>;
/** @internal */
export declare type EqualFunction<Out extends EastType = EastType, In extends EastType = EastType> = {
    type: Out;
    ast_type: "Equal";
    first: EastFunction<In>;
    second: EastFunction<In>;
};
/** @internal */
export declare function isEqualFunction<T extends EastType>(f: EastFunction<T>): f is EqualFunction<T>;
/** @internal */
export declare type NotEqualFunction<Out extends EastType = EastType, In extends EastType = EastType> = {
    type: Out;
    ast_type: "NotEqual";
    first: EastFunction<In>;
    second: EastFunction<In>;
};
/** @internal */
export declare function isNotEqualFunction<T extends EastType>(f: EastFunction<T>): f is NotEqualFunction<T>;
/** @internal */
export declare type LessFunction<Out extends EastType = EastType, In extends EastType = EastType> = {
    type: Out;
    ast_type: "Less";
    first: EastFunction<In>;
    second: EastFunction<In>;
};
/** @internal */
export declare function isLessFunction<T extends EastType>(f: EastFunction<T>): f is LessFunction<T>;
/** @internal */
export declare type LessEqualFunction<Out extends EastType = EastType, In extends EastType = EastType> = {
    type: Out;
    ast_type: "LessEqual";
    first: EastFunction<In>;
    second: EastFunction<In>;
};
/** @internal */
export declare function isLessEqualFunction<T extends EastType>(f: EastFunction<T>): f is LessEqualFunction<T>;
/** @internal */
export declare type GreaterFunction<Out extends EastType = EastType, In extends EastType = EastType> = {
    type: Out;
    ast_type: "Greater";
    first: EastFunction<In>;
    second: EastFunction<In>;
};
/** @internal */
export declare function isGreaterFunction<T extends EastType>(f: EastFunction<T>): f is GreaterFunction<T>;
/** @internal */
export declare type GreaterEqualFunction<Out extends EastType = EastType, In extends EastType = EastType> = {
    type: Out;
    ast_type: "GreaterEqual";
    first: EastFunction<In>;
    second: EastFunction<In>;
};
/** @internal */
export declare function isGreaterEqualFunction<T extends EastType>(f: EastFunction<T>): f is GreaterEqualFunction<T>;
/** @internal */
export declare type AddFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Add";
    first: EastFunction<"float" | "integer">;
    second: EastFunction<"float" | "integer">;
};
/** @internal */
export declare function isAddFunction<T extends EastType>(f: EastFunction<T>): f is AddFunction<T>;
/** @internal */
export declare type SubtractFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Subtract";
    first: EastFunction<"float" | "integer">;
    second: EastFunction<"float" | "integer">;
};
/** @internal */
export declare function isSubtractFunction<T extends EastType>(f: EastFunction<T>): f is SubtractFunction<T>;
/** @internal */
export declare type MultiplyFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Multiply";
    first: EastFunction<"float" | "integer">;
    second: EastFunction<"float" | "integer">;
};
/** @internal */
export declare function isMultiplyFunction<T extends EastType>(f: EastFunction<T>): f is MultiplyFunction<T>;
/** @internal */
export declare type DivideFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Divide";
    first: EastFunction<"float">;
    second: EastFunction<"float">;
};
/** @internal */
export declare function isDivideFunction<T extends EastType>(f: EastFunction<T>): f is DivideFunction<T>;
/** @internal */
export declare type ModuloFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Modulo";
    first: EastFunction<"float" | "integer">;
    second: EastFunction<"integer">;
};
/** @internal */
export declare function isModuloFunction<T extends EastType>(f: EastFunction<T>): f is ModuloFunction<T>;
/**
 * A mode to apply in rounding
 *
 * @category Expression
 */
export declare type RoundingMode = "nearest" | "floor" | "ceiling";
/** @internal */
export declare type RoundFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Round";
    rounding_mode: RoundingMode;
    value: EastFunction<T>;
    unit?: TimeUnit | CalendarUnit;
};
/** @internal */
export declare function isRoundFunction<T extends EastType>(f: EastFunction<T>): f is RoundFunction<T>;
/** @internal */
export declare type RoundPrecisionFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "RoundPrecision";
    value: EastFunction<T>;
    significant_digits: number;
};
/** @internal */
export declare function isRoundPrecisionFunction<T extends EastType>(f: EastFunction<T>): f is RoundFunction<T>;
/** @internal */
export declare type SqrtFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Sqrt";
    value: EastFunction<"integer" | "float">;
};
/** @internal */
export declare function isSqrtFunction<T extends EastType>(f: EastFunction<T>): f is SqrtFunction<T>;
/** @internal */
export declare type LogFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Log";
    value: EastFunction<"float">;
};
/** @internal */
export declare function isLogFunction<T extends EastType>(f: EastFunction<T>): f is LogFunction<T>;
/** @internal */
export declare type ExpFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Exp";
    value: EastFunction<"float">;
};
/** @internal */
export declare function isExpFunction<T extends EastType>(f: EastFunction<T>): f is ExpFunction<T>; /** @internal */
export declare type PowFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Pow";
    first: EastFunction<"float">;
    second: EastFunction<"float">;
};
/** @internal */
export declare function isPowFunction<T extends EastType>(f: EastFunction<T>): f is PowFunction<T>;
/** @internal */
export declare type ToDateTimeFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "ToDateTime";
    value: EastFunction<"string">;
    format?: string;
};
/** @internal */
export declare function isToDateTimeFunction<T extends EastType>(f: EastFunction<T>): f is ToDateTimeFunction<T>;
/** @internal */
export declare type DurationFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Duration";
    start: EastFunction<"datetime">;
    stop: EastFunction<"datetime">;
    unit: TimeUnit;
};
/** @internal */
export declare function isDurationFunction<T extends EastType>(f: EastFunction<T>): f is DurationFunction<T>;
/** @internal */
export declare type AddDurationFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "AddDuration";
    start: EastFunction<"datetime">;
    duration: EastFunction<"float">;
    unit: TimeUnit;
};
/** @internal */
export declare function isAddDurationFunction<T extends EastType>(f: EastFunction<T>): f is AddDurationFunction<T>;
/** @internal */
export declare type SubtractDurationFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "SubtractDuration";
    start: EastFunction<"datetime">;
    duration: EastFunction<"float">;
    unit: TimeUnit;
};
/** @internal */
export declare function isSubtractDurationFunction<T extends EastType>(f: EastFunction<T>): f is SubtractDurationFunction<T>;
/** @internal */
export declare type TimeZoneConvertFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "TimeZoneConvert";
    input: EastFunction<"datetime">;
    input_timezone: EastFunction<"string">;
    output_timezone: EastFunction<"string">;
};
/** @internal */
export declare function isTimeZoneConvertFunction<T extends EastType>(f: EastFunction<T>): f is TimeZoneConvertFunction<T>;
/** @internal */
export declare type MillisecondFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Millisecond";
    datetime: EastFunction<"datetime">;
};
/** @internal */
export declare function isMillisecondFunction<T extends EastType>(f: EastFunction<T>): f is MillisecondFunction<T>;
/** @internal */
export declare type SecondFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Second";
    datetime: EastFunction<"datetime">;
};
/** @internal */
export declare function isSecondFunction<T extends EastType>(f: EastFunction<T>): f is SecondFunction<T>;
/** @internal */
export declare type MinuteFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Minute";
    datetime: EastFunction<"datetime">;
};
/** @internal */
export declare function isMinuteFunction<T extends EastType>(f: EastFunction<T>): f is MinuteFunction<T>;
/** @internal */
export declare type HourFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Hour";
    datetime: EastFunction<"datetime">;
};
/** @internal */
export declare function isHourFunction<T extends EastType>(f: EastFunction<T>): f is HourFunction<T>;
/** @internal */
export declare type DayOfWeekFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "DayOfWeek";
    datetime: EastFunction<"datetime">;
};
/** @internal */
export declare function isDayOfWeekFunction<T extends EastType>(f: EastFunction<T>): f is DayOfWeekFunction<T>;
/** @internal */
export declare type DayOfMonthFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "DayOfMonth";
    datetime: EastFunction<"datetime">;
};
/** @internal */
export declare function isDayOfMonthFunction<T extends EastType>(f: EastFunction<T>): f is DayOfMonthFunction<T>;
/** @internal */
export declare type MonthFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Month";
    datetime: EastFunction<"datetime">;
};
/** @internal */
export declare function isMonthFunction<T extends EastType>(f: EastFunction<T>): f is MonthFunction<T>;
/** @internal */
export declare type YearFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Year";
    datetime: EastFunction<"datetime">;
};
/** @internal */
export declare function isYearFunction<T extends EastType>(f: EastFunction<T>): f is YearFunction<T>;
/** @internal */
export declare type SubstringFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "Substring";
    value: EastFunction<"string">;
    start: number;
    stop: number;
};
/** @internal */
export declare function isSubstringFunction<T extends EastType>(f: EastFunction<T>): f is SubstringFunction<T>;
/** @internal */
export declare type StringJoinFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "StringJoin";
    values: EastFunction<"string">[];
    seperator: string;
};
/** @internal */
export declare function isStringJoinFunction<T extends EastType>(f: EastFunction<T>): f is StringJoinFunction<T>;
/** @internal */
export declare type RegexReplaceFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "RegexReplace";
    value: EastFunction<"string">;
    search: string;
    replace: EastFunction<"string">;
    flags: string;
    regex?: RegExp;
};
/** @internal */
export declare function isRegexReplaceFunction<T extends EastType>(f: EastFunction<T>): f is RegexReplaceFunction<T>;
/** @internal */
export declare type RegexContainsFunction<T extends EastType = EastType> = {
    ast_type: "RegexContains";
    type: T;
    value: EastFunction<"string">;
    search: string;
    flags: string;
    regex?: RegExp;
};
/** @internal */
export declare function isRegexContainsFunction<T extends EastType>(f: EastFunction<T>): f is RegexContainsFunction<T>;
/** @internal */
export declare type UpperCaseFunction<T extends EastType = EastType> = {
    ast_type: "UpperCase";
    type: T;
    value: EastFunction<"string">;
};
/** @internal */
export declare function isUpperCaseFunction<T extends EastType>(f: EastFunction<T>): f is UpperCaseFunction<T>;
/** @internal */
export declare type LowerCaseFunction<T extends EastType = EastType> = {
    ast_type: "LowerCase";
    type: T;
    value: EastFunction<"string">;
};
/** @internal */
export declare function isLowerCaseFunction<T extends EastType>(f: EastFunction<T>): f is LowerCaseFunction<T>;
/** @internal */
export declare type ToJsonFunction<T extends EastType = EastType> = {
    ast_type: "ToJson";
    type: T;
    value: EastFunction;
};
/** @internal */
export declare function isToJsonFunction<T extends EastType>(f: EastFunction<T>): f is ToJsonFunction<T>;
/** @internal */
export declare type FromJsonFunction<T extends EastType = EastType> = {
    ast_type: "FromJson";
    type: T;
    value: EastFunction<"string">;
};
/** @internal */
export declare function isFromJsonFunction<T extends EastType>(f: EastFunction<T>): f is FromJsonFunction<T>;
/**
 * A type of hasing algorithm
 *
 * @category Expression
 */
export declare type HashType = "md5" | "sha1" | "sha256" | "sha224" | "sha512" | "sha384" | "sha3" | "ripemd160";
/** @internal */
export declare type HashFunction<T extends EastType = EastType> = {
    ast_type: "Hash";
    type: T;
    value: EastFunction<"string">;
    hash: HashType;
    encoding: "base64" | "hex";
};
/** @internal */
export declare function isHashFunction<T extends EastType>(f: EastFunction<T>): f is HashFunction<T>;
/** @internal */
export declare type HMACFunction<T extends EastType = EastType> = {
    ast_type: "HMAC";
    type: T;
    value: EastFunction<"string">;
    key: EastFunction<"string">;
    hash: HashType;
    encoding: "base64" | "hex";
};
/** @internal */
export declare function isHMACFunction<T extends EastType>(f: EastFunction<T>): f is HMACFunction<T>;
/** @internal */
export declare type Base64ToAsciiFunction<T extends EastType = EastType> = {
    ast_type: "Base64ToAscii";
    type: T;
    value: EastFunction<"string">;
};
/** @internal */
export declare function isBase64ToAsciiFunction<T extends EastType>(f: EastFunction<T>): f is Base64ToAsciiFunction<T>;
/** @internal */
export declare type AsciiToBase64Function<T extends EastType = EastType> = {
    ast_type: "AsciiToBase64";
    type: T;
    value: EastFunction<"string">;
};
/** @internal */
export declare function isAsciiToBase64Function<T extends EastType>(f: EastFunction<T>): f is AsciiToBase64Function<T>;
/** @internal */
export declare type Base64ToHexFunction<T extends EastType = EastType> = {
    ast_type: "Base64ToHex";
    type: T;
    value: EastFunction<"string">;
};
/** @internal */
export declare function isBase64ToHexFunction<T extends EastType>(f: EastFunction<T>): f is Base64ToHexFunction<T>;
/** @internal */
export declare type HexToBase64Function<T extends EastType = EastType> = {
    ast_type: "HexToBase64";
    type: T;
    value: EastFunction<"string">;
};
/** @internal */
export declare function isHexToBase64Function<T extends EastType>(f: EastFunction<T>): f is HexToBase64Function<T>;
/** @internal */
export declare type URIEncodeFunction<T extends EastType = EastType> = {
    ast_type: "URIEncode";
    type: T;
    value: EastFunction<"string">;
};
/** @internal */
export declare function isURIEncodeFunction<T extends EastType>(f: EastFunction<T>): f is URIEncodeFunction<T>;
/** @internal */
export declare type URIDecodeFunction<T extends EastType = EastType> = {
    ast_type: "URIDecode";
    type: T;
    value: EastFunction<"string">;
};
/** @internal */
export declare function isURIDecodeFunction<T extends EastType>(f: EastFunction<T>): f is URIEncodeFunction<T>;
/** @internal */
export declare type NewSetFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "NewSet";
    values: EastFunction<"string">[];
};
/** @internal */
export declare function isNewSetFunction<T extends EastType>(f: EastFunction<T>): f is NewSetFunction<T>;
/** @internal */
export declare type ToSetFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "ToSet";
    collection: EastFunction<"set" | DictType | ArrayType>;
    input_value: Variable;
    input_key?: Variable;
    output_value: EastFunction<"string">;
};
/** @internal */
export declare function isToSetFunction<T extends EastType>(f: EastFunction<T>): f is ToSetFunction<T>;
/** @internal */
export declare type InFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "In";
    set: EastFunction<"set">;
    value: EastFunction<"string">;
};
/** @internal */
export declare function isInFunction<T extends EastType>(f: EastFunction<T>): f is InFunction<T>;
/** @internal */
export declare type SubsetEqualFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "SubsetEqual";
    first: EastFunction<"set">;
    second: EastFunction<"set">;
};
/** @internal */
export declare function isSubsetEqualFunction<T extends EastType>(f: EastFunction<T>): f is SubsetEqualFunction<T>;
/** @internal */
export declare type UnionFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Union";
    first: EastFunction<"set">;
    second: EastFunction<"set">;
};
/** @internal */
export declare function isUnionFunction<T extends EastType>(f: EastFunction<T>): f is UnionFunction<T>;
/** @internal */
export declare type IntersectFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Intersect";
    first: EastFunction<"set">;
    second: EastFunction<"set">;
};
/** @internal */
export declare function isIntersectFunction<T extends EastType>(f: EastFunction<T>): f is IntersectFunction<T>;
/** @internal */
export declare type SetDiffFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "SetDiff";
    first: EastFunction<"set">;
    second: EastFunction<"set">;
};
/** @internal */
export declare function isSetDiffFunction<T extends EastType>(f: EastFunction<T>): f is SetDiffFunction<T>;
/** @internal */
export declare type SymDiffFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "SymDiff";
    first: EastFunction<"set">;
    second: EastFunction<"set">;
};
/** @internal */
export declare function isSymDiffFunction<T extends EastType>(f: EastFunction<T>): f is SymDiffFunction<T>;
/** @internal */
export declare type NewDictFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "NewDict";
    keys: EastFunction<"string">[];
    values: EastFunction[];
};
/** @internal */
export declare function isNewDictFunction<T extends EastType>(f: EastFunction<T>): f is NewDictFunction<T>;
/** @internal */
export declare type KeysFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "Keys";
    dict: EastFunction<DictType>;
};
/** @internal */
export declare function isKeysFunction<T extends EastType>(f: EastFunction<T>): f is KeysFunction<T>;
/** @internal */
export declare type ToDictFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "ToDict";
    collection: EastFunction<"set" | DictType | ArrayType>;
    input_value: Variable;
    input_key?: Variable;
    output_value: EastFunction;
    output_key: EastFunction<"string">;
    previous_value?: Variable;
    initial_value?: EastFunction;
};
/** @internal */
export declare function isToDictFunction<T extends EastType>(f: EastFunction<T>): f is ToDictFunction<T>;
/** @internal */
export declare type NewArrayFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "NewArray";
    values: EastFunction[];
};
/** @internal */
export declare function isNewArrayFunction<T extends EastType>(f: EastFunction<T>): f is NewArrayFunction<T>;
/** @internal */
export declare type ToArrayFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "ToArray";
    collection: EastFunction<"set" | DictType | ArrayType>;
    input_value: Variable;
    input_key?: Variable;
    output_value: EastFunction;
};
/** @internal */
export declare function isToArrayFunction<T extends EastType>(f: EastFunction<T>): f is ToArrayFunction<T>;
/** @internal */
export declare type RangeFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "Range";
    start: EastFunction<"integer">;
    stop: EastFunction<"integer">;
};
/** @internal */
export declare function isRangeFunction<T extends EastType>(f: EastFunction<T>): f is RangeFunction<T>;
/** @internal */
export declare type GetFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "Get";
    dict: EastFunction<DictType<U>>;
    key: EastFunction<"string">;
    default: EastFunction<U>;
} | {
    type: U;
    ast_type: "Get";
    dict: EastFunction<ArrayType<U>>;
    key: EastFunction<"integer">;
    default: EastFunction<U>;
};
/** @internal */
export declare function isGetFunction<T extends EastType>(f: EastFunction<T>): f is GetFunction<T>;
/** @internal */
export declare type OnlyKeyFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "OnlyKey";
    dict: EastFunction<DictType>;
};
/** @internal */
export declare function isOnlyKeyFunction<T extends EastType>(f: EastFunction<T>): f is OnlyKeyFunction<T>;
/** @internal */
export declare type InsertFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "Insert";
    collection: EastFunction<U>;
    key?: EastFunction<"string">;
    value?: EastFunction;
};
/** @internal */
export declare function isInsertFunction<T extends EastType>(f: EastFunction<T>): f is InsertFunction<T>;
/** @internal */
export declare type DeleteFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "Delete";
    collection: EastFunction<U>;
    key: EastFunction<"string">;
};
/** @internal */
export declare function isDeleteFunction<T extends EastType>(f: EastFunction<T>): f is DeleteFunction<T>;
/** @internal */
export declare type SizeFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "Size";
    collection: EastFunction<"set" | DictType | ArrayType>;
};
/** @internal */
export declare function isSizeFunction<T extends EastType>(f: EastFunction<T>): f is SizeFunction<T>;
/** @internal */
export declare type FilterFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "Filter";
    collection: EastFunction<U>;
    predicate: EastFunction<"boolean">;
    value: Variable<EastType>;
    key?: Variable<"string" | "integer">;
};
/** @internal */
export declare function isFilterFunction<T extends EastType>(f: EastFunction<T>): f is FilterFunction<T>;
/** @internal */
export declare type MapValuesFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "MapDict";
    collection: EastFunction<EastType>;
    "function": EastFunction<EastType>;
    value: Variable<EastType>;
    key?: Variable<"string">;
};
/** @internal */
export declare function isMapValuesFunction<T extends EastType>(f: EastFunction<T>): f is MapValuesFunction<T>;
/** @internal */
export declare type ReduceFunction<U extends EastType = EastType, T extends EastType = EastType> = {
    type: U;
    ast_type: "Reduce";
    collection: EastFunction<EastType>;
    reducer: EastFunction<U>;
    initial: EastFunction<T>;
    previous: Variable<T>;
    value: Variable<T>;
    key?: Variable<"string" | "integer">;
};
/** @internal */
export declare function isReduceFunction<T extends EastType>(f: EastFunction<T>): f is ReduceFunction<T>;
/** @internal */
export declare type SortFunction<U extends EastType = EastType> = {
    type: U;
    ast_type: "Sort";
    collection: EastFunction<ArrayType>;
    isless: EastFunction<"boolean">;
    first: Variable<EastType>;
    second: Variable<EastType>;
};
/** @internal */
export declare function isSortFunction<T extends EastType>(f: EastFunction<T>): f is SortFunction<T>;
/** @internal */
export declare type FieldTypesOf<T> = T extends {
    type: "struct";
    fields: Record<string, EastType>;
} ? T["fields"] : never;
/** @internal */
export declare type FieldFunctionTypesOf<T> = T extends {
    type: "struct";
    fields: Record<string, EastType>;
} ? {
    [K in keyof T["fields"]]: EastFunction<T["fields"][K]>;
} : never;
/** @internal */
export declare type FieldTypeOf<T extends {
    type: "struct";
    fields: Record<string, EastType>;
}, K extends keyof T["fields"]> = T["fields"][K];
/** @internal */
export declare type StructFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Struct";
    fields: FieldFunctionTypesOf<T>;
};
/** @internal */
export declare function isStructFunction<T extends EastType>(f: EastFunction<T>): f is StructFunction<T>;
/** @internal */
export declare type GetFieldFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "GetField";
    struct: EastFunction<StructType>;
    key: string;
};
/** @internal */
export declare function isGetFieldFunction<T extends EastType>(f: EastFunction<T>): f is GetFieldFunction<T>;
/** @internal */
export declare type NewVariantFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "NewVariant";
    tag: string;
    value: EastFunction;
};
/** @internal */
export declare function isNewVariantFunction<T extends EastType>(f: EastFunction<T>): f is NewVariantFunction<T>;
/** @internal */
export declare type SwitchFunction<T extends EastType = EastType> = {
    type: T;
    ast_type: "Switch";
    input: EastFunction<VariantType>;
    functions: Record<string, EastFunction>;
    value: string | null;
};
/** @internal */
export declare function isSwitchFunction<T extends EastType>(f: EastFunction<T>): f is SwitchFunction<T>;
