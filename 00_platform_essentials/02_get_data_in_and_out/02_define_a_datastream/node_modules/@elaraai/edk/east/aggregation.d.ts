// Â© Copyright 2018- 2022 - Elara AI Pty Ltd ACN 627 124 903
//
// Licensed under the EDK Licence version LICENSE-1.04.
//
// You may only use this file in accordance with the terms and conditions contained in EDK
// Licence - Version LICENSE-1.04. The full version of the EDK Licence is available at:
// https://elaraai.github.io/docs/license

import { Expression } from './definition';
import { EastFunction, Variable } from './functions';
import { DictType, EastType, PrimitiveType } from './types';
/** An `CustomAggregation` represents a reduction over rows followed by an optional final transformation. */
/** @internal */
export declare type CustomAggregation<T extends EastType = EastType, U extends EastType = EastType> = {
    type: T;
    aggregation_type: "Custom";
    primary_key: EastFunction<"string">;
    previous: Variable<U>;
    initial: EastFunction<U>;
    reducer: EastFunction<U>;
    inverse_reducer: EastFunction<U>;
    finalizer: EastFunction<T>;
    field: Variable<T>;
};
/**
 * An {@link CustomAggregationDefinition} represents a reduction over rows followed by an optional final transformation.
 *
 * @category Aggregation
 */
export declare type CustomAggregationDefinition<T extends EastType = EastType, U extends EastType = EastType> = {
    type: T;
    aggregation_type: "Custom";
    previous: Variable<U>;
    initial: EastFunction<U>;
    reducer: EastFunction<U>;
    inverse_reducer: EastFunction<U>;
    finalizer: EastFunction<T>;
};
/** @internal */
export declare type StandardAggregationType = "Count" | "Sum" | "Mean" | "StdDev" | "Some" | "Every" | "DistinctCount" | "Unique" | "CollectSet" | "CollectDict" | "CollectDictCount" | "CollectDictSum" | "CollectDictMean" | "Mode" | "Minimum" | "Maximum" | "Span" | "Median" | "FindMinimum" | "FindMaximum";
/** A `StandardAggregation` calculates one of a handful of built-in reductions over rows. */
/** @internal */
export declare type StandardAggregation<T extends EastType = EastType, U extends StandardAggregationType = StandardAggregationType> = {
    type: T;
    aggregation_type: U;
    primary_key: EastFunction<"string">;
    value: EastFunction<PrimitiveType>;
    key?: EastFunction<PrimitiveType>;
    field: Variable<T>;
};
/**
 * A {@link StandardAggregationDefinition} calculates one of a handful of built-in reductions over rows.
 *
 * @category Aggregation
 */
export declare type StandardAggregationDefinition<T extends EastType = EastType, U extends StandardAggregationType = StandardAggregationType> = {
    type: T;
    aggregation_type: U;
    value: EastFunction<PrimitiveType>;
    key?: EastFunction<PrimitiveType>;
};
/** @internal */
export declare type AggregateValue<T extends Aggregation> = T extends Aggregation<infer T> ? T : never;
/** @internal */
export declare type Aggregation<T extends EastType = EastType> = CustomAggregation<T> | StandardAggregation<T>;
/**
 * A {@link AggregationDefinition} is either a {@link CustomAggregationDefinition} or {@link StandardAggregationDefinition}.
 *
 * @category Aggregation
 */
export declare type AggregationDefinition<T extends EastType = EastType> = CustomAggregationDefinition<T> | StandardAggregationDefinition<T>;
/**
 * Create an `Aggregation` to count the number of rows where `value` is not null.
 *
 * @param value_expr the value to aggregate
 * @returns the {@link Count} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // count the number of Category's that aren't null
 *      ValidCategories: Count(Variable('Category', 'string')),
 *      // ...
 *  }
 * ```
 */
export declare function Count(value_expr: Expression<PrimitiveType>): StandardAggregationDefinition<"integer">;
/**
 * Create an `Aggregation` to count the number of distinct, non-null values of `value`.
 *
 * @param value_expr the value to aggregate
 * @returns the {@link DistinctCount} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // count the number of distinct non-null Category's
 *      Categories: DistinctCount(Variable('Category', 'string')),
 *      // ...
 *  }
 * ```
 */
export declare function DistinctCount(value_expr: Expression<PrimitiveType>): StandardAggregationDefinition<"integer">;
/**
 * Create an `Aggregation` to find the unique non-null value of `value`. If multiple non-null values are encountered, it returns null.
 *
 * @param value_expr the value to aggregate
 * @returns the {@link Unique} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // count the number of unique non-null Category's
 *      Categories: Unique(Variable('Category', 'string')),
 *      // ...
 *  }
 * ```
 */
export declare function Unique<T extends PrimitiveType>(value_expr: Expression<T>): StandardAggregationDefinition<T>;
/**
 * Create an {@link AggregationDefinition} to find the sum of the non-null values of `value` (which defaults to `field`).
 *
 * @param value_expr the value to aggregate
 * @returns the {@link Sum} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // sum all Qty's to find the total
 *      TotalQty: Sum(Variable('Qty', 'integer')),
 *      // ...
 *  }
 * ```
 */
export declare function Sum(value_expr: Expression<"integer">): StandardAggregationDefinition<"integer">;
export declare function Sum(value_expr: Expression<"float">): StandardAggregationDefinition<"float">;
/**
 * Create an {@link AggregationDefinition} to find the mean of the non-null values of `value` (which defaults to `field`).
 *
 * @param value_expr the value to aggregate
 * @returns the {@link Mean} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // find the mean Qty's
 *      MeanQty: Mean(Variable('Qty', 'integer')),
 *      // ...
 *  }
 * ```
 */
export declare function Mean(value_expr: Expression<"float">): StandardAggregationDefinition<"float">;
export declare function Mean(value_expr: Expression<"integer">): StandardAggregationDefinition<"integer">;
/**
 * Create an {@link AggregationDefinition} to find the standard deviation of the non-null values of `value` (which defaults to `field`).
 *
 * @param value_expr the value to aggregate
 * @returns the {@link StdDev} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // find the std deviation of Qty's
 *      StdDevQty: StdDev(Variable('Qty', 'integer')),
 *      // ...
 *  }
 * ```
 */
export declare function StdDev(value_expr: Expression<"float">): StandardAggregationDefinition<"float">;
export declare function StdDev(value_expr: Expression<"integer">): StandardAggregationDefinition<"integer">;
/**
 * Create an {@link AggregationDefinition} to find the set of the non-null string values of `value` (which defaults to `field`).
 *
 * @param value_expr the value to aggregate
 * @returns the {@link CollectSet} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // collect all non-null Categorie's into a set
 *      Categories: CollectSet(Variable('Category', 'string')),
 *      // ...
 *  }
 * ```
 */
export declare function CollectSet(value_expr: Expression<"string">): StandardAggregationDefinition<"set">;
/**
 * Create an {@link AggregationDefinition} to create a dictionary of distinct key-value pairs. If multiple distinct, non-null values  exist for a given key, then the value is `null` for that key.
 *
 * @param key_expr the dict key value
 * @param value_expr the value to aggregate
 * @returns the {@link CollectDict} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // collect all non-null HourlyRate's into a dictionary by EmployeeId
 *      HourlyRatePerEmployee: CollectDict(
 *          Variable('EmployeeId', 'string'),
 *          Variable('HourlyRate', 'float')
 *      ),
 *      // ...
 *  }
 * ```
 */
export declare function CollectDict<T extends PrimitiveType>(key_expr: Expression<"string">, value_expr: Expression<T>): StandardAggregationDefinition<DictType<T>>;
/**
 * Create an {@link AggregationDefinition} to create a dictionary of the count of non-null keys
 *
 * @param key_expr the dict key value
 * @returns the {@link CollectDictCount} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // create a dictionary with the count of products by Category
 *      ProductsPerCategory: CollectDictCount(
 *          Variable('Category', 'string')),
 *      ),
 *      // ...
 *  }
 * ```
 */
export declare function CollectDictCount(value_expr: Expression<"string">): StandardAggregationDefinition<DictType<"integer">>;
/**
 * Create an {@link AggregationDefinition} to create a dictionary of the sum of non-null values for key-value pairs.
 *
 * @param key_expr the dict key value
 * @param value_expr the value to aggregate
 * @returns the {@link CollectDictSum} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // create a dictionary with the sum of Qty's by Category
 *      QtyPerCategory: CollectDictSum(
 *          Variable('Category', 'string')),
 *          Variable('Qty', 'integer'))
 *      ),
 *      // ...
 *  }
 * ```
 */
export declare function CollectDictSum<T extends "float" | "integer">(key_expr: Expression<"string">, value_expr: Expression<T>): StandardAggregationDefinition<DictType<T>>;
/**
 * Create an {@link AggregationDefinition} to create a dictionary of the sum of non-null values for key-value pairs.
 *
 * @param key_expr the dict key value
 * @param value_expr the value to aggregate
 * @returns the {@link CollectDictMean} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // create a dictionary with the average of Price per Category
 *      MeanPricePerCategory: CollectDictMean(
 *          Variable('Category', 'string')),
 *          Variable('Price', 'integer'))
 *      ),
 *      // ...
 *  }
 * ```
 */
export declare function CollectDictMean(key_expr: Expression<"string">, value_expr: Expression<"float" | "integer">): StandardAggregationDefinition<DictType<'float'>>;
/**
 * Create an {@link AggregationDefinition} that returns true if one or more value is `true`.
 *
 * @param value_expr the value to aggregate
 * @returns the {@link Some} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // return true if a category value is null
 *      CategoryMissing: Some(Equal(Variable('Category', 'string'), Null('string'))),
 *      // ...
 *  }
 * ```
 */
export declare function Some(value_expr: EastFunction<"boolean">): StandardAggregationDefinition;
/**
 * Create an {@link AggregationDefinition} that returns true if all values are `true`
 *
 * @param value_expr the value to aggregate
 * @returns the {@link Every} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // return true if all category values are null
 *      AllCategoriesMissing: Every(
 *          Equal(
 *              Variable('Category', 'string'),
 *              Null('string')
 *          )
 *      ),
 *      // ...
 *  }
 * ```
 */
export declare function Every(value_expr: EastFunction<"boolean">): StandardAggregationDefinition;
/**
 * Create an {@link AggregationDefinition} to find the most common, non-null value of `value` (which defaults to `field`). If a tie is encountered, any one of the most-common values is chosen.
 *
 * @category Aggregation
 */
/**
 * Create an {@link AggregationDefinition} to find the most common, non-null value of `value` (which defaults to `field`). If a tie is encountered, any one of the most-common values is chosen.
 *
 * @param value_expr the value to aggregate
 * @returns the {@link Mode} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // return the mode of prices
 *      ModalPrice: Mode(Variable('Price', 'float')),
 *      // ...
 *  }
 * ```
 */
export declare function Mode<T extends PrimitiveType>(value_expr: EastFunction<T>): StandardAggregationDefinition<T>;
/**
 * Create an {@link AggregationDefinition} to find the smallest, non-null value of `value` (which defaults to `field`).
 *
 * @param value_expr the value to aggregate
 * @returns the {@link Minimum} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // return the lowest Price
 *      MinPrice: Minimum(Variable('Price', 'float')),
 *      // ...
 *  }
 * ```
 */
export declare function Minimum<T extends PrimitiveType>(value_expr: EastFunction<T>): StandardAggregationDefinition<T>;
/**
 * Create an {@link AggregationDefinition} to find the largest, non-null value of  `value` (which defaults to `field`).
 *
 * @param value_expr the value to aggregate
 * @returns the {@link Maximum} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // return the highest Price
 *      MaxPrice: Maximum(Variable('Price', 'float')),
 *      // ...
 *  }
 * ```
 */
export declare function Maximum<T extends PrimitiveType>(value_expr: EastFunction<T>): StandardAggregationDefinition<T>;
/**
 * Create an {@link AggregationDefinition} to find the span of the non-null values of `value` (which defaults to `field`), meaning the difference between the largest and smallest values.
 *
 * @param value_expr the value to aggregate
 * @returns the {@link Span} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // return the Price span
 *      PriceSpan: Span(Variable('Price', 'float')),
 *      // ...
 *  }
 * ```
 */
export declare function Span<T extends "float" | "integer">(value_expr: EastFunction<T>): StandardAggregationDefinition<T>;
/**
 * Create an {@link AggregationDefinition} to find the smallest, non-null value of `value` (which defaults to `field`).
 *
 * @param value_expr the value to aggregate
 * @param key_expr the value to find the minimum of
 * @returns the {@link FindMinimum} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // return Product with the lowest Price
 *      LowestPriceProduct: FindMinimum(
 *          Variable('Price', 'float'),
 *          Variable('Product', 'string')
 *      ),
 *      // ...
 *  }
 * ```
 */
export declare function FindMinimum<T extends PrimitiveType>(value_expr: EastFunction<PrimitiveType>, key_expr: EastFunction<T>): StandardAggregationDefinition<T>;
/**
 * Create an {@link AggregationDefinition} to find the `key` corresponding to the largest, non-null value of `value` (which defaults to `field`).
 *
 * @param value_expr the value to aggregate
 * @param key_expr the value to find the minimum of
 * @returns the {@link FindMaximum} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // return Product with the lowest Price
 *      HighestPriceProduct: FindMaximum(
 *          Variable('Price', 'float'),
 *          Variable('Product', 'string')
 *      ),
 *      // ...
 *  }
 * ```
 */
export declare function FindMaximum<T extends PrimitiveType>(value_expr: EastFunction<PrimitiveType>, key_expr: EastFunction<T>): StandardAggregationDefinition<T>;
/**
 * Create an {@link AggregationDefinition} to find the median of the non-null values of `value` (which defaults to `field`). In case of a tie, the greater number is returned.
 *
 * @param value_expr the value to aggregate
 * @returns the {@link Median} {@link StandardAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // return the middle Price
 *      MedianPrice: Median(Variable('Price', 'float')),
 *      // ...
 *  }
 * ```
 */
export declare function Median<T extends "float" | "integer">(value_expr: EastFunction<T>): StandardAggregationDefinition<T>;
/**
 *
 *
 * @category Aggregation
 */
/**
 * Create an {@link AggregationDefinition} to calculate the sum of the values of a "sparse" dictionary where missing elements are presumed to have value of zero.
 *
 * @param value_expr the value to aggregate
 * @returns the {@link SparseDictSum} {@link CustomAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // return the ...
 *      PriceCardTotal: SparseDictSum(Variable('PriceCard', DictType('float'))),
 *      // ...
 *  }
 * ```
 */
export declare function SparseDictSum(value_expr: Expression<DictType<"float">>): AggregationDefinition<DictType<"float">>;
export declare function SparseDictSum(value_expr: Expression<DictType<"integer">>): AggregationDefinition<DictType<"integer">>;
/**
 * Create an {@link AggregationDefinition} to calculate the average values of a "sparse" dictionary where missing elements are presumed to have value of zero.
 *
 * @param value_expr the value to aggregate
 * @returns the {@link SparseDictMean} {@link CustomAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // return the ...
 *      PriceCardAvg: SparseDictMean(Variable('PriceCard', DictType('float'))),
 *      // ...
 *  }
 * ```
 */
export declare function SparseDictMean(value_expr: Expression<DictType<"integer">>): AggregationDefinition<DictType<"float">>;
export declare function SparseDictMean(value_expr: Expression<DictType<"float">>): AggregationDefinition<DictType<"float">>;
/**
 * Create an {@link AggregationDefinition} to calculate the variance of the values of a "sparse" dictionary where missing elements are presumed to have value of zero.
 *
 * @param value_expr the value to aggregate
 * @returns the {@link SparseDictMean} {@link CustomAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // return the ...
 *      PriceCardVariance: SparseDictVariance(Variable('PriceCard', DictType('float'))),
 *      // ...
 *  }
 * ```
 */
export declare function SparseDictVariance(value_expr: Expression<DictType<"float">>): AggregationDefinition<DictType<"float">>;
export declare function SparseDictVariance(value_expr: Expression<DictType<"integer">>): AggregationDefinition<DictType<"float">>;
/**
 * Create an {@link AggregationDefinition} to calculate the covariance of the values of a "sparse" dictionary where missing elements are presumed to have value of zero.
 *
 * @param value_expr the value to aggregate
 * @returns the {@link SparseDictMean} {@link CustomAggregationDefinition}
 *
 * @category Aggregation
 *
 * @example
 * ```typescript
 *  // ...
 *  aggregations: {
 *      // return the ...
 *      PriceCardCoVariance: SparseDictCovariance(Variable('PriceCard', DictType('float'))),
 *      // ...
 *  }
 * ```
 */
export declare function SparseDictCovariance(value_expr: Expression<DictType<"float">>): AggregationDefinition<DictType<DictType<"float">>>;
export declare function SparseDictCovariance(value_expr: Expression<DictType<"integer">>): AggregationDefinition<DictType<DictType<"float">>>;
/** @internal */
export declare function toAggregation(def: AggregationDefinition, key: string, primary_key: EastFunction<"string">): Aggregation;
/** @internal */
export declare function checkAggregationInput(aggregation: Aggregation, variables: Record<string, Variable>): void;
